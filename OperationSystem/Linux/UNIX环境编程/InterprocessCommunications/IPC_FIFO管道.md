- [IPC FIFO 管道](#ipc-fifo- 管道)
  - [基本概念](#基本概念)
  - [基本 API](#基本 -api)
  - [性能问题](#性能问题)
  - [1. 并发安全](#1- 并发安全)
  - [2. Refer Links](#2-refer-links)

# IPC FIFO 管道

## 基本概念

## 基本 API

## 性能问题

阅读 FIFO 的 32 位 linux2.6.16.60 内核实现可知，无论是读还是写，FIFO 都加了互斥锁 mutex_lock，FIFO 的内核实现是不那么精致的，至少在锁的处理上来看，即使是一个读和一个写或者是多个同时读都需要互斥，就可能导致进程挂起，从而产生延迟大增的毛刺现象。经过测试，FIFO 的 write 操作比 udp socket 的 write 操作速度在没有竞争的情况下快近 10 倍，但是在有竞争的情况下，则 FIFO 的 write 延迟会下降很多，几乎与 udp socket 的 write 相近。

因此，从应用程序的角度上看，要降低因为 FIFO 互斥导致的进程阻塞现象，最好就是合理降低对 FIFO 的读写频率，使得冲突发生的现象尽量降低。另外，对 FIFO 的内核实现应该是可以再优化的，起码读写锁或者 lockfree 之类的设计是可以做的，不过 2.6.22 内核之后，已经提供了 eventfd 来替代 pipe 和 FIFO 在这方面的应用了，eventfd 的实现非常高效，不过也有点小缺点，在没有亲缘关系的进程之间需要事先用 unix socket 传递 eventfd 句柄。

## 1. 并发安全

试想这样一个问题，只使用一个 FIFO 文件，如果有多个进程同时向同一个 FIFO 文件写数据，而只有一个读 FIFO 进程在同一个 FIFO 文件中读取数据时，会发生怎么样的情况呢，会发生数据块的相互交错是很正常的？而且个人认为多个不同进程向一个 FIFO 读进程发送数据是很普通的情况。

为了解决这一问题，就需要实现写操作的原子化。怎样才能使写操作原子化呢？答案很简单，系统规定：在一个以 O_WRONLY（即阻塞方式）打开的 FIFO 中， 如果写入的数据长度小于等待 PIPE_BUF，那么或者写入全部字节，或者一个字节都不写入。如果所有的写请求都是发往一个阻塞的 FIFO 的，并且每个写记请求的数据长度小于等于 PIPE_BUF 字节，系统就可以确保数据决不会交错在一起。

## 2. Refer Links
todo:
[Linux 进程间通信——使用命名管道](https://blog.csdn.net/ljianhui/article/details/10202699)

[深入剖析命名管道 FIFO 对程序性能的影响](https://blog.csdn.net/hmings/article/details/8110371)