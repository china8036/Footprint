- [Linux 进程管理](#linux-进程管理)
  - [1. 基本概念](#1-基本概念)
  - [2. Refer Links](#2-refer-links)

# Linux 进程管理

## 1. 基本概念

在 unix/Linux 中，正常情况下子进程是通过父进程创建的，而父进程永远无法预测子进程到底什么时候结束。**当一个进程完成它的工作终止之后，它的父进程需要调用 wait() 或者 waitpid() 系统调用取得子进程的终止状态**。

- 孤儿进程

  **一个父进程退出，而它的一个或多个子进程还在运行**，那么那些子进程就称为孤儿进程。
  
  孤儿进程将被 init 进程（进程号 PID 为 1）所收养，并由 init 进程对它们完成状态收集工作。孤儿进程并不会有什么危害。

- 僵尸进程

  一个进程使用 fork 创建了子进程后，如果父进程没有调用 wait 或 waitpid 获取子进程的状态信息，会导致**子进程执行完毕退出后，子进程的进程描述符却仍保存在系统中**。这时子进程就称为僵尸进程。

  在每个进程退出的时候，内核会释放该进程的资源，包括打开的文件、占用的内存等。但仍会为其保留一定的信息（包括进程号、退出状态、运行时间等），直到父进程通过 wait / waitpid 来取时才完全释放。因此，如果进程不调用 wait / waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是**系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程**。

- 用户态和内核态

  Linux 使用两级保护机制：0 级供内核使用，3 级供用户程序使用。

  - 当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0 级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。

  - 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。此时处理器在特权级最低的（3 级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。

- 进程上下文和中断上下文

  - 进程上下文：可以看作是用户进程通过系统调用陷入内核态时，传递给内核的参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。
    
    一个进程的上下文可以分为三个部分：
    - 用户级上下文：正文、数据、用户堆栈以及共享存储区。
    - 寄存器上下文：通用寄存器、程序寄存器 (IP)、处理器状态寄存器 (EFLAGS)、栈指针 (ESP)。
    - 系统级上下文：进程控制块 task_struct、内存管理信息 (mm_struct、vm_area_struct、pgd、pte)、内核栈。
    
    当发生进程调度时，进行进程切换就是上下文切换 (context switch). 操作系统必须对上面提到的全部信息进行切换，新调度的进程才能运行。而系统调用进行的模式切换 (mode switch)。模式切换与进程切换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是切换进程寄存器上下文的切换。

  - 中断上下文：可以看作是硬件通过触发信号，导致内核调用中断处理程序，进入内核空间时，传递的参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。

    中断时，内核不代表任何进程运行，它一般只访问系统空间，而不会访问进程空间，内核在中断上下文中执行时一般不会阻塞。

- 硬中断和软中断
  
  从本质上来讲，中断是一种电信号，当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器。如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，跳到中断处理程序的入口点，进行中断处理。
  - 硬中断：由与系统相连的外设（比如网卡、硬盘) 自动产生的。主要是用来通知操作系统系统外设状态的变化。比如当网卡收到数据包的时候，就会发出一个中断。我们通常所说的中断指的是硬中断 (hardirq)。
    - 硬中断是由外设引发的。
    - 硬中断的中断号是由中断控制器提供的。
    - 硬中断是可屏蔽的。
    - 硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，属于上半部。

  - 软中断：为了满足实时系统的要求，中断处理应该是越快越好。linux 为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断 (softirq) 来完成。
    - 软中断是执行中断指令产生的。
    - 软中断的中断号由指令直接指出，无需使用中断控制器。
    - 软中断不可屏蔽。
    - 软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。 

## 2. Refer Links

[孤儿进程与僵尸进程](https://www.cnblogs.com/Anker/p/3271773.html)

[用户空间与内核空间，进程上下文与中断上下文](https://www.cnblogs.com/Anker/p/3269106.html)

[硬中断和软中断](https://blog.csdn.net/zhangskd/article/details/21992933)

TODO:

[CPU 检测到中断信号时，怎么知道是发给哪个进程的？](https://www.zhihu.com/question/47862508)

[内核态是指一个特殊的进程，还是指进程的一种特殊状态？](https://www.zhihu.com/question/40147261)

[一个进程所能分配的最大内存是多大？这是由什么决定的？](https://www.zhihu.com/question/29468200)

