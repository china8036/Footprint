- [Shell 运算符](#shell-运算符)
  - [1. 算术运算符](#1-算术运算符)
  - [2. 关系运算符](#2-关系运算符)
  - [3. 布尔运算符](#3-布尔运算符)
  - [4. 字符串运算符](#4-字符串运算符)
  - [5. 文件测试运算符](#5-文件测试运算符)
  - [6. 括号运算符](#6-括号运算符)
    - [6.1. 单小括号](#61-单小括号)
    - [6.2. 双小括号](#62-双小括号)
    - [6.3. 单方括号](#63-单方括号)
    - [6.4. 双方括号](#64-双方括号)
    - [6.5. 大括号](#65-大括号)
  - [7. Refer Links](#7-refer-links)

# Shell 运算符

## 1. 算术运算符

- 加法：`+`
- 减法：`-`
- 乘法：`*`
- 除法：`/`
- 取余：`%`
- 赋值：`=`
- 相等：`==` 或 `=`
- 不等：`!=`
- 大于：`>`
- 大于等于：`>=`
- 小于：`<`
- 小于等于：`<=`

NOTE
- 原生 bash 不支持数学运算，需要借助工具进行，如 `expr`、`let`、`awk`、`bc`。
- `expr`
  - `expr 左操作数 运算符 右操作数` 注意空格不可忽略。
  - `expr length str` 求字符串长度。
  - `expr index str1 str2` 求 str2 在 str1 中的索引。
  - `expr match string regex` 检查 string 是否能被正则表达式匹配。
- 对于 `*`、`>`、`>=`、`<`、`<=`，在使用时必须加转义符或使用单引号括起来，如 `expr 10 \* 3`、`expr 10 '*' 3`。

## 2. 关系运算符

- `-eq`
- `-ne`
- `-gt`
- `-lt`
- `-ge`
- `-le`

## 3. 布尔运算符

- `!`
- `-o`
- `-a`

eg:
```
[ ! expr ]
[ expr1 -o expr2] <=> [ expr1 ] || [ expr2 ]
[ expr1 -a expr2] <=> [ expr1 ] && [ expr2 ]
```

## 4. 字符串运算符

- `==` 或 `=`
- `!=`
- `=~`: 检测字符串是否能被正则表达式所匹配，如 `[[ ${str} =~ ^[0-9]+ ]]`。
- `-z`: 检测字符串长度是否为 0，为 0 返回 1，如 `[ -z $str ]`。
- `-n`: 检测字符串长度是否不为 0，为 0 返回 0，如 `[ -n #str ]`。
- `str`: 检测字符串是否非空，不为空返回 1，如 `[ $str ]`。

## 5. 文件测试运算符

- 文件类型
  - `-b`: 判断是否为块设备。
  - `-c`: 判断是否为字符设备文件。
  - `-f`: 判断是否为普通文件。
  - `-p`: 判断是否为管道文件。
  - `-d`: 判断是否为目录。
- 文件属性
  - `-r`: 判断是否为只读。
  - `-w`: 判断是否为可写。
  - `-x`: 判断是否为可执行。

- `-e` 判断文件是否存在。
- `-s` 判断文件长度是否大于 0.
- `-ef` 判断文件 inode 是否相等。

## 6. 括号运算符

### 6.1. 单小括号

- 命令组：解释器会重新开一个子 shell 来专门执行 `()` 中的命令，且括号中的变量不可与外边共用。多条命令用 `;` 分隔。
- 命令替换：`$(cmd)`，返回命令执行结果。
- 初始化数组：`array=(a b c d e)`。

### 6.2. 双小括号

- 可在 `(())` 中执行符合 C 语言语法规则的代码
  
  eg1:
  ```shell
  for ((var=1; var <= 5; var++));do ...;done
  ```
  eg2:
  ```shell
  ((i++))
  i=$((i++))
  i=$(($i+1))
  ```
  eg3:
  ```shell
  $((1&&0))
  ```

- 可通过 `$((n # xxx))` 将 n 进制的 xxx 转化为十进制

### 6.3. 单方括号

- 相当于 `test`。
- 正则表达式中的 ERE 元字符。
- 引用数组元素。
- 做算术运算，如 `echo $[ $a + $b ]`。

### 6.4. 双方括号

- `[[]]` 中的所有字符都不会发生文件名扩展或单词分割，但可能会发生参数扩展和命令替换。
- `[[]]` 中的字符串、通配符、正则表达式都不用加引号。
- `[[]]` 中可进行正则匹配检测，如 `[[ hello == hell? ]]`。
- **`[[]]` 中支持使用 `||`、`&&`、`<`、`>`，而在 `[]` 中不支持，应使用 `-a` / `-o`**。
- 对于每个 `[[]]`，bash 执行完毕后都会返回其退出状态码。

### 6.5. 大括号

- 作为通配符进行文件名扩展
  - eg: `touch {a,b,c}.txt` <=> `touch a.txt; touch b.txt; touch c.txt`.
  - eg: `touch {a[1-3],a4}.txt` <=> `touch a1; touch a2; touch a3; touch a4`.

- 代码块
  - 与 `()` 不同，`{}` 不会创建子 shell 来执行。
  - `{` 与第一个命令之间必须要有空格。

- 特殊替换结构
  - `${var:-word}`: 若变量 var 为空或已被 unset，返回 word 值。
  - `${var:=word}`: 若变量 var 为空或已被 unset，返回 word 值并把 word 值赋值给 var。
  - `${var:+word}`: 若变量 var 已被定义，返回 word 值。
  - `${var:?msg}`: 若变量 var 为空或已被 unset，将 msg 输出到标准错误输出。
  - `${var%pattern}`: 若 var 以 pattern 匹配的模式结尾，则删除 var 中右边最短的匹配。
  - `${var%%pattern}`: 若 var 以 pattern 匹配的模式结尾，则删除 var 中右边最长的匹配。
  - `${var#pattern}`: 若 var 以 pattern 匹配的模式开头，则删除 var 中左边最短的匹配。
  - `${var##pattern}`: 若 var 以 pattern 匹配的模式开头，则删除 var 中左边最长的匹配。

## 7. Refer Links
