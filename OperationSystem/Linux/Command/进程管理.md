- [进程管理](#进程管理)
  - [1. 进程状态](#1-进程状态)
  - [2. 前后台切换](#2-前后台切换)
  - [3. 自动交互 expect](#3-自动交互-expect)
    - [3.1. TCL](#31-tcl)
    - [3.2. Command](#32-command)
  - [4. kill](#4-kill)
  - [5. pstree](#5-pstree)
  - [6. Refer Links](#6-refer-links)

# 进程管理

## 1. 进程状态

## 2. 前后台切换

- ctrl+c 退出前台的命令，不再执行

- ctrl+z 挂起前台命令暂停执行，回到 shell 命令行环境中

- jobs 察看当前 shell 下运行的所有程序。
  - 带 + 表示最新的 jobs
  - 带 - 表示次新的 jobs
  - 其他 jobs 不带符号 -bg 将刚挂起的命令放到后台运行
  - bg %3  将第三个 job 放到后台运行
  - kill %3  杀死第三个 job，不再执行
- fg 将刚挂起的命令返回前台运行
  - fg %3  将第三个 job 返回前台运行

- command & 直接在后台运行程序（退出终端就终止？TODO:）
- nohup，即 no hang up：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用 nohup 命令。该命令可以在你退出帐户 / 关闭终端之后继续运行相应的进程。长命令必须写在 shell 文件中，否则 nohup 不起作用。eg:
  ```
  nohup command &                 // 该命令的一般形式
  nohup command > myout.file 2>&1 &      //log 输出到 myout.file，并将标准错误输出重定向到标准输出，再被重定向到 myout.file
  nohup command 1>output 2>&1 &
  ```
  https://blog.csdn.net/zjc/article/details/51484114

## 3. 自动交互 expect

TODO:

> Expect is a program that "talks" to other interactive programs according to a script. Following the script, Expect knows what can be expected from a program and what the correct response should be.  An interpreted language provides branching and high-level control structures to direct the dialogue. In addition, the user can take control and interact directly when desired, afterward returning control to the script.

[Expect](https://linux.die.net/man/1/expect) 是一个为了处理“自动交互”的工具，它可以控制、处理输入，输出流，然后提供自动填写数据等需要用户交互式输入的数据的地方实现自动化处理。Expect 支持自定义的脚本，可以通过编写自定义脚本来实现自动填写数据的功能。

### 3.1. TCL

Expect 采用的是一种叫做 [Tcl(Tool Command Language)](http://www.tcl.tk/man/tcl8.5/) 的脚本语言，但也支持 Python 和 Perl 语言。

### 3.2. Command

expect 中的基本命令有 expect、spawn、send、wait：
- send：用于向进程发送字符串
- expect：从进程接收字符串
- spawn：启动新的进程
- interact：允许用户交互

## 4. kill

> The kill utility sends a signal to the processes specified by the pid operands. Only the super-user may send signals to other users' processes.

Usage:
```
kill [Options] [pids]
```

Options:
- `-s signal_name`: A symbolic signal name specifying the signal to be sent instead of the default TERM.

- `-l [exit_status]`: If no operand is given, list the signal names; otherwise, write the signal name corresponding to exit_status.

  e.g.
  - `kill -l`: 列出所有可用的信号
  - `kill -l 9`: 列出退出码为 9 的信号的信号名。

- `-signal_name`: A symbolic signal name specifying the signal to be sent instead of the default TERM.

- `-signal_number`: A non-negative decimal integer, specifying the signal to be sent instead of the default TERM.

  常用 signal_number:
  - `1`: HUP (hang up) 平滑重启，即重新读取配置文件后重启，保留原进度
  - `2`: INT (interrupt)
  - `3`: QUIT (quit)
  - `6`: ABRT (abort)
  - `9`: KILL (non-catchable, non-ignorable kill) 强制退出进程
  - `14`: ALRM (alarm clock)
  - `15`: TERM (software termination signal) 正常终止进程（默认情况）

  e.g.
  - `kill -1 [PID]` 与 `kill -HUP [PID]` 的效果是完全一样的。

NOTE: 当 PID 为 -1 时，kill 命令将指定信号发送 / 广播给当前用户的所有进程。If superuser, broadcast the signal to all processes.

tl.dr.
```
  kill

  Sends a signal to a process, usually related to stopping the process.
  All signals except for SIGKILL and SIGSTOP can be intercepted by the process to perform a clean exit.

  - Terminate a program using the default SIGTERM (terminate) signal:
    kill process_id

  - List available signal names (to be used without the SIG prefix):
    kill -l

  - Terminate a program using the SIGHUP (hang up) signal. Many daemons will reload instead of terminating:
    kill -1|HUP process_id

  - Terminate a program using the SIGINT (interrupt) signal. This is typically initiated by the user pressing Ctrl + C:
    kill -2|INT process_id

  - Signal the operating system to immediately terminate a program (which gets no chance to capture the signal):
    kill -9|KILL process_id

  - Signal the operating system to pause a program until a SIGCONT ("continue") signal is received:
    kill -17|STOP process_id

  - Send a SIGUSR1 signal to all processes with the given GID (group id):
    kill -SIGUSR1 -group_id
```

e.g. 清除 ZOMBIE（僵尸）进程可以使用如下方法：
- `kill –18 PPID` (PPID 是其父进程): 告诉父进程，该子进程已经死亡了，请收回分配给他的资源。
- `kill –15 PID1 PID2 (PID1,PID2 是僵尸进程的父进程的其它子进程);kill –15 PPID`: 直接终止其父进程（如果其父进程不需要的话）。先看其父进程又无其他子进程，如果有，可能需要先 kill 其他子进程，也就是兄弟进程。然后再 kill 父进程。

## 5. pstree

## 6. Refer Links

[Linux 前台、后台、挂起、退出、查看命令汇总](https://blog.csdn.net/matthewei6/article/details/50573592)

[Linux 技巧：让进程在后台可靠运行的几种方法](https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/index.html)