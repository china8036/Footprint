- [System Operation](#system-operation)
  - [1. 系统信息](#1-系统信息)
    - [1.1. 内核版本](#11-内核版本)
    - [1.2. 系统版本](#12-系统版本)
    - [1.3. 系统位数](#13-系统位数)
  - [2. taskset](#2-taskset)
  - [3. ps](#3-ps)
  - [4. top](#4-top)
    - [4.1. 动态信息监控](#41-动态信息监控)
    - [4.2. 交互操作指令](#42-交互操作指令)
    - [4.3. 线程查看模式](#43-线程查看模式)
    - [4.4. 批量模式](#44-批量模式)
    - [4.5. 实现原理](#45-实现原理)
  - [5. free](#5-free)
  - [6. df](#6-df)
  - [7. du](#7-du)
  - [8. 实时统计工具 (stat)](#8-实时统计工具-stat)
    - [8.1. vmstat](#81-vmstat)
    - [8.2. mpstat](#82-mpstat)
    - [8.3. iostat](#83-iostat)
    - [8.4. pidstat](#84-pidstat)
  - [9. strace](#9-strace)
  - [10. ipcs](#10-ipcs)
  - [11. ipcrm](#11-ipcrm)
  - [12. watch](#12-watch)
  - [13. uptime](#13-uptime)
  - [14. lsof](#14-lsof)
  - [15. perf](#15-perf)
    - [15.1. 基本原理](#151-基本原理)
    - [15.2. 基本使用](#152-基本使用)
      - [15.2.1. stat](#1521-stat)
      - [15.2.2. record](#1522-record)
      - [15.2.3. report](#1523-report)
      - [15.2.4. top](#1524-top)
      - [15.2.5. script](#1525-script)
  - [17. Refer Links](#17-refer-links)

# System Operation

## 1. 系统信息

### 1.1. 内核版本

- `cat /proc/version`

  eg:
  ```bash
  $ cat /proc/version
  Linux version 4.4.0-43-Microsoft (Microsoft@Microsoft.com) (gcc version 5.4.0 (GCC) ) #1-Microsoft Wed Dec 31 14:42:53 PST 2014
  ```

- `uname -a`

  ```bash
  $ uname -a
  Linux firejqwei-PC1 4.4.0-43-Microsoft #1-Microsoft Wed Dec 31 14:42:53 PST 2014 x86_64 x86_64 x86_64 GNU/Linux
  ```

- `uname -r`

  ```bash
  $ uname -r
  4.4.0-43-Microsoft
  ```

### 1.2. 系统版本

- `cat /etc/issue`

  eg:
  ```bash
  $ cat /etc/issue
  Ubuntu 16.04.5 LTS \n \l
  ```

### 1.3. 系统位数

- `file /bin/<command>`
  
  eg:
  ```bash
  $ file /bin/ls
  /bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, stripped
  ```

## 2. taskset

https://www.cnblogs.com/liuhao/archive/2012/06/21/2558069.html

taskset 可以查看、设定单个进程运行的 CPU。

```
Options:
 -a, --all-tasks         operate on all the tasks (threads) for a given pid
 -p, --pid               operate on existing given pid
 -c, --cpu-list          display and specify cpus in list format
 -h, --help              display this help
 -V, --version           output version information
```

NOTE: 此命令返回的是十六进制的，转换成二进制后，每一位对应一个逻辑 CPU，低位是 0 号 CPU，依次类推。如果每个位置上是 1，表示该进程绑定了该 CPU。例如，0101 就表示进程绑定在了 0 号和 3 号逻辑 CPU 上了。

以下均以 redis-server 举例：
- 显示进程运行的 CPU
  ```
  taskset -p 21184
  ```
  显示结果：
  ```
  pid 21184's current affinity mask: ffffff
  ```
  注：
  - 21184 是 redis-server 运行的 pid.
  - 显示结果的 ffffff 实际上是二进制 24 个低位均为 1 的 bitmask，每一个 1 对应于 1 个 CPU，表示该进程在 24 个 CPU 上运行。
- 指定进程运行在某个特定的 CPU 上
  ```
  taskset -pc 3 21184
  ```
  显示结果：
  ```
  pid 21184's current affinity list: 0-23
  pid 21184's new affinity list: 3
  ```
  注：3 表示 CPU 将只会运行在第 4 个 CPU 上（从 0 开始计数）。

- 进程启动时指定 CPU
  ```
  taskset -c 1 ./redis-server ../redis.conf
  ```

## 3. ps

[ps](http://man7.org/linux/man-pages/man1/ps.1.html) displays information about a selection of the active processes. If you want a repetitive update of the selection and the displayed information, use top instead.

This version of ps accepts several kinds of options:
- UNIX options, which may be grouped and must be preceded by a dash. eg: `ps -ef`
- BSD options, which may be grouped and must not be used with a dash. ef: `ps aux`
- GNU long options, which are preceded by two dashes.

eg:
- 显示系统中的所有进程信息
  - `ps -ef`
  - `ps aux`
- 显示进程树
  - `ps -ejH`
  - `ps axjf`
- 显示线程信息
  - `ps -eLf`
  - `ps axms`
  - `ps -mp <pid> -o THREAD,tid,time`
  - `ps -T -p <pid>`

tldr:
```
  ps

  Information about running processes.

  - List all running processes:
    ps aux

  - List all running processes including the full command string:
    ps auxww

  - Search for a process that matches a string:
    ps aux | grep string

  - List all processes of the current user in extra full format:
    ps --user $(id -u) -F

  - List all processes of the current user as a tree:
    ps --user $(id -u) f

  - Get the parent pid of a process:
    ps -o ppid= -p pid
```

## 4. top

> The top program provides a dynamic real-time view of a running system. It can display system summary information as well as a list of processes or threads currently being managed by the Linux kernel.

[top](http://man7.org/linux/man-pages/man1/top.1.html) 命令是 Linux 下常用的性能分析工具，能够实时显示系统中**各个进程或线程**的资源占用状况，类似于 Windows 的任务管理器但更加强大。

```bash
top -hv|-bcEHiOSs1 -d secs -n max -u|U user -p pid -o fld -w [cols]
```

### 4.1. 动态信息监控

```
# top

top - 09:14:56 up 264 days, 20:56,  1 user,  load average: 0.02, 0.04, 0.00
Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.2%st
Mem:    377672k total,   322332k used,    55340k free,    32592k buffers
Swap:   397308k total,    67192k used,   330116k free,    71900k cached

  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                             
    1 root      20   0  185296   4256   2376 S  0.0  0.5  20:42.83 systemd                                                                                             
    2 root      20   0       0      0      0 S  0.0  0.0   0:00.10 kthreadd                                                                                            
    3 root      20   0       0      0      0 S  0.0  0.0  30:05.74 ksoftirqd/0                                                                                         
    5 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:0H                                                                                        
    7 root      20   0       0      0      0 S  0.0  0.0 234:09.54 rcu_sched                                                                                           
    8 root      20   0       0      0      0 S  0.0  0.0   0:00.00 rcu_bh                                                                                              
    9 root      rt   0       0      0      0 S  0.0  0.0   0:00.00 migration/0                                                                                         
   10 root      rt   0       0      0      0 S  0.0  0.0   1:29.08 watchdog/0           
```
- 第一行
  - 09:14:56：系统当前时间
  - 264 days, 20:56：系统开机到现在经过了多少时间
  - 1 users： 当前 1 用户在线
  - load average: 0.02, 0.04, 0.00： 系统 1 分钟、5 分钟、15 分钟的 CPU 负载信息
- 第二行
  - Tasks：任务
  - 87 total：当前有 87 个任务，也就是 87 个进程。
  - 1 running：1 个进程正在运行
    <!-- - TODO: 为什么正在运行的进程始终只有 1 个？ -->
  - 86 sleeping：86 个进程睡眠
  - 0 stopped：停止的进程数
  - 0 zombie：僵死的进程数
- 第三行
  - Cpu(s)：表示这一行显示 CPU 总体信息
  - 0.0%us：用户态进程占用 CPU 时间百分比，不包含 renice 值为负的任务占用的 CPU 的时间。
  - 0.7%sy：内核占用 CPU 时间百分比
  - 0.0%ni：改变过优先级的进程占用 CPU 的百分比
  - 99.3%id：空闲 CPU 时间百分比
  - 0.0%wa：等待 I/O 的 CPU 时间百分比
  - 0.0%hi：CPU 硬中断时间百分比
  - 0.0%si：CPU 软中断时间百分比
  NOTE：这里显示数据是所有 cpu 的平均值，如果想看每一个 cpu 的处理情况，按 1 即可；折叠，再次按 1。
- 第四行
  - Mem：内存
  - 8175320kk total：物理内存总量
  - 8058868k used：使用的物理内存量
  - 116452k free：空闲的物理内存量
  - 283084k buffers：用作内核缓存的物理内存量
- 第五行
  - Swap：交换空间
  - 6881272k total：交换区总量
  - 4010444k used：使用的交换区量
  - 2870828k free：空闲的交换区量
  - 4336992k cached：缓冲交换区总量
- 进程信息
  - PID：进程的 ID
  - USER：进程所有者
  - PR：进程的优先级别，越小越优先被执行
  - NI：nice 值
  - VIRT：进程占用的虚拟内存
  - RES：进程占用的物理内存
  - SHR：进程使用的共享内存
  - S：进程的状态（S 表示休眠，R 表示正在运行，Z 表示僵死状态，N 表示该进程优先值为负数）
  - %CPU：进程占用 CPU 的使用率
  - %MEM：进程使用的物理内存和总内存的百分比
  - TIME+：该进程启动后占用的总的 CPU 时间，即**占用 CPU 使用时间的累加值**
  - COMMAND：进程启动命令名称

### 4.2. 交互操作指令

- 1：显示每个逻辑 CPU 的运行信息
- q：退出 top 命令
- <Space>：立即刷新
- s：设置刷新时间间隔
- 字段控制
  - c：显示命令完全模式
  - t：显示或隐藏进程和 CPU 状态信息
  - m：显示或隐藏内存状态信息
  - l：显示或隐藏 uptime 信息
  - f：增加或减少进程显示标志
- S：累计模式，会把已完成或退出的子进程占用的 CPU 时间累计到父进程的 TIME+
- 排序（**使用频率最高**）
  - P：按 %CPU 使用率排行
  - T：按 TIME+ 排行
  - M：按 %MEM 排行
- u：指定显示用户进程
- r：修改进程 renice 值
- k / kill：进程
- i：只显示正在运行的进程
- W：保存对 top 的设置到文件 ^/.toprc，下次启动将自动调用 toprc 文件的设置
- h：帮助命令
- b: 高亮显示当前运行进程

### 4.3. 线程查看模式

默认情况下，top 显示的是 Linux 系统中的进程信息，若希望查看检查线程执行信息，可使用 Threads-mode operation。

- 交互操作
  
  在 top 交互界面中，使用 `H` 可显示正在执行的线程。

- 命令选项

  使用 `top -H -p<pid>` 可显示指定进程中的所有线程的执行信息。

NOTE：在显示线程信息时，PID 字段实际上指的是线程 ID（TID）。

### 4.4. 批量模式

使用 `-b` 命令可进入 top 的 batch mode，该模式一般用于导出结果。

eg:
```bash
# 将结果写入 1.txt 文件中
top -bc -n 1 > 1.txt

# Find Top 15 Processes by Memory Usage
top -b -o +%MEM | head -n 22
```

### 4.5. 实现原理

TODO: [linux 的 top 命令是如何实现获取到每个线程的 cpu 占用率等信息？](https://www.zhihu.com/question/64317570)

- 通过 `cat /proc/cpuinfo` 得到 CPU 相关信息。
- 通过 `cat /proc/stat` 得到 CPU 运行的状态信息。包括不同核心的运行状态。
- 通过 `cat /proc/pid/stat` 得到对应进程运行的 jiffs，结合上面两个信息可以计算出进程的 CPU 占用率。

## 5. free

free 命令用于显示内存状态，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。

```
free [-bkmotV](-s 《间隔秒数》)

Options:
 -b, --bytes         show output in bytes
 -k, --kilo          show output in kilobytes
 -m, --mega          show output in megabytes
 -g, --giga          show output in gigabytes
     --tera          show output in terabytes
 -h, --human         show human-readable output
     --si            use powers of 1000 not 1024
 -l, --lohi          show detailed low and high memory statistics
 -t, --total         show total for RAM + swap
 -s N, --seconds N   repeat printing every N seconds
 -c N, --count N     repeat printing N times, then exit
 -w, --wide          wide output

     --help     display this help and exit
 -V, --version  output version information and exit
```

eg:（速记：“好莱坞”）
```
$ free -hlw 

              total        used        free      shared     buffers       cache   available
Mem:           7.9G        6.5G        1.1G         17M         33M        197M        1.2G
Low:           7.9G        6.8G        1.1G
High:            0B          0B          0B
Swap:           24G        2.8G         21G
```
其中：
- buffer: A buffer is something that has yet to be "written" to disk. 
- cache: A cache is something that has been "read" from the disk and stored for later use.

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/22/e68cedacf86e5047b1f65e0dfa1c2cf3.jpg)

上表中 something 代表的正是 free 命令中"buffers/cached"的内存，由于这块内存从操作系统的角度确实被使用，但如果用户要使用，这块内存是可以很快被回收被用户程序使用，因此从用户角度这块内存应划为空闲状态。

再次回到 free 命令输出的结果，事实上是表示从用户角度看系统内存的使用情况。因此，如果你用 top 或者 free 命令查看系统的内存还剩多少，其实你应该将空闲内存加上 buffer/cached 的内存，那才是实际系统空闲的内存。

## 6. df

df 命令用于显示目前在 Linux 系统上的文件系统的磁盘使用情况。

```
Options:
  -a, --all             include pseudo, duplicate, inaccessible file systems
  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,
                           '-BM' prints sizes in units of 1,048,576 bytes;
                           see SIZE format below
  -h, --human-readable  print sizes in powers of 1024 (e.g., 1023M)
  -H, --si              print sizes in powers of 1000 (e.g., 1.1G)
  -i, --inodes          list inode information instead of block usage
  -k                    like --block-size=1K
  -l, --local           limit listing to local file systems
      --no-sync         do not invoke sync before getting usage info (default)
      --output[=FIELD_LIST]  use the output format defined by FIELD_LIST,
                               or print all fields if FIELD_LIST is omitted.
  -P, --portability     use the POSIX output format
      --sync            invoke sync before getting usage info
      --total           elide all entries insignificant to available space,
                          and produce a grand total
  -t, --type=TYPE       limit listing to file systems of type TYPE
  -T, --print-type      print file system type
  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE
  -v                    (ignored)
      --help     display this help and exit
      --version  output version information and exit
```

## 7. du

du 命令用于显示指定的目录或文件所占用的磁盘空间。

```
du [OPTION]... [FILE]...

Options:

-a 或 -all 显示目录中个别文件的大小。
-b 或 -bytes 显示目录或文件大小时，以 byte 为单位。
-c 或 --total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。
-D 或 --dereference-args 显示指定符号连接的源文件大小。
-h 或 --human-readable 以 K，M，G 为单位，提高信息的可读性。
-H 或 --si 与 -h 参数相同，但是 K，M，G 是以 1000 为换算单位。
-k 或 --kilobytes 以 1024 bytes 为单位。
-l 或 --count-links 重复计算硬件连接的文件。
-L link 显示选项中所指定符号连接的源文件大小。
-m 或 --megabytes 以 1MB 为单位。
-s 或 --summarize 仅显示总计。
-S 或 --separate-dirs 显示个别目录的大小时，并不含其子目录的大小。
-x 或 --one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。
-X+filename 或 --exclude-from=filename 指定目录或文件。
--exclude=filename 略过指定的目录或文件。
--max-depth=number 超过指定层数的目录后，予以忽略。
--help 显示帮助。
--version 显示版本信息。
```

eg:
```bash
du -sh ./*
du -sh ./abc
```

## 8. 实时统计工具 (stat)

### 8.1. vmstat

vmstat 是 Virtual Meomory Statistics（虚拟内存统计）的缩写，是最常见的 Linux/Unix 监控工具，可以展现给定时间间隔的服务器的状态值，包括服务器的 CPU 使用率、内存使用、虚拟内存交换情况、IO 读写情况。

```
vmstat [options] [delay [count]] （delay 为两次输出之间的延迟时间，count 为监控次数，忽略 count 表示持续输出）

Options:
 -a, --active           active/inactive memory
 -f, --forks            number of forks since boot
 -m, --slabs            slabinfo
 -n, --one-header       do not redisplay header
 -s, --stats            event counter statistics
 -d, --disk             disk statistics
 -D, --disk-sum         summarize disk statistics
 -p, --partition <dev>  partition specific statistics
 -S, --unit <char>      define display unit
 -w, --wide             wide output
 -t, --timestamp        show timestamp

 -h, --help     display this help and exit
 -V, --version  output version information and exit
```

eg:
```
# vmstat 1 5 -t
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- -----timestamp-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st                 CST
 3  0      0 143836  21528 290056    0    0   914    31    0    1 38  3 57  3  0 2018-07-22 15:29:30
 0  0      0 143836  21536 290048    0    0     0    88  303  399  0  1 98  1  0 2018-07-22 15:29:31
 0  0      0 143820  21536 290056    0    0     0     0  263  338  1  0 99  0  0 2018-07-22 15:29:32
 0  0      0 143868  21536 290056    0    0     0     0  287  419  0  0 100  0  0 2018-07-22 15:29:33
 0  0      0 143852  21536 290056    0    0     0     0  248  350  0  0 100  0  0 2018-07-22 15:29:34
```
其中：
- Procs（进程）:
  - r: 即 running，运行队列中进程数量
  - b: 即 blocking，等待 IO 的进程数量
- Memory（内存）:
  - swpd: 使用虚拟内存大小
  - free: 可用内存大小
  - buff: 用作缓冲的内存大小
  - cache: 用作缓存的内存大小
- Swap:
  - si: 每秒从交换区写到内存的大小，如果这个值大于 0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。
  - so: 每秒写入交换区的内存大小，如果这个值大于 0，同上。
- IO：（默认块大小是 1024byte）
  - bi: 每秒读取的块数
  - bo: 每秒写入的块数
- system：
  - in: 每秒中断数，包括时钟中断
  - cs: 每秒上下文切换数，这个值要越小越好，太大的话就要考虑调低线程或者进程的数目，例如在 apache 和 nginx 这种 web 服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择 web 服务器的进程可以由进程或者线程的峰值一直下调，压测，直到 cs 到一个比较小的值，这个进程和线程数就是比较合适的值了。
- CPU（以百分比表示）
  - us: 用户进程执行时间 (user time)
  - sy: 系统进程执行时间 (system time)，如果太高，表示系统调用时间长，例如是 IO 操作频繁。
  - id: 空闲 CPU 时间（包括 IO 等待时间），一般来说，id + us + sy = 100。
  - wa: 等待 IO 的 CPU 时间

eg: 输出各种事件计数器和内存的统计信息
```
# vmstat -s
       885112 K total memory
       429736 K used memory
       543976 K active memory
        56508 K inactive memory
       141356 K free memory
        23176 K buffer memory
       290844 K swap cache
            0 K total swap
            0 K used swap
            0 K free swap
   1056764096 non-nice user cpu ticks
       199007 nice user cpu ticks
     72302304 system cpu ticks
   1571078022 idle cpu ticks
     75409961 IO-wait cpu ticks
            0 IRQ cpu ticks
       562612 softirq cpu ticks
            0 stolen cpu ticks
  25380358925 pages paged in
    850789032 pages paged out
            0 pages swapped in
            0 pages swapped out
   1852998022 interrupts
    321976849 CPU context switches
   1504322400 boot time
     28362507 forks
```

### 8.2. mpstat

mpstat 是 Multiprocessor Statistics 的缩写，是实时的 CPU 监控工具，它会从 /proc/stat 中读取和统计与 CPU 相关的一些统计信息。

在多 CPUs 系统里，mpstat 不但能查看所有 CPU 的平均状况信息，而且能够查看特定 CPU 的信息。mpstat 最大的特点是：可以查看多核心 CPU 中每个计算核心的统计数据，而类似工具 vmstat 只能查看系统整体 CPU 情况。

Usage: 
```
mpstat [ 选项 ] [ 时间间隔 [ 次数 ]]
```

Options:
- `-A`

  This option is equivalent to specifying `-I ALL -u -P ALL`

- `-I` { SUM | CPU | ALL }

  Report interrupts statistics. With the SUM keyword, the mpstat command reports the total number of interrupts per processor.  
  
  The following values are displayed:
  ```
  CPU: Processor number. The keyword all indicates that statistics are calculated as averages among all processors.

  intr/s: Show the total number of interrupts received per second by the CPU or CPUs.
  ```
  With the CPU keyword, the number of each individual interrupt received per second by the CPU or CPUs is displayed.

  The ALL keyword is equivalent to specifying all the keywords above and therefore all the interrupts statistics are displayed.
  
- `-P` { cpu [,...] | ALL }

  Indicate the processor number for which statistics are to be reported.  cpu is the processor number. Note that processor 0 is the first processor.  The ALL keyword indicates that statistics are to be reported for all  processors.

- `-u`     Report CPU utilization. The following values are displayed:
  ```
  CPU        Processor number.
  %usr       在 internal 时间段里，用户态的 CPU 时间 (%)，不包含 nice 值为负进程  (usr/total)*100
  %nice      在 internal 时间段里，nice 值为负进程的 CPU 时间 (%)   (nice/total)*100
  %sys       在 internal 时间段里，内核时间 (%)       (system/total)*100
  %iowait    在 internal 时间段里，硬盘 IO 等待时间 (%) (iowait/total)*100
  %irq       在 internal 时间段里，硬中断时间 (%)     (irq/total)*100
  %soft      在 internal 时间段里，软中断时间 (%)     (softirq/total)*100
  %idle      在 internal 时间段里，CPU 除去等待磁盘 IO 操作外的因为任何原因而空闲的时间闲置时间 (%) (idle/total)*100
  ```
Note: On SMP machines a processor that does not have any activity at all is a disabled (offline) processor.

### 8.3. iostat

iostat 是 I/O statistics（输入 / 输出统计）的缩写，用于查看 CPU、网卡、tty 设备、磁盘、CD-ROM 等设备的活动情况、负载信息。

```
iostat [ options ] [ <interval> [ <count> ] ]
```
Options:
- -C 显示 CPU 使用情况
- -d 显示磁盘使用情况
- -k 以 KB 为单位显示
- -m 以 M 为单位显示
- -N 显示磁盘阵列 (LVM) 信息
- -n 显示 NFS 使用情况
- -p『磁盘』 显示磁盘和分区的情况
- -t 显示终端和 CPU 的信息
- -x 显示详细信息
- -V 显示版本信息

eg: 显示所有设备负载情况
```
# iostat -x
Linux 4.4.0-77-generic (VM-52-170-ubuntu) 	07/22/18 	_x86_64_	(1 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          38.06    0.01    2.62    2.72    0.00   56.59

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
vda               0.01     4.55   25.49    1.80   914.15    30.64    69.24     0.14    4.98    2.29   43.16   1.27   3.48

```
cpu 属性值说明：
- %user：CPU 处在用户模式下的时间百分比。
- %nice：CPU 处在带 NICE 值的用户模式下的时间百分比。
- %system：CPU 处在系统模式下的时间百分比。
- %iowait：CPU 等待输入输出完成时间的百分比。如果 %iowait 的值过高，表示硬盘存在 I/O 瓶颈。
- %steal：管理程序维护另一个虚拟处理器时，虚拟 CPU 的无意识等待时间百分比。
- %idle：CPU 空闲时间百分比。如果 %idle 值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量。%idle 值如果持续低于 10，那么系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU。
disk 属性值说明：
- rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/s
- wrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/s
- r/s: 每秒完成的读 I/O 设备次数。即 rio/s
- w/s: 每秒完成的写 I/O 设备次数。即 wio/s
- rsec/s: 每秒读扇区数。即 rsect/s
- wsec/s: 每秒写扇区数。即 wsect/s
- rkB/s: 每秒读 K 字节数。是 rsect/s 的一半，因为每扇区大小为 512 字节。
- wkB/s: 每秒写 K 字节数。是 wsect/s 的一半。
- avgrq-sz: 平均每次设备 I/O 操作的数据大小 （扇区）。
- avgqu-sz: 平均 I/O 队列长度。如果 avgqu-sz 比较大，表示有大量 IO 在等待。
- await: 平均每次设备 I/O 操作的等待时间 （毫秒）。如果 await 远大于 svctm，说明 I/O 队列太长，io 响应太慢，则需要进行必要优化。
- svctm: 平均每次设备 I/O 操作的服务时间 （毫秒）。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间。
- %util: 一秒中有百分之多少的时间用于 I/O 操作，即被 io 消耗的 cpu 百分比。如果 %util 接近 100%，说明产生的 I/O 请求太多，I/O 系统已经满负荷，该磁盘可能存在瓶颈。

eg: 查看 TPS 和吞吐量
```
# iostat -dk 1 5
Linux 4.4.0-77-generic (VM-52-170-ubuntu) 	07/22/18 	_x86_64_	(1 CPU)

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda              27.29       914.14        30.64 25380359261  850797464

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               0.00         0.00         0.00          0          0

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               0.00         0.00         0.00          0          0

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               3.96         0.00        23.76          0         24

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               0.00         0.00         0.00          0          0
```
- tps：该设备每秒的传输次数（Indicate the number of transfers per second that were issued to the device.）。“一次传输”意思是“一次 I/O 请求”。多个逻辑请求可能会被合并为“一次 I/O 请求”。“一次传输”请求的大小是未知的。
- kB_read/s：每秒从设备（drive expressed）读取的数据量。
- kB_wrtn/s：每秒向设备（drive expressed）写入的数据量。
- kB_read：读取的总数据量；kB_wrtn：写入的总数量数据量。

### 8.4. pidstat

TODO:

pidstat 主要用于监控全部或指定进程占用系统资源的情况，如 CPU，内存、设备 IO、任务切换、线程等。

pidstat 首次运行时显示自系统启动开始的各项统计信息，之后运行 pidstat 将显示自上次运行该命令以后的统计信息。用户可以通过指定统计的次数和时间来获得所需的统计信息。

## 9. strace

在 Linux 中，进程不能直接访问硬件设备，因此当进程需要访问硬件设备（比如读取磁盘文件，接收网络数据等等) 时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。

strace 可以跟踪到一个进程产生的系统调用，包括参数，返回值，执行消耗的时间，常用来跟踪进程执行时的系统调用和所接收的信号。

strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。

Options:
- -c 统计每一系统调用的所执行的时间，次数和出错的次数等。
- -d 输出 strace 关于标准错误的调试信息。
- -f 跟踪由 fork 调用所产生的子进程。
- -ff 如果提供 -o filename, 则所有进程的跟踪结果输出到相应的 filename.pid 中，pid 是各进程的进程号。
- -F 尝试跟踪 vfork 调用。在 -f 时，vfork 不被跟踪。
- -i 输出系统调用的入口指针。
- -r 打印出相对时间关于，每一个系统调用。
- -t 在输出中的每一行前加上时间信息。
- -tt 在输出中的每一行前加上时间信息，微秒级。
- -ttt 微秒级输出，以秒了表示时间。
- -v 输出所有的系统调用。一些调用关于环境变量，状态，输入输出等调用由于使用频繁，默认不输出。
- -V 输出 strace 的版本信息。
- -x 以十六进制形式输出非标准字符串
- -xx 所有字符串以十六进制形式输出。
- -a column 设置返回值的输出位置。默认 为 40.
- -e expr 指定一个表达式，用来控制如何跟踪。格式如下：
  ```
  [qualifier=](!)value1[, value2]...
  ```
  其中：
  - qualifier 只能是 trace,abbrev,verbose,raw,signal,read,write 其中之一。默认的 qualifier 是 trace. 感叹号是否定符号。
  - value 是用来限定的符号或数字。
  
  例如：
  - -e trace=set 只跟踪指定的系统调用。例如：-e trace=open,close,rean,write 表示只跟踪这四个系统调用。默认的为 set=all.
    - -eopen 等价于 -e trace=open
  - -e trace=file 只跟踪有关文件操作的系统调用。
  - -e trace=process 只跟踪有关进程控制的系统调用。
  - -e trace=network 跟踪与网络有关的所有系统调用。
  - -e strace=signal 跟踪所有与系统信号有关的 系统调用。
  - -e trace=ipc 跟踪所有与进程通讯有关的系统调用。
  - -e abbrev=set 设定 strace 输出的系统调用的结果集。-v 等与 abbrev=none. 默认为 abbrev=all.
  - -e raw=set 将指 定的系统调用的参数以十六进制显示。
  - -e signal=set 指定跟踪的系统信号。默认为 all. 如 signal=!SIGIO（或者 signal=!io), 表示不跟踪 SIGIO 信号。
  - -e read=set 输出从指定文件中读出 的数据。例如：`-e read=3,5`.
  - -e write=set 输出写入到指定文件中的数据。
- -o filename 将 strace 的输出写入文件 filename.
- -p pid 跟踪指定的进程 pid.
- -s strsize 指定输出的字符串的最大长度。默认为 32. 文件名一直全部输出。
- -u username 以 username 的 UID 和 GID 执行被跟踪的命令。

eg:
```bash
$ strace cat /dev/null 

  execve("/bin/cat", ["cat", "/dev/null"], [/* 28 vars */]) = 0
  brk(0)                                  = 0xdcd000
  mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f72a5d11000
  access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
  open("/etc/ld.so.cache", O_RDONLY)      = 3
  fstat(3, {st_mode=S_IFREG|0644, st_size=74630, ...}) = 0
  mmap(NULL, 74630, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f72a5cfe000
  close(3)                                = 0
  open("/lib64/libc.so.6", O_RDONLY)      = 3
  read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0p\356\1\0\0\0\0\0"..., 832) = 832
  fstat(3, {st_mode=S_IFREG|0755, st_size=1921160, ...}) = 0
  mmap(NULL, 3750152, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f72a575f000
  mprotect(0x7f72a58e9000, 2097152, PROT_NONE) = 0
  mmap(0x7f72a5ae9000, 20480, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x18a000) = 0x7f72a5ae9000
  mmap(0x7f72a5aee000, 18696, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f72a5aee000
  close(3)                                = 0
  mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f72a5cfd000
  mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f72a5cfc000
  mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f72a5cfb000
  arch_prctl(ARCH_SET_FS, 0x7f72a5cfc700) = 0
  mprotect(0x7f72a5ae9000, 16384, PROT_READ) = 0
  mprotect(0x7f72a5d12000, 4096, PROT_READ) = 0
  munmap(0x7f72a5cfe000, 74630)           = 0
  brk(0)                                  = 0xdcd000
  brk(0xdee000)                           = 0xdee000
  open("/usr/lib/locale/locale-archive", O_RDONLY) = 3
  fstat(3, {st_mode=S_IFREG|0644, st_size=99154624, ...}) = 0
  mmap(NULL, 99154624, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f729f8cf000
  close(3)                                = 0
  fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0
  open("/dev/null", O_RDONLY)             = 3
  fstat(3, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
  read(3, "", 32768)                      = 0
  close(3)                                = 0
  close(1)                                = 0
  close(2)                                = 0
  exit_group(0)                           = ?
```
在 strace 命令的输出中，**每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值**。

eg:
```bash
$  strace -c cat /dev/null 

  % time     seconds  usecs/call     calls    errors syscall
  ------ ----------- ----------- --------- --------- ----------------
    -nan    0.000000           0         2           read
    -nan    0.000000           0         4           open
    -nan    0.000000           0         6           close
    -nan    0.000000           0         5           fstat
    -nan    0.000000           0         9           mmap
    -nan    0.000000           0         3           mprotect
    -nan    0.000000           0         1           munmap
    -nan    0.000000           0         3           brk
    -nan    0.000000           0         1         1 access
    -nan    0.000000           0         1           execve
    -nan    0.000000           0         1           arch_prctl
  ------ ----------- ----------- --------- --------- ----------------
  100.00    0.000000                    36         1 total
```

eg:
```bash
$ strace -i cat /dev/null 
  [    7f0f60e0fda7] execve("/bin/cat", ["cat", "/dev/null"], [/* 28 vars */]) = 0
  [    7fa978c3e2ca] brk(0)               = 0x25f6000
  [    7fa978c3f0ba] mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa978e46000
  [    7fa978c3ef77] access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
  [    7fa978c3eeb7] open("/etc/ld.so.cache", O_RDONLY) = 3
  [    7fa978c3ee84] fstat(3, {st_mode=S_IFREG|0644, st_size=74630, ...}) = 0
  [    7fa978c3f0ba] mmap(NULL, 74630, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fa978e33000
  [    7fa978c3eee7] close(3)             = 0
  [    7fa978c3eeb7] open("/lib64/libc.so.6", O_RDONLY) = 3
  [    7fa978c3ef17] read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0p\356\1\0\0\0\0\0"..., 832) = 832
  [    7fa978c3ee84] fstat(3, {st_mode=S_IFREG|0755, st_size=1921160, ...}) = 0
  [    7fa978c3f0ba] mmap(NULL, 3750152, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fa978894000
  [    7fa978c3f117] mprotect(0x7fa978a1e000, 2097152, PROT_NONE) = 0
  [    7fa978c3f0ba] mmap(0x7fa978c1e000, 20480, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x18a000) = 0x7fa978c1e000
  [    7fa978c3f0ba] mmap(0x7fa978c23000, 18696, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fa978c23000
  [    7fa978c3eee7] close(3)             = 0
  [    7fa978c3f0ba] mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa978e32000
  [    7fa978c3f0ba] mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa978e31000
  [    7fa978c3f0ba] mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa978e30000
  [    7fa978c2a566] arch_prctl(ARCH_SET_FS, 0x7fa978e31700) = 0
  [    7fa978c3f117] mprotect(0x7fa978c1e000, 16384, PROT_READ) = 0
  [    7fa978c3f117] mprotect(0x7fa978e47000, 4096, PROT_READ) = 0
  [    7fa978c3f0e7] munmap(0x7fa978e33000, 74630) = 0
  [    7fa97897479a] brk(0)               = 0x25f6000
  [    7fa97897479a] brk(0x2617000)       = 0x2617000
  [    7fa97896f2d0] open("/usr/lib/locale/locale-archive", O_RDONLY) = 3
  [    7fa97896ee44] fstat(3, {st_mode=S_IFREG|0644, st_size=99154624, ...}) = 0
  [    7fa9789792da] mmap(NULL, 99154624, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fa972a04000
  [    7fa9788be37c] close(3)             = 0
  [    7fa97896ee44] fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0
  [    7fa97896f2d0] open("/dev/null", O_RDONLY) = 3
  [    7fa97896ee44] fstat(3, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
  [    7fa97896f4c0] read(3, "", 32768)   = 0
  [    7fa97896f460] close(3)             = 0
  [    7fa97896f460] close(1)             = 0
  [    7fa97896f460] close(2)             = 0
  [    7fa978940d88] exit_group(0)        = ?
```

tldr:
```bash
# 跟踪进程运行，显示指针和相对时间
$ strace -ri cat /dev/null

# 跟踪 28979 进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在 output.txt 文件里面
$ strace -o output.txt -T -tt -e trace=all -p 28979

# 同时跟踪 fork 和 vfork 出来的进程，-o 选项把所有 strace 输出写到~/straceout.txt 中
$ strace -f -F -o ~/straceout.txt cat /dev/null
```

## 10. ipcs

ipcs 是 Linux 下显示进程间通信设施状态的工具，用于显示消息队列、共享内存和信号量的信息，对于程序开发非常有用。

Options:
- -m: 输出有关共享内存 (shared memory) 的信息。
- -q: 输出有关信息队列 (message queue) 的信息。
- -s: 输出有关信号量 (semaphore) 的信息。

tldr:
```
ipcs

  Display information about resources used in IPC (Inter-process Communication).

  - Specific information about the Message Queue which has the id 32768:
    ipcs -qi 32768

  - General information about all the IPC:
    ipcs -a
```

eg:
```
# ipcs

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status      
0x00000000 98304      root       644        80         2                       
0x00000000 131073     root       644        16384      2                       
0x00000000 163842     root       644        280        2                       

------ Semaphore Arrays --------
key        semid      owner      perms      nsems     
0x000000a7 32768      root       600        1   
```

## 11. ipcrm

ipcrm 用于删除消息队列、共享内存、信号量等 IPC 资源。

Usage:
```
ipcrm [ -m SharedMemoryID ] [ -M SharedMemoryKey ] [ -q MessageID ] [ -Q MessageKey ] [ -s SemaphoreID ] [ -S SemaphoreKey ]
```
Options:
- -M: 以 shmkey 删除共享内存。
- -m: 以 shmid 删除共享内存。
- -Q: 以 msgkey 删除消息队列。
- -q: 以 msgid 删除消息队列。
- -S: 以 semkey 删除信号量。
- -s: 以 semid 删除信号量。

eg:
```
ipcrm -m 18602
```

## 12. watch

当需要持续的监控应用的某个数据变化时，watch 工具能满足要求。执行 watch 命令后，会进入到一个界面，输出当前被监控的数据，一旦数据变化，便会高亮显示变化情况。

```
Usage:
 watch [options] command

Options:
  -b, --beep             beep if command has a non-zero exit
  -c, --color            interpret ANSI color and style sequences
  -d, --differences[=<permanent>]
                         highlight changes between updates
  -e, --errexit          exit if command has a non-zero exit
  -g, --chgexit          exit when output from command changes
  -n, --interval <secs>  seconds to wait between updates
  -p, --precise          attempt run command in precise intervals
  -t, --no-title         turn off header
  -x, --exec             pass command to exec instead of "sh -c"

 -h, --help     display this help and exit
 -v, --version  output version information and exit
```

tldr:
```
  watch

  Execute a program periodically, showing output fullscreen.

  - Repeatedly run a command and show the result:
    watch command

  - Re-run a command every 60 seconds:
    watch -n 60 command

  - Monitor the contents of a directory, highlighting differences as they appear:
    watch -d ls -l
```

## 13. uptime

uptime 命令显示系统已经运行了多长时间，它依次显示当前时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的 1 分钟、5 分钟和 15 分钟内的平均负载。

关于系统平均负载，它表示在特定时间间隔内运行队列中的平均进程数。如果一个进程满足以下条件则其就会位于运行队列中：没有在等待 I/O 操作的结果；没有主动进入等待状态；没有被停止。

```
Options:
 -p, --pretty   show uptime in pretty format
 -h, --help     display this help and exit
 -s, --since    system up since
 -V, --version  output version information and exit
```

eg:
```
# uptime   
 17:24:00 up 323 days,  6:04,  1 user,  load average: 0.00, 0.01, 0.00
```
load average 值分别记录了上个 1 分钟，5 分钟和 15 分钟间隔的负载情况，load average 不是一个百分比，而是在队列中等待执行的进程的数量。如果进程要求 CPU 时间被阻塞（意味着 CPU 没有时间处理它），load average 值将增加；如果每个进程都可以立刻得到访问 CPU 的时间，这个值将减少。

tldr:
```
  uptime

  Tell how long the system has been running and other information.

  - Print current time, uptime, number of logged-in users and other information:
    uptime

  - Show only the amount of time the system has been booted for:
    uptime --pretty

  - Print the date and time the system booted up at:
    uptime --since

  - Show version information:
    uptime --version
```

## 14. lsof

lsof（list open files）是一个查看当前系统文件的工具。在 linux 环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。

Options:
- -a 列出打开文件存在的进程
- -c 『进程名』 列出指定进程所打开的文件
- -g 列出 GID 号进程详情
- -d 『文件号』 列出占用该文件号的进程
- +d 『目录』 列出目录下被打开的文件
- +D 『目录』 递归列出目录下被打开的文件
- -n 『目录』 列出使用 NFS 的文件
- -i 『条件』 列出符合条件的网络连接进程（4、6、协议、: 端口、 @ip ）
- -p 『进程号』 列出指定进程号所打开的文件
- -u 列出 UID 号进程详情
- -h 显示帮助信息
- -v 显示版本信息

eg:
- 查找某个文件相关的进程
  ```
  root@VM-52-170-ubuntu:~# lsof /bin/bash 
  COMMAND   PID USER  FD   TYPE DEVICE SIZE/OFF  NODE NAME
  bash    29421 root txt    REG  253,1  1037528 65588 /bin/bash
  ```
- 列出某个用户打开的文件信息
  ```
  $lsof -u username
  ```
- 列出某个程序进程所打开的文件信息
  ```
  $lsof -c mysql
  ```
  -c 选项将会列出所有以 mysql 这个进程开头的程序的文件，其实你也可以写成 `lsof | grep mysql`。
- 组合使用：列出某个用户以及某个进程所打开的文件信息
  ```
  $lsof  -u test -c mysql
  ```
- 通过某个进程号显示该进程打开的文件
  ```
  $lsof -p 11968
  ```
- 列出所有 tcp 网络连接信息
  ```
  $lsof -i tcp
  ```
- 列出谁在使用某个端口
  ```
  $lsof -i :3306
  ```
- 列出目前连接主机 nf5260i5-td 上端口为：20，21，80 相关的所有文件信息，且每隔 3 秒重复执行
  ```
  $ lsof -i @nf5260i5-td:20,21,80 -r 3
  ```

## 15. perf

现代计算机系统非常复杂，因此要判断哪些代码消耗了更多的 CPU 处理时间以及为什么这些代码会消耗额外的 CPU 处理时间是一个困难的工作。

[Perf](https://github.com/brendangregg/perf-tools) 是一个 Linux 下的性能调试工具，能够帮助开发者发现哪些代码会消耗更多的 CPU 时间以及这些代码为什么会消耗额外的 CPU 时间，同时具有开销小、适用面广等优点，适合在生产环境中使用。

与以往 Linux 发行版提供的 OPrifle 工具相比：
- Perf 工具的优势在于与 Linux 内核的紧密结合，它可以最先应用到加入内核的新特性，而 OPrifle 则通常会“慢一拍”。
- 同时，Perf 的功能更强大，更全面。Oprifle 和 Perf 都使用现代 CPU 中的硬件计数器进行工作，但 Perf 还可以使用内核定义中的软件计数器和 Trace Points 进行更多的工作。Oprifile 的抽样工作利用 CPU 的 NMI 中断来进行，而 Perf 既可以利用 NMI 中断也可以利用硬件计数器提供的周期性中断，因此更加灵活和强大。
- 更为可贵的是：Perf 因其很低的性能开销，对系统和应用造成的性能影响非常小，很适宜用于生产环境。

### 15.1. 基本原理

Perf 对判断系统的性能瓶颈非常有用。它可以被配置以中断或定期方式获取事件实例数来收集代码的运行信息。在许多体系结构上，Perf 提供了对性能计数器的访问。

> 性能计数器是现代 CPU 中一些特殊的硬件寄存器。这些寄存器对特定的硬件事件进行计数：比如指令的执行，cache miss 或者是分支预测错误等，同时不会对内核或应用的性能产生影响。这些寄存器中的内容可以被定期收集，同时这些寄存器也可以在特定的事件数量超过一定数值时触发中断。而在这些中断中，特定的事件数量被记录，并在应用层需要时返回这些数据。这样，使得开发者能够收集代码执行过程中某些事件比如 cache miss，内存引用以及 CPU clock 或 cycle 等的相关信息，并使得开发者能够根据它们来判断代码的运行情况及其原因。
>
> Linux 的性能计数器子系统对这些硬件特性进行了抽象。它可以提供针对每个任务和每个 CPU 的计数器或者是计数器组，并基于它们提供了一系列的事件特性。同时，无论底层硬件计数器的字宽是什么，它都可以提供“虚拟的”64 位计数器。
> 
> 性能计数器可以通过特殊的文件描述符访问。这些特殊的文件描述符通过特定的系统调用 perf_event_open 打开，并可以通过通常的文件访问接口进行访问和设置。多个性能计数器可以被一次打开，并支持 poll 操作。

### 15.2. 基本使用

Perf 工具的常用命令包括 stat，record，report 等。如何使用 Perf 判断性能瓶颈点所在并揭示性能瓶颈原因呢？

在程序运行出现问题时，我们希望快速定位热点代码段，以使得后面的优化和问题分析有的放矢，实现问题的快速定位与解决。我们可以使用 Perf record 命令记录合适的事件信息，并使用 Perf report 命令生成程序运行状况报告。

#### 15.2.1. stat

Perf stat 命令用来显示程序运行的整体状况。

eg:

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/8/17/e12d39505fe9e15fc5236ff4bf0f320c.jpg)

```bash
$ perf stat ./p.sh

 Performance counter stats for './p.sh':

        371.407091      task-clock (msec)         #    1.087 CPUs utilized          
               569      context-switches          #    0.002 M/sec                  
                73      cpu-migrations            #    0.197 K/sec                  
             22655      page-faults               #    0.061 M/sec                  
         963436748      cycles                    #    2.594 GHz                    
                 0      stalled-cycles-frontend   #    0.00% frontend cycles idle   
                 0      stalled-cycles-backend    #    0.00% backend  cycles idle   
        1611498705      instructions              #    1.67  insns per cycle        
         335544484      branches                  #  903.441 M/sec                  
           1867390      branch-misses             #    0.56% of all branches        

       0.341589205 seconds time elapsed

```
在上面的测试结果中：
- task-clock(msecs) 表示 CPU 利用率，该值高，说明 CPU 花在计算上的时间比花在 I/O 上面的时间多。
- context-switches 表示上下文切换次数，上下文切换需要一定的开销，并且会增加系统的分支预测错误数和 cache miss 率，因此应避免频繁的上下文切换。
- CPU-migrations 表示线程或进程在 CPU 之间迁移的次数，线程或进程在 CPU 之间迁移会增加 cache miss 率。
- page-faults 表示页错误次数。
- cycles 表示程序执行的总指令周期数。
- instructions 表示所执行的总指令数，而 ipc(insns per cycle) 则表示 instructiojns/cycles 的比值，该值越大越好，说明程序充分利用了 CPU 的特性。
- branches 表示总分支数。
- branch-misses 则表示分支预测错误数。
- cache-erferences 表示总 cache 命中的次数。
- cache-misses 则表示 cache miss 数。Branch miss 和 cache miss 率的高低会对 IPC 产生影响，并进而对程序的执行效率产生影响。

#### 15.2.2. record

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/8/17/1cfcc140d5bf9ef23fb8d754de4a4370.jpg)

Perf record 命令则用来记录指定事件在程序运行过程中的信息。

通过 `perf list` 命令可以看到 perf 支持的事件，Perf 能够观察的事件包括以下类型：
- PERF_TYPE_HARDWARE：内核能够提供的“通用的”硬件事件。PERF_TYPE_HARDWARE 类事件包括：
  - cpu-cycles：某段时间内的 CPU cycle 数，即执行程序指令花费的时钟周期数，如果 CPU 处于 Pn（n 非 0）或者是 C 状态，则 cycles 的产生速度会减慢。
  - instructions：某段时间内的 CPU 所执行的指令数。
  - cache misses：cache miss 次数。
  - branch misses：分支预测错误次数。
- PERF_TYPE_SOFTWARE：内核提供的软件定义的事件（即使没有硬件的支持）。PERF_TYPE_SOFTWARE 类事件包括：
  - cpu-clock：某段时间内的 cpu 时钟数，即程序执行经过的真实时间，而无论 CPU 处于什么状态（Pn（n 非 0）或者是 C 状态）。
  - page faults：页错误次数。
  - context switches：上下文交换次数。
- PERF_TYPE_TRACEPOINT：由 Ftrace 架构提供，支持采样功能。
- PERF_TYPE_HW_CACHE：这些是硬件事件，但是由于其复杂性，因而需要特殊的编码。
- PERF_TYPE_RAW：只有某些 CPU 支持的特定事件。

其中，CPU cycles 事件和 CPU clock 事件比较常用，如果你想查看哪些代码消耗的真实时间多，则可以使用 cpu-clock 事件；而如果你想查看哪些代码消耗的时钟周期多，则可以使用 CPU cycles 事件。

在使用 Perf 时，需要对计算机体系结构有深入的了解并理解相关事件的含义，才能选择合适的事件进行观察并根据事件信息对代码的运行状况进行正确的判断。

eg: 使用 Perf record 命令抓取测试程序运行时的 cycle 事件以获取以上信息。在 Perf record 命令中需要加上 `-a` 选项以抓取全面的信息，因为在 SMP 平台上，测试程序可能运行在任意一个 CPU 或核上。
```bash
$ perf record -e cycles -a ./p.sh 
```

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/8/17/89681af41df22ff370a62066749ba486.jpg)

运行完毕后，perf 会在当前目录下生成一个二进制的记录文件，存储其抓取的运行信息：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/8/17/a011633328b70cee3d47483aaaf5a3fd.jpg)

可以通过 perf report 命令来查看。

#### 15.2.3. report

Perf report 命令则用来报告基于前面 record 命令记录的事件信息生成的程序运行状况报告。

eg: 在 perf.data 文件目录下执行
```bash
$ perf report
```

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/8/17/1e06050f89da8bf3703c65c2de66081b.jpg)

#### 15.2.4. top

Perf top 命令用来观测应用退出阶段的运行信息，从而发现到底是哪部分代码使在占用 CPU 并使得应用退出的速度变慢。Perf top 命令的好处是可以快速实时查看系统的运行状况。

#### 15.2.5. script

使用 `perf script > out.perf` 将 perf.data 的内容 dump 到 out.perf，通常的做法是将 out.perf 拷贝到本地机器，在本地生成火焰图：
```
$ git clone --depth 1 https://github.com/brendangregg/FlameGraph.git
# 折叠调用栈
$ FlameGraph/stackcollapse-perf.pl out.perf > out.folded
# 生成火焰图
$ FlameGraph/flamegraph.pl out.folded > out.svg
```
生成火焰图可以指定参数，`–width` 可以指定图片宽度，`–height` 指定每一个调用栈的高度，生成的火焰图，宽度越大就表示 CPU 耗时越多。

## 17. Refer Links

[如何查看 linux 版本、内核版本、系统位数](http://blog.sina.com.cn/s/blog_4b856bcb0101e42t.html)

[Linux 基础 » 6. 性能监控](http://linuxtools-rst.readthedocs.io/zh_CN/latest/base/06_monitor.html)

[工具参考篇 » 3. lsof 一切皆文件](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html)

[工具参考篇 » 7. ipcs 查询进程间通信状态](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ipcs.html)

[工具参考篇 » 8. top linux 下的任务管理器](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/top.html)

[工具参考篇 » 9. free 查询可用内存](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/free.html)

[工具参考篇 » 10. vmstat 监视内存使用情况](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/vmstat.html)

[工具参考篇 » 11. iostat 监视 I/O 子系统](http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/iostat.html)

[Linux 吃掉我的内存](https://www.cnblogs.com/hazir/p/linux_ate_my_ram.html)

[Runoob free](http://www.runoob.com/linux/linux-comm-free.html)

[Runoob df](http://www.runoob.com/linux/linux-comm-df.html)

[Runoob du](http://www.runoob.com/linux/linux-comm-du.html)

[Linux vmstat 命令实战详解](https://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html)

[Linux 常用性能检测命令](http://blog.licess.com/linux-performance-command/)

[浅谈服务器性能测试的全生命周期——从测试、结果分析到优化策略](http://wetest.qq.com/lab/view/?id=102)

[strace 跟踪进程中的系统调用](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html)

TODO:

[Oracle 手册页部分：系统管理命令 mpstat](https://docs.oracle.com/cd/E56344_01/html/E54077/mpstat-1m.html)

[Perf -- Linux 下的系统性能调优工具，第 1 部分](https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/index.html)

[Perf -- Linux 下的系统性能调优工具，第 2 部分](https://www.ibm.com/developerworks/cn/linux/l-cn-perf2/index.html)

http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/index.html

http://linuxtools-rst.readthedocs.io/zh_CN/latest/advance/03_optimization.html

https://blog.csdn.net/chosen0ne/article/details/8200737
