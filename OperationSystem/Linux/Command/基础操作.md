- [Base Operation](#base-operation)
  - [1. echo](#1-echo)
  - [2. cp](#2-cp)
  - [3. ls](#3-ls)
  - [4. ln](#4-ln)
  - [5. tar](#5-tar)
  - [6. tree](#6-tree)
  - [7. diff](#7-diff)
  - [8. xargs](#8-xargs)
  - [9. 搜索](#9- 搜索)
    - [9.1. 文件搜索](#91- 文件搜索)
      - [9.1.1. locate](#911-locate)
      - [9.1.2. find](#912-find)
    - [9.2. 命令（二进制文件）搜索](#92- 命令二进制文件搜索)
      - [9.2.1. whereis](#921-whereis)
      - [9.2.2. which](#922-which)
  - [10. 字符串搜索：grep](#10- 字符串搜索 grep)
  - [11. 权限控制](#11- 权限控制)
    - [11.1. 基础概念](#111- 基础概念)
      - [11.1.1. 权限类型](#1111- 权限类型)
        - [11.1.1.1. 基本权限类型](#11111- 基本权限类型)
        - [11.1.1.2. 附加权限类型](#11112- 附加权限类型)
      - [11.1.2. 权限粒度](#1112- 权限粒度)
      - [11.1.3. 权限表示](#1113- 权限表示)
    - [11.2. chmod](#112-chmod)
  - [12. Refer Links](#12-refer-links)

# Base Operation

## 1. echo

Options
- `-n` 关闭自动插入换行符（默认开启）。
- `-e` 开启对转义字符进行识别替换（默认关闭）
  
  eg: 通过 echo 改变 shell 输出颜色：
  ```
  echo -e "\e[1;color_code text \e[1;color_code"
  ```
  其中，`\e[1;color_code` 表示改变终端颜色。如：`echo -e "\e[1;31m hahahaha \e[0m"` 可输出红色的字符 'hahahaha'。

tldr:
```bash
  echo

  Print given arguments.

  - Print a text message. Note: quotes are optional:
    echo "Hello World"

  - Print a message with environment variables:
    echo "My path is $PATH"

  - Print a message without the trailing newline:
    echo -n "Hello World"

  - Enable interpretation of backslash escapes (special characters):
    echo -e "Column 1\tColumn 2"
```

## 2. cp

tldr:
```bash
  Copy files and folders.

  - Copy a file to another location:
    cp path/to/file.ext path/to/copy.ext

  - Copy a file into another folder, keeping the filename:
    cp path/to/file.ext path/to/target/parent/folder

  - Copy a folder recursively to another location:
    cp -r path/to/folder path/to/copy

  - Copy the contents of a folder into another folder:
    cp -r path/to/source/folder/* path/to/target/folder

  - Copy text files to another location, in interactive mode (prompts user before overwriting):
    cp -i *.txt path/to/source/
```

## 3. ls

```
ls [Options] [Directory]
```
- -a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件
- -A 同 -a，但不列出“.”（表示当前目录) 和“..”（表示当前目录的父目录)。
- -c  配合 -lt：根据 ctime 排序及显示 ctime （文件状态最后更改的时间) 配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序
- -C 每栏由上至下列出项目
- –color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是'never'、'always'或'auto'其中之一
- -d, –directory 将目录象文件一样显示，而不是显示其下的文件。
- -D, –dired 产生适合 Emacs 的 dired 模式使用的结果
- -f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效
- -g 类似 -l, 但不列出所有者
- -G, –no-group 不列出任何有关组的信息
- -h, –human-readable 以容易理解的格式列出文件大小 （例如 1K 234M 2G)
- –si 类似 -h, 但文件大小取 1000 的次方而不是 1024
- -H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地
- –indicator-style= 方式 指定在每个项目名称后加上指示符号《方式》：none （默认)，classify (-F)，file-type (-p)
- -i, –inode 印出每个文件的 inode 号
- -I, –ignore=pattern 排除 pattern 匹配的文件
- -k 即 –block-size=1K, 以 k 字节的形式表示文件的大小。
- -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。
- -L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息
- -m 所有项目以逗号分隔，并填满整行行宽
- -o 类似 -l, 显示文件的除组信息外的详细信息。   
- -r, –reverse 依相反次序排列
- -R, –recursive 同时列出所有子目录层
- -s, –size 以块大小为单位列出所有文件的大小
- -S 根据文件大小排序
- –sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：
  - extension -X status -c
  - none -U time -t
  - size -S atime -u
  - time -t access -u
  - version -v use -u
- -t 以文件修改时间排序
- -U 不进行排序；依文件系统原有的次序列出项目
- -v 根据版本进行排序
- -w, –width=COLS 自行指定屏幕宽度而不使用目前的数值
- -x 逐行列出项目而不是逐栏列出
- -X 根据扩展名排序
- -1 每行只列出一个文件
- –help 显示此帮助信息并离开
- –version 显示版本信息并离开

eg:
```
ls -Alht // sorted by time
ls -AlhS // sorted by size
ls -I file_name // ignore file_name
```

tldr:
```
  ls

  List directory contents.

  - List files one per line:
    ls -1

  - List all files, including hidden files:
    ls -a

  - Long format list (permissions, ownership, size and modification date) of all files:
    ls -la

  - Long format list with size displayed using human readable units (KB, MB, GB):
    ls -lh

  - Long format list sorted by size (descending):
    ls -lS

  - Long format list of all files, sorted by modification date (oldest first):
    ls -ltr
```

## 4. ln

## 5. tar

Options:
- --delete : 从归档文件 （而非磁带) 中删除
- -r, --append : 将文件追加到归档文件中
- -t, --list : 列出归档文件中包含的内容
- --test-label : 测试归档文件卷标并退出
- -u, --update : 将已更新的文件追加到归档文件中
- -x, --extract, --get : 释放归档文件中文件及目录
- -C, --directory=DIR : 执行归档动作前变更工作目录到 DIR
- -f, --file=ARCHIVE : 指定 （将要创建或已存在的) 归档文件名
- -j, --bip2 : 对归档文件使用 bzip2 压缩
- -J, --xz : 对归档文件使用 xz 压缩
- -p, --preserve-permissions : 保留原文件的访问权限
- -v, --verbose : 显示命令整个执行过程
- -z, gzip : 对归档文件使用 gzip 压缩 / 解压缩

NOTE: 在 tar 命令选项中的连接符 `-` 是可选的（tar 命令更多受到古老的 UNIX 风格影响）。

tldr:
```
  tar
  Archiving utility.
  Often combined with a compression method, such as gzip or bzip.

  - Create an archive from files:
    tar cf target.tar file1 file2 file3

  - Create a gzipped archive:
    tar czf target.tar.gz file1 file2 file3

  - Extract an archive in a target folder:
    tar xf source.tar -C folder

  - Extract a gzipped archive in the current directory:
    tar xzf source.tar.gz

  - Extract a bzipped archive in the current directory:
    tar xjf source.tar.bz2

  - Create a compressed archive, using archive suffix to determine the compression program:
    tar caf target.tar.xz file1 file2 file3

  - List the contents of a tar file:
    tar tvf source.tar

  - Extract files matching a pattern:
    tar xf source.tar --wildcards "*.html"
```

## 6. cat

## 7. nl

nl(number lines of files) is used to write each FILE to standard output, with line numbers added.

## 8. tree

usage: 
```bash
tree [-adfghilnpqrstuvxACDFNS] [-H baseHREF] [-T title ] [-L level [-R]]
    [-P pattern] [-I pattern] [-o filename] [--version] [--help] [--inodes]
    [--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset]
    [--filelimit #] [<directory list>]
```
- `-a`: 显示所有文件和目录。
- `-A`: 使用 ASNI 绘图字符显示树状图而非以 ASCII 字符组合。
- `-C`: 在文件和目录清单加上色彩，便于区分各种类型。
- `-d`: 显示目录名称而非内容。
- `-D`: 列出文件或目录的更改时间。
- `-f`: 在每个文件或目录之前，显示完整的相对路径名称。
- `-F`: 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上"*","/","=","@","|"号。
- `-g`: 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。
- `-i`: 不以阶梯状列出文件或目录名称。
- `-I`: 不显示符合范本样式的文件或目录名称。
- `-l`: 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。
- `-n`: 不在文件和目录清单加上色彩。
- `-N`: 直接列出文件和目录名称，包括控制字符。
- `-p`: 列出权限标示。
- `-P`: 只显示符合范本样式的文件或目录名称。
- `-q`: 用"?"号取代控制字符，列出文件和目录名称。
- `-s`: 列出文件或目录大小。
- `-t`: 用文件和目录的更改时间排序。
- `-u`: 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。
- `-x`: 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。

tldr:
```
tree -DFpsf
```

## 9. diff

diff 命令用来比较两个文本文件的差异，是代码版本管理的基石之一。

```
diff 《变动前的文件》 《变动后的文件》
```

todo: [阮一峰：读懂 diff](http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html)

- 正常模式

- 上下文模式 `-c`

- 合并模式 `-u`

## 10. xargs

https://www.cnblogs.com/wangqiguo/p/6464234.html

http://www.runoob.com/linux/linux-comm-xargs.html

xargs 命令可以通过管道接受字符串，并将接收到的字符串通过空格分割成许多参数（默认情况下是通过空格分割），然后将参数传递给其后面的命令，**作为后面命令的命令行参数**。

tl.dr:
```
echo '--help' | xargs cat 
```

参数：
- -d 
  
  指定分隔符
  ```
  echo '11@22@33' | xargs echo 
  ```
  输出：11@22@33

  默认情况下以空白分割，那么 11@22@33 这个字符串中没有空白，所以实际上等价于 echo 11@22@33 其中字符串 '11@22@33' 被当作 echo 命令的一个命令行参数
  ```
  echo '11@22@33' | xargs -d '@' echo 
  ```
  输出：11 22 33

  指定以 @符号分割参数，所以等价于 echo 11 22 33 相当于给 echo 传递了 3 个参数，分别是 11、22、33

- -p 
  
  使用该选项之后 xargs 并不会马上执行其后面的命令，而是输出即将要执行的完整的命令（包括命令以及传递给命令的命令行参数)，询问是否执行，输入 y 才继续执行，否则不执行。

- -n 
  
  该选项表示将 xargs 生成的命令行参数，每次传递几个参数给其后面的命令执行，例如如果 xargs 从标准输入中读入内容，然后以分隔符分割之后生成的命令行参数有 10 个，使用 -n 3 之后表示一次传递给 xargs 后面的命令是 3 个参数，因为一共有 10 个参数，所以要执行 4 次，才能将参数用完。
  ```bash
  ╭─firejq@firejqwei-PC0 ~  
  ╰─$ echo '11@22@33@44@55@66@77@88@99@00' | xargs -d '@' -n 3 echo 
  11 22 33
  44 55 66
  77 88 99
  00
  ```

- -E 
  
  该选项指定一个字符串，当 xargs 解析出多个命令行参数的时候，如果搜索到 -e 指定的命令行参数，则只会将 -E 指定的命令行参数之前的参数（不包括 -e 指定的这个参数）传递给 xargs 后面的命令。
  ```
  echo '11 22 33 44 55' | xargs -E '33' echo 
  ```
  输出：11 22

## 11. 搜索

### 11.1. 文件搜索

#### 11.1.1. locate

#### 11.1.2. find

find 命令用来在指定目录下查找文件，任何位于参数之前的字符串都将被视为要查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件，并且将查找到的子目录和文件全部进行显示。

NOTE: 当搜索范围过大时，find 操作将会耗费大量的系统资源。

Usage:
```
find path -option condition
```

Options:
- 条件参数
  - `-name + 文件名` **默认完全匹配**，模糊匹配需要使用通配符。
    - `*` 任意多个字符
    - `?` 任意一个字符
    - `[]` 方括号内的任意一个字符 
  - `-iname + 文件名` 不区分大小写的 `-name`
  - `-regex + 正则`  使用正则表达式匹配文件名
  - `-iregex + 正则` 不区分大小写的 `-regex`
  - `-regextype` 指定使用正则的类型，可选的有 emacs（默认)，posix-awk，posix-basic，posix-egrep，posix-extended
  - `-type + 文件类型`: 搜索指定文件类型的文件。
    - d 目录
    - c 字符文件
    - b 区块文件
    - f 一般文件
    - l 链接文件
    - s socket 文件
  - `-user + 所有者`
  - `-mtime + 相对时间（天）` 搜索在指定时间段内发生了修改的文件
    
    ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/8/5/e38fe304b210547f4fc2cdeae71db25e.jpg)
    - `+10` 从今天往过去算的 10 天之前
    - `-10` 从今天往过去算的 10 天之内
    - `10` 从今天往过去算的第 10 天
  - `-mmin + 相对时间（分钟）` 搜索在指定时间段内发生了修改的文件
  - `-size 大小（M、k）（默认大小单位是数据块）`
    - `+10k` 大于 10k
    - `-10k` 小于 10k
    - `10k` 10k
  - `-inum + inode 节点`
  - `-perm + 权限` 搜索指定权限的文件 
  - `-path + 路径` 搜索指定路径格式的文件
- 逻辑参数
  - `-a` 逻辑与
  - `-o` 逻辑或
  - `-not` 逻辑非 
  eg:
  ```
  find /root -size +25k -a -size -50k
  ```
- 复合参数
  - `-exec` 相当于 xargs，将搜索结果传递给其它命令作为输入
    ```
    find . -name "*.h" -exec rm -rf {}\
    # equal to
    find . -name "*.h" xargs rm -rf
    ```
  - `-ok` 在执行操作之前进行询问
  

tldr:
```
  find

  Find files under the given directory tree, recursively.

  - Find files by extension:
    find root_path -name '*.ext'

  - Find files matching path pattern:
    find root_path -path '**/lib/**/*.ext'

  - Run a command for each file, use {} within the command to access the filename:
    find root_path -name '*.ext' -exec wc -l {} \;

  - Find files modified in the last 24-hour period:
    find root_path -mtime -1

  - Find files using case insensitive name matching, of a certain size:
    find root_path -size +500k -size -10MB -iname '*.TaR.gZ'

  - Delete files by name, older than 180 days:
    find root_path -name '*.ext' -mtime +180 -delete

  - Find files matching more than one search criteria:
    find root_path -name '*.py' -or -name '*.r'

  - Find files matching a given pattern, while excluding specific paths:
    find root_path -name '*.py' -not -path '*/site-packages/*'
```

### 11.2. 命令（二进制文件）搜索

#### 11.2.1. whereis

#### 11.2.2. which

## 12. 字符串搜索：grep

grep 命令用于查找文件里符合条件的字符串，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。

NOTE
- 若 pattern 包含空格或使用了正则表达式，则必须使用单引号包围，否则可不使用引号。
- 若不指定任何文件名称，或是所给予的文件名为"-"，则 grep 指令会从标准输入设备读取数据。
- grep **默认使用模糊匹配**。

Usage:
```
grep <pattern> file1 [file2 [file3]]
```

Options:
- -a 把二进制文件当作文本来处理
  - eg: 找回被删除的文件 `grep -a -B 50 -A 60 'string' /dev/sda1 > new.txt`
- `-A 行数` 或 `--after-context= 行数`: 除了显示符合范本样式的那一列之外，并显示该行之后的内容。
- -b 或 --byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。
- `-B 行数` 或 `--before-context= 行数`: 除了显示符合样式的那一行之外，并显示该行之前的内容。
- -c 或 --count : 计算符合样式的列数。
- `-C 行数` 或 `--context= 行数`: 除了显示符合样式的那一行之外，并显示该行前后的内容。
- `-d 动作` 或 `--directories= 动作`: 当指定要查找的是目录而非文件时，必须使用这项参数，否则 grep 指令将回报信息并停止动作。
- `-E` 或 `--extended-regexp`: 使用扩展的 POSIX 正则表达式（ERE）。
- -i 或 --ignore-case : 忽略字符大小写的差别。
- -n 或 --line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。
- -r 或 --recursive : 此参数的效果和指定"-d recurse"参数相同。
- -v 或 --revert-match : 显示不包含匹配文本的所有行。
- -w 或 --word-regexp : 只显示全字符合的列。
- -x : 只显示全列符合的列。

tldr:
```
  grep

  Matches patterns in input text.
  Supports simple patterns and regular expressions.

  - Search for an exact string:
    grep search_string path/to/file

  - Search in case-insensitive mode:
    grep -i search_string path/to/file

  - Search recursively (ignoring non-text files) in current directory for an exact string:
    grep -RI search_string .

  - Use extended regular expressions (supporting ?, +, {}, () and |):
    grep -E ^regex$ path/to/file

  - Print 3 lines of [C]ontext around, [B]efore, or [A]fter each match:
    grep -C|B|A 3 search_string path/to/file

  - Print file name with the corresponding line number for each match:
    grep -Hn search_string path/to/file

  - Use the standard input instead of a file:
    cat path/to/file | grep search_string

  - Invert match for excluding specific strings:
    grep -v search_string
```

## 13. 权限控制

### 13.1. 基础概念

Linux/Unix 系统中对文件的权限有着严格的控制，如果想对某个文件执行某种操作，必须具有对应的权限才能执行成功。

#### 13.1.1. 权限类型

##### 13.1.1.1. 基本权限类型

文件的基本权限类型一般包括：
- 读权限，用 `r`(read) 表示
- 写权限，用 `w`(write) 表示
- 执行权限，用 `x`(execute) 表示
- 无权限，用 `-` 表示

NOTE: 

Linux/unix 下文件的权限只控制对文件**内容**的访问 / 修改 / 执行，对**文件**本身的控制是由父目录的权限决定的。
  
- 对于普通用户：
  - 显示目录（如 ls）需要对目录拥有读权限 (r)。
  - 进入目录（如 cd）需要对目录拥有执行权限 (x)。
  - 创建文件（如 touch、mkdir）和删除文件（如 rm）需要对父目录拥有执行权限 (x) （需要先进入目录才能操作）和写权限 (w)，不需要对文件有任何权限。
  - 读取文件（如 cat）需要对父目录拥有执行权限 (x)（需要先进入目录才能操作），对文件拥有读权限 (r)。
  - 修改文件（如 vim）需要对父目录拥有执行权限 (x)（需要先进入目录才能操作），对文件拥有读权限 (r) 和写权限 (w)。
  - 执行文件需要对父目录拥有执行权限 (x)（需要先进入目录才能操作），对文件拥有执行权限 (x)。
  
  例：在用户目录下（$HOME）有一个文件 file（$HOME/file），该 file 的 owner 为 root，即权限为 -rw-r--r--;$USER 虽然没有 file 的 write 权限，但是仍可以删除该 file 文件。因为 $USER 拥有 $HOME 目录的 write 和 execute 权限。

- 对于超级用户 (root)：无论权限如何，都可以进入目录，进行读写和执行操作。

##### 13.1.1.2. 附加权限类型

除了正常的读写操作权限之外，Linux 文件系统还包含了附加权限类型：
- SET 位权限 (SET UID & SET GID)
  
  SUID/SGID 是为了使没有取得特权的用户要完成一项必须要有特权才可以执行的任务而产生的，一般用于给可执行的程序或脚本文件，其中 SUID 表示对属主用户增加 SET 位权限，SGID 表示对属组内用户增加 SET 位权限。**可执行文件被设置了 SUID、SGID 权限后，任何用户执行该文件时，将获得该文件属主、属组账号对应的身份**。在许多环境中，SUID 和 SGID 很管用，但是不恰当地使用这些位可能使系统的安全遭到破坏。所以应该尽量避免使用 SET 位权限程序。

  **如果一个文件被设置了 SUID 或 SGID 位，会分别表现在所有者或同组用户的权限的可执行位上**。如果文件设置了 SUID 还设置了 x（执行）位，则相应的执行位表示为 s（小写)。如果没有设置 x 位，则相应的位将表示为 S（大写)：
  ```
  -rwsr-xr-x 表示 SUID 被设置，且拥有者有可执行权限
  -rwSr--r-- 表示 SUID 被设置，但拥有者没有可执行权限
  -rwxr-sr-x 表示 SGID 被设置，且群组用户有可执行权限
  -rw-r-Sr-- 表示 SGID 被设置，但群组用户没有可执行权限
  ```

- 粘滞位权限 (Sticky) 

  粘滞位权限一般用于为目录设置特殊的附加权限，**当目录被设置了粘滞位权限后，即便用户对该目录有写的权限，也不能删除该目录中其他用户的文件数据**。

  **如果一个文件或目录被设置了粘滞位权限，会表现在其他组用户的权限的可执行位上**。如果文件设置了 sticky 还设置了 x（执行）位，其他组用户的权限的可执行位为 t（小写）。但是，如果没有设置 x 位，它将表示为 T（大写）：
  ```
  -rwsr-xr-t 表示设置了粘滞位且其他用户组有可执行权限
  -rwSr--r-T 表示设置了粘滞位但其他用户组没有可执行权限
  ```

#### 13.1.2. 权限粒度

权限粒度一般分为三级：`owner`、`group`、`others`，每个文件都可以针对三个粒度，设置不同的 rwx 权限。通常情况下，一个文件只能归属于一个用户和组， 如果其它的用户想有这个文件的权限，则可以将该用户加入具备权限的群组，一个用户可以同时归属于多个组。

eg: `-rwxr--r--` 表示 `-（文件类型）×××（所有者权限）×××（组用户权限）×××（其他用户权限）`

#### 13.1.3. 权限表示

一个文件的所有权限详情，一般有 2 种表示方式：
- **10 位二进制表示法**：三个属组每个都使用 3 个二进制位表示，再加一个最高位共十位，可简化为 3 位八进制形式。

  如果我们将各个位置权限的有无用二进制数 1 和 0 来代替，则只读、只写、只执行权限，可以用 3 位二进制数来表示，且可以转换为八进制数如下：
  ```
  r-- = 100(2) = 4(8)
  -w- = 010(2) = 2(8)
  --x = 001(2) = 1(8)
  --- = 000(2) = 0(8)
  ```
  也就是说，r、w、x 权限可以分别用数字表示如下：
  - r(read) 权限为 4
  - w(write) 权限为 2
  - x(execute) 权限为 1
  我们可以进一步将所有的权限用二进制形式表现出来，并进一步转变成八进制数字：
  ```
  rwx = 111 = 7
  rw- = 110 = 6
  r-x = 101 = 5
  r-- = 100 = 4
  -wx = 011 = 3
  -w- = 010 = 2
  --x = 001 = 1
  --- = 000 = 0
  ```

  如果我们将每个属组的权限都用八进制数表示，则文件的权限可以表示为 3 位八进制数：
  ```
  -rw------- (600)      只有拥有者有读写权限。
  -rw-r--r-- (644)      只有拥有者有读写权限；而属组用户和其他用户只有读权限。
  -rwx------ (700)      只有拥有者有读、写、执行权限。
  -rwxr-xr-x (755)      拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。
  -rwx--x--x (711)      拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。
  -rw-rw-rw- (666)      所有用户都有文件读、写权限。
  -rwxrwxrwx (777)      所有用户都有读、写、执行权限。
  ```

  对于最高位，它代表的是文件的类型，类型可以是下面几个中的一个：
  - `d` 代表的是目录 (directroy)。
  - `-` 代表的是文件 (regular file)。
  - `s` 代表的是套接字文件 (socket)。
  - `p` 代表的管道文件 (pipe) 或命名管道文件 (named pipe)。
  - `l` 代表的是符号链接文件 (symbolic link)。
  - `b` 代表的是该文件是面向块的设备文件 (block-oriented device file)。
  - `c` 代表的是该文件是面向字符的设备文件 (charcter-oriented device file)。

- **12 位二进制表示法**：可简化为 4 位八进制形式。

  12 位二进制的权限表示法在 10 位二进制表示法的基础上，高 3 位分别表示 SUID、SGID、Sticky 权限的有无，即第 11 位为 SUID 位，第 10 位为 SGID 位，第 9 位为 sticky 位，第 8-0 位对应于上面的三组 rwx 位（后九位）。
  ```
  -rw-r-sr-- 的值为： 0 1 0  1 1 0  1 0 0  1 0 0
  -rwsr-xr-x 的值为： 1 0 0  1 1 1  1 0 1  1 0 1
  -rwsr-sr-x 的值为： 1 1 0  1 1 1  1 0 1  1 0 1 
  -rwsr-sr-t 的值为： 1 1 1  1 1 1  1 0 1  1 0 1
  ```
  将前三位 `SGT` 也转换成一个八进制数，则：
  - SUID 权限为 4
  - SGID 权限为 2
  - Sticky 权限为 1
  
  因此，文件的权限可以表示为 4 位八进制数
  ```
  -rw-r-sr-- = 0 1 0 1 1 0 1 0 0 1 0 0 = 2644 
  -rwsr-xr-x = 1 0 0 1 1 1 1 0 1 1 0 1 = 4755
  -rwsr-sr-x = 1 1 0 1 1 1 1 0 1 1 0 1 = 6755
  -rwsr-sr-t = 1 1 1 1 1 1 1 0 1 1 0 1 = 7755
  ```

### 13.2. chmod

通过`chmod`命令可以对文件调用权限进行设置和更改。

Usage:
```
chmod [OPTION]... MODE[,MODE]... FILE...
  or:  chmod [OPTION]... OCTAL-MODE FILE...
  or:  chmod [OPTION]... --reference=RFILE FILE...
```

Options:
- `-c`: 若该文件权限确实已经更改，才显示其更改动作。
- `-f`: 若该文件权限无法被更改也不要显示错误讯息。
- `-v`: 显示权限变更的详细资料。
- `-R`: 对目前目录下的所有文件与子目录进行相同的权限变更（以递归方式逐个变更）。

MODE:
- 方式一：字母设置
  ```
  (ugoa...)(+-=)(rwxX)
  ```
  即：
  ```
  操作对象 + 权限增减 + 操作权限
  ```
  其中：
  - `u` 表示该文件的拥有者，`g` 表示与该文件的拥有者属于同一个群体 (group) 者，`o` 表示其他以外的人，`a` 表示这三者皆是。
  - `+` 表示增加权限、`-` 表示取消权限、`=` 表示唯一设定权限。
  - `r` 表示可读取，`w` 表示可写入，`x` 表示可执行，`X` 表示只有当该文件是个子目录或者该文件已经被设定过为可执行，`s` 表示 SET 位权限，`t` 表示粘滞位权限。
  eg:
  ```bash
  # 将文件 file1.txt 设为所有人可读
  chmod a+r file1.txt
  # 将文件 file1.txt 与 file2.txt 设为该文件拥有者、与其所属同一个群体者可写入，但其他以外的人则不可写入
  chmod ug+w,o-w file1.txt file2.txt
  # 将 ex1.py 设定为只有该文件拥有者可以执行 
  chmod u+x ex1.py
  # 为 ex2.py 设置 SUID SET 位权限
  chmod u+s ex2.py
  ```

- 方式二：数字设置
  ```
  abc 
  ```
  其中：a、b、c 各为一个数字，分别表示 user、group、other 的权限。
  因此：
  - 若要 `rwx` 属性则设置 4+2+1=7.
  - 若要 `rw-` 属性则设置 4+2=6.
  - 若要 `r-x` 属性则设置 4+1=5.
  eg:
  ```bash
  # chmod a=rwx file 相当于
  chmod 777 file
  # chmod ug=rwx,o=x file 相当于
  chmod 771 file
  # chmod u=rws,g=rx,o=rx file 相当于
  chmod 4755 file
  ```

tldr:
```
chmod

  Change the access permissions of a file or directory.

  - Give the [u]ser who owns a file the right to e[x]ecute it:
    chmod u+x file

  - Give the user rights to [r]ead and [w]rite to a file/directory:
    chmod u+rw file

  - Remove executable rights from the [g]roup:
    chmod g-x file

  - Give [a]ll users rights to read and execute:
    chmod a+rx file

  - Give [o]thers (not in the file owner's group) the same rights as the group:
    chmod o=g file

  - Change permissions recursively giving [g]roup and [o]thers the abililty to [w]rite:
    chmod -R g+w,o+w directory
```

## 14. Refer Links

[Runoob Linux grep 命令](http://www.runoob.com/linux/linux-comm-grep.html)

[Runoob Linux find 命令](http://www.runoob.com/linux/linux-comm-find.html)

[Runoob Linux chmod 命令](http://www.runoob.com/linux/linux-comm-chmod.html)

[Linux 权限详解（chmod、600、644、666、700、711、755、777、4755、6755、7755）](https://blog.csdn.net/u013197629/article/details/73608613)

[在 Linux 下进入目录，目录下创建、修改、删除文件所需权限](https://blog.csdn.net/Korey_sparks/article/details/52389941)