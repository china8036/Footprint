- [Base Operation](#base-operation)
  - [1. echo](#1-echo)
  - [2. cp](#2-cp)
  - [3. ls](#3-ls)
  - [4. ln](#4-ln)
  - [5. tar](#5-tar)
  - [6. cat](#6-cat)
  - [7. nl](#7-nl)
  - [8. tree](#8-tree)
  - [9. diff](#9-diff)
  - [10. xargs](#10-xargs)
    - [10.1. 背景：`xargs` 与 `|` 的区别](#101-背景xargs-与--的区别)
    - [10.2. 使用方法](#102-使用方法)
  - [11. strings](#11-strings)
  - [12. file](#12-file)
  - [13. size](#13-size)
  - [14. nm](#14-nm)
  - [15. objdump](#15-objdump)
  - [16. 搜索](#16-搜索)
    - [16.1. 文件搜索](#161-文件搜索)
      - [16.1.1. locate](#1611-locate)
      - [16.1.2. find](#1612-find)
        - [16.1.2.1. Options](#16121-options)
        - [16.1.2.2. Expression](#16122-expression)
    - [16.2. 命令（二进制文件）搜索](#162-命令二进制文件搜索)
      - [16.2.1. whereis](#1621-whereis)
      - [16.2.2. which](#1622-which)
  - [17. 字符串搜索：grep](#17-字符串搜索grep)
  - [18. 权限控制](#18-权限控制)
    - [18.1. 基础概念](#181-基础概念)
      - [18.1.1. 权限类型](#1811-权限类型)
        - [18.1.1.1. 基本权限类型](#18111-基本权限类型)
        - [18.1.1.2. 附加权限类型](#18112-附加权限类型)
      - [18.1.2. 权限粒度](#1812-权限粒度)
      - [18.1.3. 权限表示](#1813-权限表示)
    - [18.2. chmod](#182-chmod)
  - [19. Refer Links](#19-refer-links)

# Base Operation

## 1. echo

Options
- `-n` 关闭自动插入换行符（默认开启）。
- `-e` 开启对转义字符进行识别替换（默认关闭）

  eg: 通过 echo 改变 shell 输出颜色：
  ```
  echo -e "\e[1;color_code text \e[1;color_code"
  ```
  其中，`\e[1;color_code` 表示改变终端颜色。如：`echo -e "\e[1;31m hahahaha \e[0m"` 可输出红色的字符 'hahahaha'。

tldr:
```bash
  echo

  Print given arguments.

  - Print a text message. Note: quotes are optional:
    echo "Hello World"

  - Print a message with environment variables:
    echo "My path is $PATH"

  - Print a message without the trailing newline:
    echo -n "Hello World"

  - Enable interpretation of backslash escapes (special characters):
    echo -e "Column 1\tColumn 2"
```

## 2. cp

tldr:
```bash
  Copy files and folders.

  - Copy a file to another location:
    cp path/to/file.ext path/to/copy.ext

  - Copy a file into another folder, keeping the filename:
    cp path/to/file.ext path/to/target/parent/folder

  - Copy a folder recursively to another location:
    cp -r path/to/folder path/to/copy

  - Copy the contents of a folder into another folder:
    cp -r path/to/source/folder/* path/to/target/folder

  - Copy text files to another location, in interactive mode (prompts user before overwriting):
    cp -i *.txt path/to/source/
```

## 3. ls

```
ls [Options] [Directory]
```
- -a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件
- -A 同 -a，但不列出“.”（表示当前目录) 和“..”（表示当前目录的父目录)。
- -c  配合 -lt：根据 ctime 排序及显示 ctime （文件状态最后更改的时间) 配合 -l：显示 ctime 但根据名称排序否则根据 ctime 排序
- -C 每栏由上至下列出项目
- –color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是'never'、'always'或'auto'其中之一
- -d, –directory 将目录像文件一样显示，而不是显示其下的文件。
- -D, –dired 产生适合 Emacs 的 dired 模式使用的结果
- -f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效
- -g 类似 -l, 但不列出所有者
- -G, –no-group 不列出任何有关组的信息
- -h, –human-readable 以容易理解的格式列出文件大小（例如 1K 234M 2G)
- –si 类似 -h, 但文件大小取 1000 的次方而不是 1024
- -H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地
- –indicator-style= 方式 指定在每个项目名称后加上指示符号《方式》：none （默认)，classify (-F)，file-type (-p)
- -i, –inode 印出每个文件的 inode 号
- -I, –ignore=pattern 排除 pattern 匹配的文件
- -k 即 –block-size=1K, 以 k 字节的形式表示文件的大小。
- -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。
- -L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息
- -m 所有项目以逗号分隔，并填满整行行宽
- -o 类似 -l, 显示文件的除组信息外的详细信息。
- -r, –reverse 依相反次序排列
- -R, –recursive 同时列出所有子目录层
- -s, –size 以块大小为单位列出所有文件的大小
- -S 根据文件大小排序
- –sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：
  - extension -X status -c
  - none -U time -t
  - size -S atime -u
  - time -t access -u
  - version -v use -u
- -t 以文件修改时间排序
- -U 不进行排序；依文件系统原有的次序列出项目
- -v 根据版本进行排序
- -w, –width=COLS 自行指定屏幕宽度而不使用目前的数值
- -x 逐行列出项目而不是逐栏列出
- -X 根据扩展名排序
- -1 每行只列出一个文件
- –help 显示此帮助信息并离开
- –version 显示版本信息并离开

NOTE:
- 查看 Linux 文件的 atime/mtime/ctime：
  - `ls -ul` 看到的时间即为 atime。
  - `ls -l` 看到的时间即为 mtime。
  - `ls -t` 看到的时间即为 ctime。

e.g.
```
ls -Alht // sorted by time
ls -AlhS // sorted by size
ls -I file_name // ignore file_name

ls | sed "s:^:`pwd`/:" // 在 ls 中列出文件的绝对路径
```

tldr:
```
  ls

  List directory contents.

  - List files one per line:
    ls -1

  - List all files, including hidden files:
    ls -a

  - Long format list (permissions, ownership, size and modification date) of all files:
    ls -la

  - Long format list with size displayed using human readable units (KB, MB, GB):
    ls -lh

  - Long format list sorted by size (descending):
    ls -lS

  - Long format list of all files, sorted by modification date (oldest first):
    ls -ltr
```

## 4. ln

## 5. tar

Options:
- --delete : 从归档文件 （而非磁带) 中删除
- -r, --append : 将文件追加到归档文件中
- -t, --list : 列出归档文件中包含的内容
- --test-label : 测试归档文件卷标并退出
- -u, --update : 将已更新的文件追加到归档文件中
- -x, --extract, --get : 释放归档文件中文件及目录
- -C, --directory=DIR : 执行归档动作前变更工作目录到 DIR
- -f, --file=ARCHIVE : 指定 （将要创建或已存在的) 归档文件名
- -j, --bip2 : 对归档文件使用 bzip2 压缩
- -J, --xz : 对归档文件使用 xz 压缩
- -p, --preserve-permissions : 保留原文件的访问权限
- -v, --verbose : 显示命令整个执行过程
- -z, gzip : 对归档文件使用 gzip 压缩 / 解压缩

NOTE: 在 tar 命令选项中的连接符 `-` 是可选的（tar 命令更多受到古老的 UNIX 风格影响）。

tldr:
```
  tar
  Archiving utility.
  Often combined with a compression method, such as gzip or bzip.

  - Create an archive from files:
    tar cf target.tar file1 file2 file3

  - Create a gzipped archive:
    tar czf target.tar.gz file1 file2 file3

  - Extract an archive in a target folder:
    tar xf source.tar -C folder

  - Extract a gzipped archive in the current directory:
    tar xzf source.tar.gz

  - Extract a bzipped archive in the current directory:
    tar xjf source.tar.bz2

  - Create a compressed archive, using archive suffix to determine the compression program:
    tar caf target.tar.xz file1 file2 file3

  - List the contents of a tar file:
    tar tvf source.tar

  - Extract files matching a pattern:
    tar xf source.tar --wildcards "*.html"
```

## 6. cat

## 7. nl

nl(number lines of files) is used to write each FILE to standard output, with line numbers added.

## 8. tree

usage:
```bash
tree [-adfghilnpqrstuvxACDFNS] [-H baseHREF] [-T title ] [-L level [-R]]
    [-P pattern] [-I pattern] [-o filename] [--version] [--help] [--inodes]
    [--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset]
    [--filelimit #] [<directory list>]
```
- `-a`: 显示所有文件和目录。
- `-A`: 使用 ASNI 绘图字符显示树状图而非以 ASCII 字符组合。
- `-C`: 在文件和目录清单加上色彩，便于区分各种类型。
- `-d`: 显示目录名称而非内容。
- `-D`: 列出文件或目录的更改时间。
- `-f`: 在每个文件或目录之前，显示完整的相对路径名称。
- `-F`: 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上"*","/","=","@","|"号。
- `-g`: 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。
- `-i`: 不以阶梯状列出文件或目录名称。
- `-I`: 不显示符合范本样式的文件或目录名称。
- `-l`: 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。
- `-n`: 不在文件和目录清单加上色彩。
- `-N`: 直接列出文件和目录名称，包括控制字符。
- `-p`: 列出权限标示。
- `-P`: 只显示符合范本样式的文件或目录名称。
- `-q`: 用"?"号取代控制字符，列出文件和目录名称。
- `-s`: 列出文件或目录大小。
- `-t`: 用文件和目录的更改时间排序。
- `-u`: 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。
- `-x`: 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。

tldr:
```
tree -DFpsf
```

## 9. diff

diff 命令用来比较两个文本文件的差异，是代码版本管理的基石之一。

```
diff 《变动前的文件》 《变动后的文件》
```

todo: [阮一峰：读懂 diff](http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html)

- 正常模式

- 上下文模式 `-c`

- 合并模式 `-u`

## 10. xargs

### 10.1. 背景：`xargs` 与 `|` 的区别

对于 UNIX 命令，一般可以通过 2 种方式来获取用户输入：
- 命令行参数：反映在程序上，命令行参数一般通过 main 函数 `int main(int argc,char*argv[])` 的函数参数获得。
- 标准输入 (stdin)：反映在程序上，标准输入一般通过标准输入函数（例如 C 语言中的 scanf）读取到。

对于一部分 UNIX 命令，其设计是既可以从命令行参数中获取参数，也支持从标准输入中读取。例如，cat、grep 等文字处理命令：
```bash
echo 'main' | cat  # 这条命令中 cat 会从其标准输入中读取内容并处理，也就是会输出 'main' 字符串
echo 'main' | cat -  # 如果直接在命令的最后指定 -  则表示从标准输入中读取
echo 'main' | cat test.cpp -  # 同时指定 test.cpp 和 - 参数，此时 cat 程序会先输出 test.cpp 的内容，然后输出标准输入'main'字符串
echo 'main' | cat - test.cpp  # 如果换一下顺序，则会先输出标准输入'main'字符串，然后输出 test.cpp 文件的内容
echo 'main' | cat test.cpp  # 如果去掉 -，则 cat 只从标准输入读取内容，即输出 test.cpp 的内容，而不是'main'字符串，如果 test.cpp 不存在则 cat 命令报告该文件不存在
echo 'main' | grep 'main' test.cpp -  # grep 同理，如果同时传递标准输入和文件名，grep 也会同时处理这两个输入，也就是说会在标准输入中搜索 'main' 也会在文件 test.cpp （该文件名从 grep 命令行参数中获得) 中搜索 'main'
```
但实际上，也有很多命令**只接受命令行参数，而不读取 stdin 的内容**，这取决于命令程序的内部实现。例如，kill、rm、ls 等命令：
```bash
# 以下 2 个命令都没有任何效果
echo '516' | kill
echo 'test' | rm -f
# 以下 ls 命令列出当前目录下的所有文件
echo "test.sh" | ls
```
因此，针对这部分命令，如果需要使用上一个命令的执行结果作为参数输入，可以有以下解决方案：
- 通过 kill \`ps -ef | grep 'ddd'\`，实际上等同于拼接字符串得到的命令，其效果类似于  `kill $pid`。
- `for procid in $(ps -aux | grep "some search" | awk '{print $2}'); do kill -9 $procid; done`，其实与第一种原理一样，只不过需要多次 kill 的时候是循环处理的，每次处理一个。
- 使用 `xargs` 命令来实现：`ps -ef | grep 'ddd' | xargs kill`

### 10.2. 使用方法

`xargs` 命令可以通过管道接受字符串，并将接收到的字符串通过空格分割成许多参数（默认情况下是通过空格分割），然后将参数传递给其后面的命令，**也就是将标准输入的内容转化为命令行参数，提供给后边的命令**。

参数：
- -d

  指定分隔符
  ```
  echo '11@22@33' | xargs echo
  ```
  输出：11@22@33

  默认情况下以空白分割，那么 11@22@33 这个字符串中没有空白，所以实际上等价于 echo 11@22@33 其中字符串 '11@22@33' 被当作 echo 命令的一个命令行参数
  ```
  echo '11@22@33' | xargs -d '@' echo
  ```
  输出：11 22 33

  指定以 @符号分割参数，所以等价于 echo 11 22 33 相当于给 echo 传递了 3 个参数，分别是 11、22、33

- -0

  使用 null 作为分隔符。

- -p

  使用该选项之后 xargs 并不会马上执行其后面的命令，而是输出即将要执行的完整的命令（包括命令以及传递给命令的命令行参数)，询问是否执行，输入 y 才继续执行，否则不执行。

- -t

  打印出最终要执行的命令，然后直接执行，不需要用户确认。

- -n

  该选项表示将 xargs 生成的命令行参数，每次传递几个参数给其后面的命令执行，例如如果 xargs 从标准输入中读入内容，然后以分隔符分割之后生成的命令行参数有 10 个，使用 -n 3 之后表示一次传递给 xargs 后面的命令是 3 个参数，因为一共有 10 个参数，所以要执行 4 次，才能将参数用完。
  ```bash
  ╭─firejq@firejqwei-PC0 ~
  ╰─$ echo '11@22@33@44@55@66@77@88@99@00' | xargs -d '@' -n 3 echo
  11 22 33
  44 55 66
  77 88 99
  00
  ```

- -E

  该选项指定一个字符串，当 xargs 解析出多个命令行参数的时候，如果搜索到 -E 指定的命令行参数，则只会将 -E 指定的命令行参数之前的参数（不包括 -e 指定的这个参数）传递给 xargs 后面的命令。
  ```
  echo '11 22 33 44 55' | xargs -E '33' echo
  ```
  输出：11 22

- -L

  如果标准输入包含多行，-L 参数指定多少行作为一个命令行参数。

- -I

  如果 xargs 要将命令行参数传给多个命令，可以使用 -I 参数，-I 指定每一项命令行参数的替代字符串。
  ```
  $ cat foo.txt
  one
  two
  three

  $ cat foo.txt | xargs -I file sh -c 'echo file; mkdir file'
  one
  two
  three

  $ ls
  one two three
  ```

- -i
  <!-- TODO: -->
  ```
  printf "1\n2\n3\n" | xargs -i touch {}.txt
  ```

NOTE:
- xargs 后面的命令默认是 echo，`xargs` 等同于 `xargs echo`。
- 大多数时候，xargs 命令都是跟管道一起使用的，但事实上它也可以单独使用：
  ```bash
  $ xargs find -name
  "*.txt"
  ./foo.txt
  ./hello.txt
  ```
  上面的例子输入 `xargs find -name` 以后，命令行会等待用户输入所要搜索的文件。用户输入"*.txt"，表示搜索当前目录下的所有 TXT 文件，然后按下 Ctrl d，表示输入结束。这时就相当执行 `find -name *.txt`。

tl.dr:
```
echo '--help' | xargs cat
```

e.g. 与 find 搭配使用：
```
find . -type f -print | xargs file  # 查找系统中的每一个普通文件，然后使用 xargs 命令来测试它们分别属于哪类文件
find / -name "core" -print | xargs echo "" >/tmp/core.log  # 在整个系统中查找内存信息转储文件 (core dump) ，然后把结果保存到 /tmp/core.log 文件中
find . -perm -7 -print | xargs chmod o-w  # 在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限
find . -type f -print | xargs grep "hostname"  # 用 grep 命令在所有的普通文件中搜索 hostname 这个词
find . -type f -atime +0 -print0 | xargs -0 -l1 -t rm -f  # find 后执行 xargs 提示 xargs: argument line too long 解决方法
find . -name "*.log" | xargs -i mv {} test4  # 使用 xargs 执行 mv
```

## 11. strings

strings 命令用于打印文件中的所有可打印字符，该文件可以是文本文件、二进制文件等类型。

tldr.
```
  strings

  Find printable strings in an object file or binary.

  - Print all strings in a binary:
    strings file

  - Limit results to strings at least length characters long:
    strings -n length file

  - Prefix each result with its offset within the file:
    strings -t d file

  - Prefix each result with its offset within the file in hexadecimal:
    strings -t x file
```

strings 命令有很多实际用途，e.g.

在大型的软件开发中，假设有 100 个 `.c/.cpp` 文件， 这些 `.cpp` 文件最终生成 10 个 `.so` 库， 那么怎样才能快速知道某个 `.c/.cpp` 文件编译到那个 `.so` 库中去了呢？
```
$ strings -f "*.so" | grep "my dear"

  a.out: oh, my dear, c is %d
  test.c: 	printf("oh, my dear, c is %d\n", c);
```
可以看到，源文件 `test.c` 和可执行文件中皆有"my dear"串，一下子就找到了对应的文件。

## 12. file

## 13. size

## 14. nm

## 15. objdump

## 16. 搜索

### 16.1. 文件搜索

#### 16.1.1. locate

#### 16.1.2. find

find 命令用来在指定目录下查找文件，任何位于参数之前的字符串都将被视为要查找的目录名。

Usage:
```
find path -option condition
```
NOTE:
- 如果搜索范围过大，find 操作将会耗费大量的系统资源。
- 如果使用该命令时，不设置任何参数，则 find 命令**将默认在当前目录下查找子目录与文件，并且将查找到的子目录和文件全部进行显示**。

##### 16.1.2.1. Options

- -P 表示不追随符号链接
- -L 表示追随符号链接
- -H 表示只追随命令行中的符号链接
- -D debug 的选项，一般的使用者不关心这个。
- -O 开启查询的优化有 1,2,3 级。

##### 16.1.2.2. Expression

- Test：用于判断的表达式，返回 true 或者是 false。

  - `-name + 文件名` **默认完全匹配**，模糊匹配需要使用通配符。
    - `*` 任意多个字符
    - `?` 任意一个字符
    - `[]` 方括号内的任意一个字符
  - `-iname + 文件名` 不区分大小写的 `-name`
  - `-regex + 正则`  使用正则表达式匹配文件名
  - `-iregex + 正则` 不区分大小写的 `-regex`
  - `-regextype` 指定使用正则的类型，可选的有 emacs（默认)，posix-awk，posix-basic，posix-egrep，posix-extended
  - `-type + 文件类型`: 搜索指定文件类型的文件
    - d 目录
    - c 字符文件
    - b 区块文件
    - f 一般文件
    - l 链接文件
    - p 管道文件
    - s socket 文件
  - `-user + 所有者`

  - `-mtime + 相对时间（天）` 搜索在指定时间段内发生了修改的文件

    > File's data was last modified n*24 hours ago.

    ![image](http://img.cdn.firejq.com/jpg/2018/8/5/e38fe304b210547f4fc2cdeae71db25e.jpg)

    - `+10` 从今天往过去算的 10 天之前
    - `-10` 从今天往过去算的 10 天之内
    - `10` 从今天往过去算的第 10 天

  - `-mmin + 相对时间（分钟）` 搜索在指定时间段内发生了修改的文件

    > File's data was last modified n minutes ago.

  - `-atime + n`: File  was last accessed n*24 hours ago.  When find figures out how many 24-hour periods ago the file was last accessed, any fractional part is ignored, so to match -atime +1, a file has to have been accessed at least two days ago.
  - `-amin + n`: File was last accessed n minutes ago.

  - `-ctime + n`: File's status was last changed n*24 hours ago.  See the comments for -atime to understand how rounding affects the interpretation of file status change times.
  - `-cmnin + n`: File's status was last changed n minutes ago.

  - `-size 大小（M、k）（默认大小单位是数据块）`
    - `+10k` 大于 10k
    - `-10k` 小于 10k
    - `10k` 10k

  - `-inum + inode 节点`
  - `-perm + 权限` 搜索指定权限的文件
    - `-perm mode`
    - `-perm -mode`
    - `-perm /mode`
    - `-perm +mode`
  - `-path + 路径` 搜索指定路径格式的文件

- Operators：逻辑连接
  - `-a` 逻辑与（默认值）
  - `-o` 逻辑或
  - `-not` 逻辑非
  e.g.
  ```
  find /root -size +25k -a -size -50k
  ```

- Action：对符合 test 标准的文件的行为

  - `-delete`

  - `-print0`

    指定输出的文件列表以 null 分隔。

    e.g.
    ```bash
    find /path -type f -print0 | xargs -0 rm  # 删除 /path 路径下的所有文件。由于分隔符是 null，所以处理包含空格的文件名，也不会报错
    find . -type f -atime +0 -print0 | xargs -0 -l1 -t rm -f  # 有些命令（比如 rm）一旦参数过多会报错"参数列表过长"，而无法执行，改用 xargs 就没有这个问题，因为它对每个参数执行一次命令。
    ```

  - `-exec cmd` 相当于 xargs，将搜索结果传递给其它命令作为输入
    ```
    find . -name "*.h" -exec rm -rf {}\
    # equal to
    find . -name "*.h" xargs rm -rf
    ```
    - `-exec command \;`: command 的终止是以 `;` 为结束标志的，考虑到各个系统中分号会有不同的意义，所以通常会在 `;` 前面加反斜杠。
    - `-exec command {} \;`: 花括号 `{}` 代表前面 find 查找出来的文件名，可起到 xargs 命令的作用。
    - `-exec command {} +` 与上一条唯一的区别在于，不把每个文件都作为参数分别传给命令，而是把所有文件并列作为参数一次传给命令。使用 `find * -exec echo {} \;` 和 `find * -exec echo {} \+` 可以很清楚的显示他们的区别。

    e.g.
    ```
    find . -type f -exec ls -l {} \;
    find . -type f -mtime +14 -exec rm {} \;  # 在目录中查找更改时间在 n 日以前的文件并删除它们
    find /etc -name "passwd*" -exec grep "root" {} \;  # find 命令首先匹配所有文件名为“ passwd*”的文件，例如 passwd、passwd.old、passwd.bak，然后执行 grep 命令看看在这些文件中是否存在一个 root 用户
    find . -name "*.log" -exec mv {} .. \;  # 查找文件并移动到上一级目录
    find . -name "*.log" -exec cp {} test3 \;  #
    ```

    NOTE:

    使用 `-exec` 与 `xargs` 的区别：<!-- TODO: -->
    - 使用 `-exec` 时参数是一个一个传递的，传递一个参数执行一次 cmd；`xargs` 命令一次将参数传给命令，可以使用 `-n` 控制参数个数
    - 使用 `-exec` 时文件名有空格等特殊字符也能处理；`xargs` 命令不能

    e.g.
    ```bash
    #find . -type f |xargs -t -n 2 echo
    echo ./data.txt ./env2.txt
    ./data.txt ./env2.txt
    echo ./env.txt ./export2.txt
    ./env.txt ./export2.txt
    echo ./s.txt ./d.txt
    ./s.txt ./d.txt
    echo ./export.txt ./set.txt
    ./export.txt ./set.txt
    echo ./fuck.txt
    ./fuck.txt

    #find . -type f -exec echo begin {} \;
    begin ./data.txt
    begin ./env2.txt
    begin ./env.txt
    begin ./export2.txt
    begin ./s.txt
    begin ./d.txt
    begin ./export.txt
    begin ./set.txt
    ```

    e.g.
    ```bash
    find . -type f -print | xargs file  # 查找系统中的每一个普通文件，然后使用 xargs 命令来测试它们分别属于哪类文件
    find / -name "core" -print | xargs echo "" >/tmp/core.log  # 在整个系统中查找内存信息转储文件 (core dump) ，然后把结果保存到 /tmp/core.log 文件中
    find . -perm -7 -print | xargs chmod o-w  # 在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限
    find . -type f -print | xargs grep "hostname"  # 用 grep 命令在所有的普通文件中搜索 hostname 这个词
    find . -name "*.log" | xargs -i mv {} test4  # 使用 xargs 执行 mv
    ```

  - `-ls`

  - `-ok` 相当于加上交互确认的 `-exec`。

    e.g.
    ```
    find . -name "*.log" -mtime +5 -ok rm {} \;  # 在目录中查找更改时间在 n 日以前的文件并删除它们，在删除之前进行交互提示确认
    ```

- GLOBAL OPTIONS：全局参数，会影响全部的 test 和 action

  - -d,-depth 深度优先进行操作，例如使用 -delte 的时候，会先删除文件夹中的内容再删除文件夹。
  - -help,–help 这个不用解释了
  - -ignore_readdir_race　通常如果在 find 的过程中，find 的内容发生了变化。这个参数的作用是忽略它
  - -noignore_readdir_race。不忽略上面这种情况
  - -maxdept　搜索深度上限
  - -mindepth 搜索深度下限，例如 -mindepth 2 会忽略两层以内的所有文件，即使他们可能满足你的测试。
  - -mount 只会在当前的文件系统中搜索，不会搜索其他挂载的文件系统
  - -noleaf 如果在非 Unix 规范的文件系统中搜索，需要加上这个选项。

tldr:
```
  find

  Find files under the given directory tree, recursively.

  - Find files by extension:
    find root_path -name '*.ext'

  - Find files matching path pattern:
    find root_path -path '**/lib/**/*.ext'

  - Run a command for each file, use {} within the command to access the filename:
    find root_path -name '*.ext' -exec wc -l {} \;

  - Find files modified in the last 24-hour period:
    find root_path -mtime -1

  - Find files using case insensitive name matching, of a certain size:
    find root_path -size +500k -size -10MB -iname '*.TaR.gZ'

  - Delete files by name, older than 180 days:
    find root_path -name '*.ext' -mtime +180 -delete

  - Find files matching more than one search criteria:
    find root_path -name '*.py' -or -name '*.r'

  - Find files matching a given pattern, while excluding specific paths:
    find root_path -name '*.py' -not -path '*/site-packages/*'
```

### 16.2. 命令（二进制文件）搜索

#### 16.2.1. whereis

#### 16.2.2. which

## 17. 字符串搜索：grep

grep 命令用于查找文件里符合条件的字符串，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。

NOTE
- **若 pattern 包含空格或使用了正则表达式，则必须使用单引号包围**，否则可不使用引号。
- 若不指定任何文件名称，或是所给予的文件名为"-"，则 grep 指令会从标准输入设备读取数据。
- grep **默认使用模糊匹配**。

Usage:
```
grep <pattern> file1 [file2 [file3]]
```

Options:
- -a 把二进制文件当作文本来处理
  - eg: 找回被删除的文件 `grep -a -B 50 -A 60 'string' /dev/sda1 > new.txt`
- `-A 行数` 或 `--after-context= 行数`: 除了显示符合范本样式的那一列之外，并显示该行之后的内容。
- -b 或 --byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。
- `-B 行数` 或 `--before-context= 行数`: 除了显示符合样式的那一行之外，并显示该行之前的内容。
- -c 或 --count : 计算符合样式的列数。
- `-C 行数` 或 `--context= 行数`: 除了显示符合样式的那一行之外，并显示该行前后的内容。
- `-d 动作` 或 `--directories= 动作`: 当指定要查找的是目录而非文件时，必须使用这项参数，否则 grep 指令将回报信息并停止动作。
- `-E` 或 `--extended-regexp`: 使用扩展的 POSIX 正则表达式（ERE）。
- -i 或 --ignore-case : 忽略字符大小写的差别。
- -n 或 --line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。
- -r 或 --recursive : 此参数的效果和指定"-d recurse"参数相同。
- -v 或 --revert-match : 显示不包含匹配文本的所有行。
- -w 或 --word-regexp : 只显示全字符合的列。
- -x : 只显示全列符合的列。

tldr:
```
  grep

  Matches patterns in input text.
  Supports simple patterns and regular expressions.

  - Search for an exact string:
    grep search_string path/to/file

  - Search in case-insensitive mode:
    grep -i search_string path/to/file

  - Search recursively (ignoring non-text files) in current directory for an exact string:
    grep -RI search_string .

  - Use extended regular expressions (supporting ?, +, {}, () and |):
    grep -E ^regex$ path/to/file

  - Print 3 lines of [C]ontext around, [B]efore, or [A]fter each match:
    grep -C|B|A 3 search_string path/to/file

  - Print file name with the corresponding line number for each match:
    grep -Hn search_string path/to/file

  - Use the standard input instead of a file:
    cat path/to/file | grep search_string

  - Invert match for excluding specific strings:
    grep -v search_string
```

## 18. 权限控制

### 18.1. 基础概念

Linux/Unix 系统中对文件的权限有着严格的控制，如果想对某个文件执行某种操作，必须具有对应的权限才能执行成功。

#### 18.1.1. 权限类型

##### 18.1.1.1. 基本权限类型

文件的基本权限类型一般包括：
- 读权限，用 `r`(read) 表示
- 写权限，用 `w`(write) 表示
- 执行权限，用 `x`(execute) 表示
- 无权限，用 `-` 表示

NOTE:

Linux/unix 下文件的权限只控制对文件**内容**的访问 / 修改 / 执行，对**文件**本身的控制是由父目录的权限决定的。

- 对于普通用户：
  - 显示目录（如 ls）需要对目录拥有读权限 (r)。
  - 进入目录（如 cd）需要对目录拥有执行权限 (x)。
  - 创建文件（如 touch、mkdir）和删除文件（如 rm）需要对父目录拥有执行权限 (x) （需要先进入目录才能操作）和写权限 (w)，不需要对文件有任何权限。
  - 读取文件（如 cat）需要对父目录拥有执行权限 (x)（需要先进入目录才能操作），对文件拥有读权限 (r)。
  - 修改文件（如 vim）需要对父目录拥有执行权限 (x)（需要先进入目录才能操作），对文件拥有读权限 (r) 和写权限 (w)。
  - 执行文件需要对父目录拥有执行权限 (x)（需要先进入目录才能操作），对文件拥有执行权限 (x)。

  例：在用户目录下（$HOME）有一个文件 file（$HOME/file），该 file 的 owner 为 root，即权限为 -rw-r--r--;$USER 虽然没有 file 的 write 权限，但是仍可以删除该 file 文件。因为 $USER 拥有 $HOME 目录的 write 和 execute 权限。

- 对于超级用户 (root)：无论权限如何，都可以进入目录，进行读写和执行操作。

##### 18.1.1.2. 附加权限类型

除了正常的读写操作权限之外，Linux 文件系统还包含了附加权限类型：
- SET 位权限 (SET UID & SET GID)

  SUID/SGID 是为了使没有取得特权的用户要完成一项必须要有特权才可以执行的任务而产生的，一般用于给可执行的程序或脚本文件，其中 SUID 表示对属主用户增加 SET 位权限，SGID 表示对属组内用户增加 SET 位权限。**可执行文件被设置了 SUID、SGID 权限后，任何用户执行该文件时，将获得该文件属主、属组账号对应的身份**。在许多环境中，SUID 和 SGID 很管用，但是不恰当地使用这些位可能使系统的安全遭到破坏。所以应该尽量避免使用 SET 位权限程序。

  **如果一个文件被设置了 SUID 或 SGID 位，会分别表现在所有者或同组用户的权限的可执行位上**。如果文件设置了 SUID 还设置了 x（执行）位，则相应的执行位表示为 s（小写)。如果没有设置 x 位，则相应的位将表示为 S（大写)：
  ```
  -rwsr-xr-x 表示 SUID 被设置，且拥有者有可执行权限
  -rwSr--r-- 表示 SUID 被设置，但拥有者没有可执行权限
  -rwxr-sr-x 表示 SGID 被设置，且群组用户有可执行权限
  -rw-r-Sr-- 表示 SGID 被设置，但群组用户没有可执行权限
  ```

- 粘滞位权限 (Sticky)

  粘滞位权限一般用于为目录设置特殊的附加权限，**当目录被设置了粘滞位权限后，即便用户对该目录有写的权限，也不能删除该目录中其他用户的文件数据**。

  **如果一个文件或目录被设置了粘滞位权限，会表现在其他组用户的权限的可执行位上**。如果文件设置了 sticky 还设置了 x（执行）位，其他组用户的权限的可执行位为 t（小写）。但是，如果没有设置 x 位，它将表示为 T（大写）：
  ```
  -rwsr-xr-t 表示设置了粘滞位且其他用户组有可执行权限
  -rwSr--r-T 表示设置了粘滞位但其他用户组没有可执行权限
  ```

#### 18.1.2. 权限粒度

权限粒度一般分为三级：`owner`、`group`、`others`，每个文件都可以针对三个粒度，设置不同的 rwx 权限。通常情况下，一个文件只能归属于一个用户和组， 如果其它的用户想有这个文件的权限，则可以将该用户加入具备权限的群组，一个用户可以同时归属于多个组。

eg: `-rwxr--r--` 表示 `-（文件类型）×××（所有者权限）×××（组用户权限）×××（其他用户权限）`

#### 18.1.3. 权限表示

一个文件的所有权限详情，一般有 2 种表示方式：
- **10 位二进制表示法**：三个属组每个都使用 3 个二进制位表示，再加一个最高位共十位，可简化为 3 位八进制形式。

  如果我们将各个位置权限的有无用二进制数 1 和 0 来代替，则只读、只写、只执行权限，可以用 3 位二进制数来表示，且可以转换为八进制数如下：
  ```
  r-- = 100(2) = 4(8)
  -w- = 010(2) = 2(8)
  --x = 001(2) = 1(8)
  --- = 000(2) = 0(8)
  ```
  也就是说，r、w、x 权限可以分别用数字表示如下：
  - r(read) 权限为 4
  - w(write) 权限为 2
  - x(execute) 权限为 1
  我们可以进一步将所有的权限用二进制形式表现出来，并进一步转变成八进制数字：
  ```
  rwx = 111 = 7
  rw- = 110 = 6
  r-x = 101 = 5
  r-- = 100 = 4
  -wx = 011 = 3
  -w- = 010 = 2
  --x = 001 = 1
  --- = 000 = 0
  ```

  如果我们将每个属组的权限都用八进制数表示，则文件的权限可以表示为 3 位八进制数：
  ```
  -rw------- (600)      只有拥有者有读写权限。
  -rw-r--r-- (644)      只有拥有者有读写权限；而属组用户和其他用户只有读权限。
  -rwx------ (700)      只有拥有者有读、写、执行权限。
  -rwxr-xr-x (755)      拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。
  -rwx--x--x (711)      拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。
  -rw-rw-rw- (666)      所有用户都有文件读、写权限。
  -rwxrwxrwx (777)      所有用户都有读、写、执行权限。
  ```

  对于最高位，它代表的是文件的类型，类型可以是下面几个中的一个：
  - `d` 代表的是目录 (directroy)。
  - `-` 代表的是文件 (regular file)。
  - `s` 代表的是套接字文件 (socket)。
  - `p` 代表的管道文件 (pipe) 或命名管道文件 (named pipe)。
  - `l` 代表的是符号链接文件 (symbolic link)。
  - `b` 代表的是该文件是面向块的设备文件 (block-oriented device file)。
  - `c` 代表的是该文件是面向字符的设备文件 (charcter-oriented device file)。

- **12 位二进制表示法**：可简化为 4 位八进制形式。

  12 位二进制的权限表示法在 10 位二进制表示法的基础上，高 3 位分别表示 SUID、SGID、Sticky 权限的有无，即第 11 位为 SUID 位，第 10 位为 SGID 位，第 9 位为 sticky 位，第 8-0 位对应于上面的三组 rwx 位（后九位）。
  ```
  -rw-r-sr-- 的值为： 0 1 0  1 1 0  1 0 0  1 0 0
  -rwsr-xr-x 的值为： 1 0 0  1 1 1  1 0 1  1 0 1
  -rwsr-sr-x 的值为： 1 1 0  1 1 1  1 0 1  1 0 1
  -rwsr-sr-t 的值为： 1 1 1  1 1 1  1 0 1  1 0 1
  ```
  将前三位 `SGT` 也转换成一个八进制数，则：
  - SUID 权限为 4
  - SGID 权限为 2
  - Sticky 权限为 1

  因此，文件的权限可以表示为 4 位八进制数
  ```
  -rw-r-sr-- = 0 1 0 1 1 0 1 0 0 1 0 0 = 2644
  -rwsr-xr-x = 1 0 0 1 1 1 1 0 1 1 0 1 = 4755
  -rwsr-sr-x = 1 1 0 1 1 1 1 0 1 1 0 1 = 6755
  -rwsr-sr-t = 1 1 1 1 1 1 1 0 1 1 0 1 = 7755
  ```

### 18.2. chmod

通过`chmod`命令可以对文件调用权限进行设置和更改。

Usage:
```
chmod [OPTION]... MODE[,MODE]... FILE...
  or:  chmod [OPTION]... OCTAL-MODE FILE...
  or:  chmod [OPTION]... --reference=RFILE FILE...
```

Options:
- `-c`: 若该文件权限确实已经更改，才显示其更改动作。
- `-f`: 若该文件权限无法被更改也不要显示错误讯息。
- `-v`: 显示权限变更的详细资料。
- `-R`: 对目前目录下的所有文件与子目录进行相同的权限变更（以递归方式逐个变更）。

MODE:
- 方式一：字母设置
  ```
  (ugoa...)(+-=)(rwxX)
  ```
  即：
  ```
  操作对象 + 权限增减 + 操作权限
  ```
  其中：
  - `u` 表示该文件的拥有者，`g` 表示与该文件的拥有者属于同一个群体 (group) 者，`o` 表示其他以外的人，`a` 表示这三者皆是。
  - `+` 表示增加权限、`-` 表示取消权限、`=` 表示唯一设定权限。
  - `r` 表示可读取，`w` 表示可写入，`x` 表示可执行，`X` 表示只有当该文件是个子目录或者该文件已经被设定过为可执行，`s` 表示 SET 位权限，`t` 表示粘滞位权限。
  eg:
  ```bash
  # 将文件 file1.txt 设为所有人可读
  chmod a+r file1.txt
  # 将文件 file1.txt 与 file2.txt 设为该文件拥有者、与其所属同一个群体者可写入，但其他以外的人则不可写入
  chmod ug+w,o-w file1.txt file2.txt
  # 将 ex1.py 设定为只有该文件拥有者可以执行
  chmod u+x ex1.py
  # 为 ex2.py 设置 SUID SET 位权限
  chmod u+s ex2.py
  ```

- 方式二：数字设置
  ```
  abc
  ```
  其中：a、b、c 各为一个数字，分别表示 user、group、other 的权限。
  因此：
  - 若要 `rwx` 属性则设置 4+2+1=7.
  - 若要 `rw-` 属性则设置 4+2=6.
  - 若要 `r-x` 属性则设置 4+1=5.
  eg:
  ```bash
  # chmod a=rwx file 相当于
  chmod 777 file
  # chmod ug=rwx,o=x file 相当于
  chmod 771 file
  # chmod u=rws,g=rx,o=rx file 相当于
  chmod 4755 file
  ```

tldr:
```
chmod

  Change the access permissions of a file or directory.

  - Give the [u]ser who owns a file the right to e[x]ecute it:
    chmod u+x file

  - Give the user rights to [r]ead and [w]rite to a file/directory:
    chmod u+rw file

  - Remove executable rights from the [g]roup:
    chmod g-x file

  - Give [a]ll users rights to read and execute:
    chmod a+rx file

  - Give [o]thers (not in the file owner's group) the same rights as the group:
    chmod o=g file

  - Change permissions recursively giving [g]roup and [o]thers the abililty to [w]rite:
    chmod -R g+w,o+w directory
```

## 19. Refer Links

[Runoob Linux grep 命令](http://www.runoob.com/linux/linux-comm-grep.html)

[Runoob Linux find 命令](http://www.runoob.com/linux/linux-comm-find.html)

[Runoob Linux chmod 命令](http://www.runoob.com/linux/linux-comm-chmod.html)

[Linux 权限详解（chmod、600、644、666、700、711、755、777、4755、6755、7755）](https://blog.csdn.net/u013197629/article/details/73608613)

[在 Linux 下进入目录，目录下创建、修改、删除文件所需权限](https://blog.csdn.net/Korey_sparks/article/details/52389941)

[linux 中 find 命令的详细用法](https://xionchen.github.io/2016/08/19/linux-find/)

[xargs 命令详解，xargs 与管道的区别](https://www.cnblogs.com/wangqiguo/p/6464234.html)

[阮一峰：xargs 命令教程](https://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html)
