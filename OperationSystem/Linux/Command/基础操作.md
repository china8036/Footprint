- [Base Operation](#base-operation)
  - [1. echo](#1-echo)
  - [2. cp](#2-cp)
  - [3. ls](#3-ls)
  - [4. ln](#4-ln)
  - [5. tar](#5-tar)
  - [6. cat](#6-cat)
  - [7. nl](#7-nl)
  - [8. tree](#8-tree)
  - [9. diff](#9-diff)
  - [10. xargs](#10-xargs)
    - [10.1. 背景：`xargs` 与 `|` 的区别](#101-背景xargs-与--的区别)
    - [10.2. 使用方法](#102-使用方法)
  - [11. strings](#11-strings)
  - [12. file](#12-file)
  - [13. size](#13-size)
  - [14. nm](#14-nm)
  - [15. objdump](#15-objdump)
  - [16. chmod](#16-chmod)
  - [17. history](#17-history)
  - [18. Refer Links](#18-refer-links)

# Base Operation

## 1. echo

Options
- `-n` 关闭自动插入换行符（默认开启）。
- `-e` 开启对转义字符进行识别替换（默认关闭）

  eg: 通过 echo 改变 shell 输出颜色：
  ```
  echo -e "\e[1;color_code text \e[1;color_code"
  ```
  其中，`\e[1;color_code` 表示改变终端颜色。如：`echo -e "\e[1;31m hahahaha \e[0m"` 可输出红色的字符 'hahahaha'。

tldr:
```bash
  echo

  Print given arguments.

  - Print a text message. Note: quotes are optional:
    echo "Hello World"

  - Print a message with environment variables:
    echo "My path is $PATH"

  - Print a message without the trailing newline:
    echo -n "Hello World"

  - Enable interpretation of backslash escapes (special characters):
    echo -e "Column 1\tColumn 2"
```

## 2. cp

tldr:
```bash
  Copy files and folders.

  - Copy a file to another location:
    cp path/to/file.ext path/to/copy.ext

  - Copy a file into another folder, keeping the filename:
    cp path/to/file.ext path/to/target/parent/folder

  - Copy a folder recursively to another location:
    cp -r path/to/folder path/to/copy

  - Copy the contents of a folder into another folder:
    cp -r path/to/source/folder/* path/to/target/folder

  - Copy text files to another location, in interactive mode (prompts user before overwriting):
    cp -i *.txt path/to/source/
```

## 3. ls

```
ls [Options] [Directory]
```
- -a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件
- -A 同 -a，但不列出“.”（表示当前目录) 和“..”（表示当前目录的父目录)。
- -c  配合 -lt：根据 ctime 排序及显示 ctime （文件状态最后更改的时间) 配合 -l：显示 ctime 但根据名称排序否则根据 ctime 排序
- -C 每栏由上至下列出项目
- –color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是'never'、'always'或'auto'其中之一
- -d, –directory 将目录像文件一样显示，而不是显示其下的文件。
- -D, –dired 产生适合 Emacs 的 dired 模式使用的结果
- -f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效
- -g 类似 -l, 但不列出所有者
- -G, –no-group 不列出任何有关组的信息
- -h, –human-readable 以容易理解的格式列出文件大小（例如 1K 234M 2G)
- –si 类似 -h, 但文件大小取 1000 的次方而不是 1024
- -H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地
- –indicator-style= 方式 指定在每个项目名称后加上指示符号《方式》：none （默认)，classify (-F)，file-type (-p)
- -i, –inode 印出每个文件的 inode 号
- -I, –ignore=pattern 排除 pattern 匹配的文件
- -k 即 –block-size=1K, 以 k 字节的形式表示文件的大小。
- -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。
- -L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息
- -m 所有项目以逗号分隔，并填满整行行宽
- -o 类似 -l, 显示文件的除组信息外的详细信息。
- -r, –reverse 依相反次序排列
- -R, –recursive 同时列出所有子目录层
- -s, –size 以块大小为单位列出所有文件的大小
- -S 根据文件大小排序
- –sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：
  - extension -X status -c
  - none -U time -t
  - size -S atime -u
  - time -t access -u
  - version -v use -u
- -t 以文件修改时间排序
- -U 不进行排序；依文件系统原有的次序列出项目
- -v 根据版本进行排序
- -w, –width=COLS 自行指定屏幕宽度而不使用目前的数值
- -x 逐行列出项目而不是逐栏列出
- -X 根据扩展名排序
- -1 每行只列出一个文件
- –help 显示此帮助信息并离开
- –version 显示版本信息并离开

NOTE:
- 查看 Linux 文件的 atime/mtime/ctime：
  - `ls -ul` 看到的时间即为 atime。
  - `ls -l` 看到的时间即为 mtime。
  - `ls -t` 看到的时间即为 ctime。

e.g.
```
ls -Alht // sorted by time
ls -AlhS // sorted by size
ls -I file_name // ignore file_name

ls | sed "s:^:`pwd`/:" // 在 ls 中列出文件的绝对路径
```

tldr:
```
  ls

  List directory contents.

  - List files one per line:
    ls -1

  - List all files, including hidden files:
    ls -a

  - Long format list (permissions, ownership, size and modification date) of all files:
    ls -la

  - Long format list with size displayed using human readable units (KB, MB, GB):
    ls -lh

  - Long format list sorted by size (descending):
    ls -lS

  - Long format list of all files, sorted by modification date (oldest first):
    ls -ltr
```

## 4. ln

## 5. tar

Options:
- --delete : 从归档文件 （而非磁带) 中删除
- -r, --append : 将文件追加到归档文件中
- -t, --list : 列出归档文件中包含的内容
- --test-label : 测试归档文件卷标并退出
- -u, --update : 将已更新的文件追加到归档文件中
- -x, --extract, --get : 释放归档文件中文件及目录
- -C, --directory=DIR : 执行归档动作前变更工作目录到 DIR
- -f, --file=ARCHIVE : 指定 （将要创建或已存在的) 归档文件名
- -j, --bip2 : 对归档文件使用 bzip2 压缩
- -J, --xz : 对归档文件使用 xz 压缩
- -p, --preserve-permissions : 保留原文件的访问权限
- -v, --verbose : 显示命令整个执行过程
- -z, gzip : 对归档文件使用 gzip 压缩 / 解压缩

NOTE: 在 tar 命令选项中的连接符 `-` 是可选的（tar 命令更多受到古老的 UNIX 风格影响）。

tldr:
```
  tar
  Archiving utility.
  Often combined with a compression method, such as gzip or bzip.

  - Create an archive from files:
    tar cf target.tar file1 file2 file3

  - Create a gzipped archive:
    tar czf target.tar.gz file1 file2 file3

  - Extract an archive in a target folder:
    tar xf source.tar -C folder

  - Extract a gzipped archive in the current directory:
    tar xzf source.tar.gz

  - Extract a bzipped archive in the current directory:
    tar xjf source.tar.bz2

  - Create a compressed archive, using archive suffix to determine the compression program:
    tar caf target.tar.xz file1 file2 file3

  - List the contents of a tar file:
    tar tvf source.tar

  - Extract files matching a pattern:
    tar xf source.tar --wildcards "*.html"
```

## 6. cat

## 7. nl

nl(number lines of files) is used to write each FILE to standard output, with line numbers added.

## 8. tree

usage:
```bash
tree [-adfghilnpqrstuvxACDFNS] [-H baseHREF] [-T title ] [-L level [-R]]
    [-P pattern] [-I pattern] [-o filename] [--version] [--help] [--inodes]
    [--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset]
    [--filelimit #] [<directory list>]
```
- `-a`: 显示所有文件和目录。
- `-A`: 使用 ASNI 绘图字符显示树状图而非以 ASCII 字符组合。
- `-C`: 在文件和目录清单加上色彩，便于区分各种类型。
- `-d`: 显示目录名称而非内容。
- `-D`: 列出文件或目录的更改时间。
- `-f`: 在每个文件或目录之前，显示完整的相对路径名称。
- `-F`: 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上"*","/","=","@","|"号。
- `-g`: 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。
- `-i`: 不以阶梯状列出文件或目录名称。
- `-I`: 不显示符合范本样式的文件或目录名称。
- `-l`: 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。
- `-n`: 不在文件和目录清单加上色彩。
- `-N`: 直接列出文件和目录名称，包括控制字符。
- `-p`: 列出权限标示。
- `-P`: 只显示符合范本样式的文件或目录名称。
- `-q`: 用"?"号取代控制字符，列出文件和目录名称。
- `-s`: 列出文件或目录大小。
- `-t`: 用文件和目录的更改时间排序。
- `-u`: 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。
- `-x`: 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。

tldr:
```
tree -DFpsf
```

## 9. diff

diff 命令用来比较两个文本文件的差异，是代码版本管理的基石之一。

```
diff 《变动前的文件》 《变动后的文件》
```

todo: [阮一峰：读懂 diff](http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html)

- 正常模式

- 上下文模式 `-c`

- 合并模式 `-u`

## 10. xargs

### 10.1. 背景：`xargs` 与 `|` 的区别

对于 UNIX 命令，一般可以通过 2 种方式来获取用户输入：
- 命令行参数：反映在程序上，命令行参数一般通过 main 函数 `int main(int argc,char*argv[])` 的函数参数获得。
- 标准输入 (stdin)：反映在程序上，标准输入一般通过标准输入函数（例如 C 语言中的 scanf）读取到。

对于一部分 UNIX 命令，其设计是既可以从命令行参数中获取参数，也支持从标准输入中读取。例如，cat、grep 等文字处理命令：
```bash
echo 'main' | cat  # 这条命令中 cat 会从其标准输入中读取内容并处理，也就是会输出 'main' 字符串
echo 'main' | cat -  # 如果直接在命令的最后指定 -  则表示从标准输入中读取
echo 'main' | cat test.cpp -  # 同时指定 test.cpp 和 - 参数，此时 cat 程序会先输出 test.cpp 的内容，然后输出标准输入'main'字符串
echo 'main' | cat - test.cpp  # 如果换一下顺序，则会先输出标准输入'main'字符串，然后输出 test.cpp 文件的内容
echo 'main' | cat test.cpp  # 如果去掉 -，则 cat 只从标准输入读取内容，即输出 test.cpp 的内容，而不是'main'字符串，如果 test.cpp 不存在则 cat 命令报告该文件不存在
echo 'main' | grep 'main' test.cpp -  # grep 同理，如果同时传递标准输入和文件名，grep 也会同时处理这两个输入，也就是说会在标准输入中搜索 'main' 也会在文件 test.cpp （该文件名从 grep 命令行参数中获得) 中搜索 'main'
```
但实际上，也有很多命令**只接受命令行参数，而不读取 stdin 的内容**，这取决于命令程序的内部实现。例如，kill、rm、ls 等命令：
```bash
# 以下 2 个命令都没有任何效果
echo '516' | kill
echo 'test' | rm -f
# 以下 ls 命令列出当前目录下的所有文件
echo "test.sh" | ls
```
因此，针对这部分命令，如果需要使用上一个命令的执行结果作为参数输入，可以有以下解决方案：
- 通过 kill \`ps -ef | grep 'ddd'\`，实际上等同于拼接字符串得到的命令，其效果类似于  `kill $pid`。
- `for procid in $(ps -aux | grep "some search" | awk '{print $2}'); do kill -9 $procid; done`，其实与第一种原理一样，只不过需要多次 kill 的时候是循环处理的，每次处理一个。
- 使用 `xargs` 命令来实现：`ps -ef | grep 'ddd' | xargs kill`

### 10.2. 使用方法

`xargs` 命令可以通过管道接受字符串，并将接收到的字符串通过空格分割成许多参数（默认情况下是通过空格分割），然后将参数传递给其后面的命令，**也就是将标准输入的内容转化为命令行参数，提供给后边的命令**。

参数：
- -d

  指定分隔符
  ```
  echo '11@22@33' | xargs echo
  ```
  输出：11@22@33

  默认情况下以空白分割，那么 11@22@33 这个字符串中没有空白，所以实际上等价于 echo 11@22@33 其中字符串 '11@22@33' 被当作 echo 命令的一个命令行参数
  ```
  echo '11@22@33' | xargs -d '@' echo
  ```
  输出：11 22 33

  指定以 @符号分割参数，所以等价于 echo 11 22 33 相当于给 echo 传递了 3 个参数，分别是 11、22、33

- -0

  使用 null 作为分隔符。

- -p

  使用该选项之后 xargs 并不会马上执行其后面的命令，而是输出即将要执行的完整的命令（包括命令以及传递给命令的命令行参数)，询问是否执行，输入 y 才继续执行，否则不执行。

- -t

  打印出最终要执行的命令，然后直接执行，不需要用户确认。

- -n

  该选项表示将 xargs 生成的命令行参数，每次传递几个参数给其后面的命令执行，例如如果 xargs 从标准输入中读入内容，然后以分隔符分割之后生成的命令行参数有 10 个，使用 -n 3 之后表示一次传递给 xargs 后面的命令是 3 个参数，因为一共有 10 个参数，所以要执行 4 次，才能将参数用完。
  ```bash
  ╭─firejq@firejqwei-PC0 ~
  ╰─$ echo '11@22@33@44@55@66@77@88@99@00' | xargs -d '@' -n 3 echo
  11 22 33
  44 55 66
  77 88 99
  00
  ```

- -E

  该选项指定一个字符串，当 xargs 解析出多个命令行参数的时候，如果搜索到 -E 指定的命令行参数，则只会将 -E 指定的命令行参数之前的参数（不包括 -e 指定的这个参数）传递给 xargs 后面的命令。
  ```
  echo '11 22 33 44 55' | xargs -E '33' echo
  ```
  输出：11 22

- -L

  如果标准输入包含多行，-L 参数指定多少行作为一个命令行参数。

- -I

  如果 xargs 要将命令行参数传给多个命令，可以使用 -I 参数，-I 指定每一项命令行参数的替代字符串。
  ```
  $ cat foo.txt
  one
  two
  three

  $ cat foo.txt | xargs -I file sh -c 'echo file; mkdir file'
  one
  two
  three

  $ ls
  one two three
  ```

- -i
  <!-- TODO: -->
  ```
  printf "1\n2\n3\n" | xargs -i touch {}.txt
  ```

NOTE:
- xargs 后面的命令默认是 echo，`xargs` 等同于 `xargs echo`。
- 大多数时候，xargs 命令都是跟管道一起使用的，但事实上它也可以单独使用：
  ```bash
  $ xargs find -name
  "*.txt"
  ./foo.txt
  ./hello.txt
  ```
  上面的例子输入 `xargs find -name` 以后，命令行会等待用户输入所要搜索的文件。用户输入"*.txt"，表示搜索当前目录下的所有 TXT 文件，然后按下 Ctrl d，表示输入结束。这时就相当执行 `find -name *.txt`。

tl.dr:
```
echo '--help' | xargs cat
```

e.g. 与 find 搭配使用：
```
find . -type f -print | xargs file  # 查找系统中的每一个普通文件，然后使用 xargs 命令来测试它们分别属于哪类文件
find / -name "core" -print | xargs echo "" >/tmp/core.log  # 在整个系统中查找内存信息转储文件 (core dump) ，然后把结果保存到 /tmp/core.log 文件中
find . -perm -7 -print | xargs chmod o-w  # 在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限
find . -type f -print | xargs grep "hostname"  # 用 grep 命令在所有的普通文件中搜索 hostname 这个词
find . -type f -atime +0 -print0 | xargs -0 -l1 -t rm -f  # find 后执行 xargs 提示 xargs: argument line too long 解决方法
find . -name "*.log" | xargs -i mv {} test4  # 使用 xargs 执行 mv
```

## 11. strings

strings 命令用于打印文件中的所有可打印字符，该文件可以是文本文件、二进制文件等类型。

tldr.
```
  strings

  Find printable strings in an object file or binary.

  - Print all strings in a binary:
    strings file

  - Limit results to strings at least length characters long:
    strings -n length file

  - Prefix each result with its offset within the file:
    strings -t d file

  - Prefix each result with its offset within the file in hexadecimal:
    strings -t x file
```

strings 命令有很多实际用途，e.g.

在大型的软件开发中，假设有 100 个 `.c/.cpp` 文件， 这些 `.cpp` 文件最终生成 10 个 `.so` 库， 那么怎样才能快速知道某个 `.c/.cpp` 文件编译到那个 `.so` 库中去了呢？
```
$ strings -f "*.so" | grep "my dear"

  a.out: oh, my dear, c is %d
  test.c: 	printf("oh, my dear, c is %d\n", c);
```
可以看到，源文件 `test.c` 和可执行文件中皆有"my dear"串，一下子就找到了对应的文件。

## 12. file

## 13. size

## 14. nm

## 15. objdump

## 16. chmod

通过`chmod`命令可以对文件调用权限进行设置和更改。

Usage:
```
chmod [OPTION]... MODE[,MODE]... FILE...
  or:  chmod [OPTION]... OCTAL-MODE FILE...
  or:  chmod [OPTION]... --reference=RFILE FILE...
```

Options:
- `-c`: 若该文件权限确实已经更改，才显示其更改动作。
- `-f`: 若该文件权限无法被更改也不要显示错误讯息。
- `-v`: 显示权限变更的详细资料。
- `-R`: 对目前目录下的所有文件与子目录进行相同的权限变更（以递归方式逐个变更）。

MODE:
- 方式一：字母设置
  ```
  (ugoa...)(+-=)(rwxX)
  ```
  即：
  ```
  操作对象 + 权限增减 + 操作权限
  ```
  其中：
  - `u` 表示该文件的拥有者，`g` 表示与该文件的拥有者属于同一个群体 (group) 者，`o` 表示其他以外的人，`a` 表示这三者皆是。
  - `+` 表示增加权限、`-` 表示取消权限、`=` 表示唯一设定权限。
  - `r` 表示可读取，`w` 表示可写入，`x` 表示可执行，`X` 表示只有当该文件是个子目录或者该文件已经被设定过为可执行，`s` 表示 SET 位权限，`t` 表示粘滞位权限。
  eg:
  ```bash
  # 将文件 file1.txt 设为所有人可读
  chmod a+r file1.txt
  # 将文件 file1.txt 与 file2.txt 设为该文件拥有者、与其所属同一个群体者可写入，但其他以外的人则不可写入
  chmod ug+w,o-w file1.txt file2.txt
  # 将 ex1.py 设定为只有该文件拥有者可以执行
  chmod u+x ex1.py
  # 为 ex2.py 设置 SUID SET 位权限
  chmod u+s ex2.py
  ```

- 方式二：数字设置
  ```
  abc
  ```
  其中：a、b、c 各为一个数字，分别表示 user、group、other 的权限。
  因此：
  - 若要 `rwx` 属性则设置 4+2+1=7.
  - 若要 `rw-` 属性则设置 4+2=6.
  - 若要 `r-x` 属性则设置 4+1=5.
  eg:
  ```bash
  # chmod a=rwx file 相当于
  chmod 777 file
  # chmod ug=rwx,o=x file 相当于
  chmod 771 file
  # chmod u=rws,g=rx,o=rx file 相当于
  chmod 4755 file
  ```

tldr:
```
chmod

  Change the access permissions of a file or directory.

  - Give the [u]ser who owns a file the right to e[x]ecute it:
    chmod u+x file

  - Give the user rights to [r]ead and [w]rite to a file/directory:
    chmod u+rw file

  - Remove executable rights from the [g]roup:
    chmod g-x file

  - Give [a]ll users rights to read and execute:
    chmod a+rx file

  - Give [o]thers (not in the file owner's group) the same rights as the group:
    chmod o=g file

  - Change permissions recursively giving [g]roup and [o]thers the abililty to [w]rite:
    chmod -R g+w,o+w directory
```

## 17. history

在管理服务器中为了提高 history 命令的效率，可以通过配置环境变量，使 history 记录加上一些参数：
```bash
# 加上时间和用户
export HISTTIMEFORMAT="%F %T `whoami` "
# 加上时间、用户和用户 IP
export HISTTIMEFORMAT="%F %T `whoami` `who -u am i 2>/dev/null| awk '{print $NF}'|sed -e 's/[()]//g'` "
```
可将以上环境变量的配置加到 `~/.bashrc` 文件中，每次启动 shell 都可以自动加载。

tl.dr.
```
  history

  Command Line history.

  - Display the commands history list with line numbers:
    history

  - Clear the commands history list (only for current bash shell):
    history -c

  - Overwrite history file with history of current bash shell (often combined with history -c to purge history):
    history -w

  - Delete the history entry at the specified offset:
    history -d offset
```

## 18. Refer Links

[Runoob Linux grep 命令](http://www.runoob.com/linux/linux-comm-grep.html)

[Runoob Linux find 命令](http://www.runoob.com/linux/linux-comm-find.html)

[Runoob Linux chmod 命令](http://www.runoob.com/linux/linux-comm-chmod.html)

[Linux 权限详解（chmod、600、644、666、700、711、755、777、4755、6755、7755）](https://blog.csdn.net/u013197629/article/details/73608613)

[在 Linux 下进入目录，目录下创建、修改、删除文件所需权限](https://blog.csdn.net/Korey_sparks/article/details/52389941)

[linux 中 find 命令的详细用法](https://xionchen.github.io/2016/08/19/linux-find/)

[xargs 命令详解，xargs 与管道的区别](https://www.cnblogs.com/wangqiguo/p/6464234.html)

[阮一峰：xargs 命令教程](https://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html)
