- [Linux 内存管理](#linux-内存管理)
	- [1. 基本概念](#1-基本概念)
		- [1.1. 虚拟内存 (Virtual Memory)](#11-虚拟内存-virtual-memory)
		- [1.2. 驻留内存 (Resident Memory)](#12-驻留内存-resident-memory)
		- [1.3. 共享内存 (Shared Memory)](#13-共享内存-shared-memory)
	- [2. 内存模型](#2-内存模型)
		- [2.1. Code 段](#21-code-段)
		- [2.2. Data 段](#22-data-段)
		- [2.3. BBS 段](#23-bbs-段)
		- [2.4. 栈内存](#24-栈内存)
		- [2.5. 堆内存](#25-堆内存)
	- [3. Refer Links](#3-refer-links)

# Linux 内存管理

https://blog.csdn.net/column/details/linux--mm.html

https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt

http://blog.codinglabs.org/articles/a-malloc-tutorial.html#21-linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86

TODO:

https://github.com/shigh1005/pdf_book/blob/master/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--Linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B8%89%E7%BA%A7%E6%9E%B6%E6%9E%84.pdf

## 1. 基本概念

https://blog.csdn.net/u012398613/article/details/52903296

### 1.1. 虚拟内存 (Virtual Memory)

虚拟内存是操作系统内核为了对进程地址空间进行管理（process address space management）而精心设计的一个逻辑意义上的内存空间概念。我们程序中的指针其实都是这个虚拟内存空间中的地址。

比如我们在写完一段 C++ 程序之后都需要采用 g++ 进行编译，这时候编译器采用的地址其实就是虚拟内存空间的地址。因为这时候程序还没有运行，何谈物理内存空间地址？凡是程序运行过程中可能需要用到的指令或者数据都必须在虚拟内存空间中。既然说虚拟内存是一个逻辑意义上（假象的）的内存空间，为了能够让程序在物理机器上运行，那么必须有一套机制可以让这些假象的虚拟内存空间映射到物理内存空间（实实在在的 RAM 内存条上的空间）。这其实就是操作系统中页映射表（page table）所做的事情了。内核会为系统中每一个进程维护一份相互独立的页映射表。页映射表的基本原理是将程序运行过程中需要访问的一段虚拟内存空间通过页映射表映射到一段物理内存空间上，这样 CPU 访问对应虚拟内存地址的时候就可以通过这种查找页映射表的机制访问物理内存上的某个对应的地址。“页（page）”是虚拟内存空间向物理内存空间映射的基本单元。

### 1.2. 驻留内存 (Resident Memory)

驻留内存，顾名思义是指那些被映射到进程虚拟内存空间的物理内存。一般我们所讲的进程占用了多少内存，其实就是说的占用了多少驻留内存而不是多少虚拟内存。因为虚拟内存大并不意味着占用的物理内存大。

### 1.3. 共享内存 (Shared Memory)

SHR 是 share（共享）的缩写，它表示的是进程占用的共享内存大小。

我们写的程序会依赖于很多外部的动态库（.so），比如 libc.so、libld.so 等等。这些动态库在内存中仅仅会保存 / 映射一份，如果某个进程运行时需要这个动态库，那么动态加载器会将这块内存映射到对应进程的虚拟内存空间中。多个进程之间通过共享内存的方式相互通信也会出现这样的情况。这么一来，就会出现不同进程的虚拟内存空间会映射到相同的物理内存空间。这部分物理内存空间其实是被多个进程所共享的，所以我们将他们称为共享内存，用 SHR 来表示。

某个进程占用的内存除了和别的进程共享的内存之外就是自己的独占内存了。所以要计算进程独占内存的大小只要用 RES 的值减去 SHR 值即可。

## 2. 内存模型

对于 Linux 32 位系统，最大寻址范围为 2^32 (4G) 的线性地址空间。Linux 简化了分段机制，使得虚拟地址与线性地址总是一致的，即一般把这个 4G 的地址空间划分为两个部分：
- 0～3G 为用户程序地址空间，虚地址 0x00000000 到 0xBFFFFFFF，供各个进程使用。
- 3G～4G 为内核的地址空间，虚拟地址 0xC0000000 到 0xFFFFFFFF, 供内核使用（ARM 架构不是 3G/1G 划分的，而是 2G/2G 划分。这里以 3G/1G 划分作讲解）。Linux 内核采用了最简单的映射方式来映射物理内存，即把物理地址＋PAGE_OFFSET 按照线性关系直接映射到内核空间（PAGE_OFFSET 大小为 0xC0000000）. 但是 linux 内核并没有把整个 1G 空间用于线性映射，而只映射了最多 896M 物理内存，预留了最高端的 128M 虚拟地址空间给 IO 设备和其他用途。当系统物理内存较大时，超过 896M 的内存区域，内核就无法直接通过线性映射直接访问了。这部分内存被称作 high memory。相应的可以映射的低端物理内存称为 Low memory。

对于 Linux 64 位系统，理论上 64bit 内存地址可用空间为 0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux 实际上只用了其中一小部分（256T）。**根据 Linux 内核相关文档描述，Linux 64 位操作系统中实际用到的地址空间为 0x0000000000000000 ~ 0x00007FFFFFFFFFFF 和 0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。**

![image](http://img.cdn.firejq.com/jpg/2018/7/29/87790219e8780320da56b2e47b879af2.jpg)

User Space 主要分为如下几段：
- **Code**：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）。
- **Data**：这里存放的是初始化过的全局变量。
- **BSS**：这里存放的是未初始化的全局变量。
- **Heap**：堆，堆自低地址向高地址增长，brk 相关的系统调用就是从这里分配内存。一般来说，malloc 所申请的内存主要从 Heap 区域分配（此处不考虑通过 mmap 申请大块内存的情况）。
- **Mapping Area**：这里是与 mmap 系统调用相关的区域。大多数实际的 malloc 实现会考虑通过 mmap 分配较大块的内存区域。这个区域自高地址向低地址增长。
- **Stack**：这是栈区域，自高地址向低地址增长。

其中：
- 代码段、数据段、BSS 段在程序编译期间由编译器分配空间，在程序启动时加载，由于未初始化的全局变量存放在 BSS 段，已初始化的全局变量存放在数据段，所以程序中应该尽量少的使用全局变量以节省程序编译和启动时间。
- 栈和堆在程序运行时由系统分配空间。

### 2.1. Code 段

Code 段通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定。

### 2.2. Data 段

Data 段通常是指用来存放程序中已初始化的全局变量、静态变量以及字符串常量。

### 2.3. BBS 段

BBS 即 Block Started by Symbol，通常是指用来存放程序中未初始化的全局变量和静态变量。

### 2.4. 栈内存

栈作为内存中存储结构，通常存放：
- **程序临时创建的局部变量**。
- **函数调用时其形参**。
- **函数调用后的返回值**。

栈是**由到高地址向低地址扩展**的数据结构，即依次定义两个局部变量，首先定义的变量的地址是高地址，其次变量的地址是低地址。

栈还具有“小内存、自动化、可能会溢出”的特点。栈顶的地址和栈的最大容量一般是系统预先规定好的，通常不会太大。由于栈中主要存放的是局部变量，而局部变量的占用的内存空间是其所在的代码段或函数段结束时由系统回收重新利用，所以栈的空间是循环利用自动管理的，一般不需要人为操作。如果某次局部变量申请的空间超过栈的剩余空间时就有可能出现 “栈的溢出”，进而导致意想不到的后果。所以一般不宜在栈中申请过大的空间，比如长度很大的数组、递归调用重复次数很多的函数等等。

TODO: [系统默认的栈大小限制](https://blog.csdn.net/woshiyuanlei/article/details/45059417)

### 2.5. 堆内存

**堆内存通常存放程序运行中动态分配的存储空间**。

堆是**由低地址向高地址扩展**的数据结构，是一块不连续的内存区域。

堆具有“大内存、手工分配管理、申请大小随意、可能会泄露”的特点，堆内存是操作系统划分给堆管理器来管理的，管理器向使用者（用户进程）提供 API（malloc 和 free 等）来使用堆内存。需要程序员手动分配释放，如果程序员在使用完申请后的堆内存却没有及时把它释放掉，那么这块内存就丢失了（进程自身认为该内存没被使用，但是在堆内存记录中该内存仍然属于这个进程，所以当需要分配空间时又会重新去申请新的内存而不是重复利用这块内存），就是我们常说的 - 内存泄漏，所以内存泄漏指的是堆内存被泄露了。

由于进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。因此，Linux 中通过以下方式管理堆内存：

![image](http://img.cdn.firejq.com/jpg/2018/7/29/1be42a562002c6192a08fe356a32df99.jpg)

Linux 维护一个 break 指针，这个指针指向堆空间的某个地址。从堆起始地址到 break 之间的地址空间为映射好的，可以供进程访问；而从 break 往上，是未映射的地址空间，如果访问这段空间则程序会报错。Linux 通过 brk 和 sbrk 系统调用操作 break 指针。两个系统调用的原型如下：
```c
int brk(void *addr);
void *sbrk(intptr_t increment);
```
- brk 将 break 指针直接设置为某个地址，brk 在执行成功时返回 0，否则返回 -1 并设置 errno 为 ENOMEM。
- sbrk 将 break 从当前位置移动 increment 所指定的增量，sbrk 成功时返回 break 移动之前所指向的地址，否则返回 (void *)-1。如果将 increment 设置为 0，则可以获得当前 break 的地址。

需要注意的是，由于 Linux 是按页进行内存映射的，所以如果 break 被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比 break 指向的地方要大一些，但使用 break 之后的地址是很危险的（尽管也许 break 之后确实有一小块可用内存地址）。

系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个 rlimit 表示当前进程可用的资源上限：
```c
struct rlimit {
		rlim_t rlim_cur;  /* Soft limit */
		rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
};
```
可用资源限制可以通过 getrlimit 系统调用得到：
```c
int main() {
		struct rlimit *limit = (struct rlimit *)malloc(sizeof(struct rlimit));
		getrlimit(RLIMIT_AS, limit);
		printf("soft limit: %ld, hard limit: %ld\n", limit->rlim_cur, limit->rlim_max);
}
```
每种资源有软限制和硬限制，并且可以通过 setrlimit 对 rlimit 进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。

## 3. Refer Links

[张洋：如何实现一个 malloc](http://blog.codinglabs.org/articles/a-malloc-tutorial.html)

[用户空间与内核空间，进程上下文与中断上下文](https://www.cnblogs.com/Anker/p/3269106.html)

[关于 linux kernel 里的 high memory](http://blog.sina.com.cn/s/blog_6488248f0100wu6v.html)