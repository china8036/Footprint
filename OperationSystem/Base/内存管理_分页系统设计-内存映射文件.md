- [内存管理 分页系统设计：内存映射文件](#内存管理-分页系统设计内存映射文件)
  - [1. 基本概念](#1-基本概念)
  - [2. 系统调用](#2-系统调用)
  - [3. 原理分析](#3-原理分析)
    - [3.1. 过程分析](#31-过程分析)
    - [3.2. 效率分析](#32-效率分析)
  - [4. 优缺点](#4-优缺点)
    - [4.1. 优点](#41-优点)
    - [4.2. 缺点](#42-缺点)
  - [5. 分类与用途](#5-分类与用途)
  - [6. 实现支持](#6-实现支持)
  - [7. Refer Links](#7-refer-links)

# 内存管理 分页系统设计：内存映射文件

## 1. 基本概念

> A memory-mapped file is a segment of virtual memory that has been assigned a direct byte-for-byte correlation with some portion of a file or file-like resource. This resource is typically a file that is physically present on disk, but can also be a device, shared memory object, or other resource that the operating system can reference through a file descriptor. Once present, this correlation between the file and the memory space permits applications to treat the mapped portion as if it were primary memory.

mmap 是一种内存映射文件的方法，即**将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，使得应用程序处理映射部分如同访问主内**存。即完成了对文件的操作而不必再调用 read,write 等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/13/f40426c327c43bcc120ef1d7bdc5e2b9.jpg)

## 2. 系统调用

```c
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
```
- 参数说明：
  - start：映射区的开始地址

  - length：映射区的长度

  - prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过 or 运算合理地组合在一起
    ```
    1 PROT_EXEC ：页内容可以被执行
    2 PROT_READ ：页内容可以被读取
    3 PROT_WRITE ：页可以被写入
    4 PROT_NONE ：页不可访问
    ```

  - flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体
    ```
    MAP_FIXED // 使用指定的映射起始地址，如果由 start 和 len 参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。
    MAP_SHARED // 与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到 msync() 或者 munmap() 被调用，文件实际上不会被更新。
    MAP_PRIVATE // 建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。
    MAP_DENYWRITE // 这个标志被忽略。
    MAP_EXECUTABLE // 同上
    MAP_NORESERVE // 不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。
    MAP_LOCKED // 锁定映射区的页面，从而防止页面被交换出内存。
    MAP_GROWSDOWN // 用于堆栈，告诉内核 VM 系统，映射区可以向下扩展。
    MAP_ANONYMOUS // 匿名映射，映射区不与任何文件关联。
    MAP_ANON //MAP_ANONYMOUS 的别称，不再被使用。
    MAP_FILE // 兼容标志，被忽略。
    MAP_32BIT // 将映射区放在进程地址空间的低 2GB，MAP_FIXED 指定时会被忽略。当前这个标志只在 x86-64 平台上得到支持。
    MAP_POPULATE // 为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。
    MAP_NONBLOCK // 仅和 MAP_POPULATE 一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。
    ```

  - fd：有效的文件描述词。如果 MAP_ANONYMOUS 被设定，为了兼容问题，其值应为 -1

  - offset：被映射对象内容的起点

- 返回说明：
  成功执行时，mmap() 返回被映射区的指针。失败时，mmap() 返回 MAP_FAILED『其值为 (void *)-1]， error 被设为以下的某个值：
  - 1 EACCES：访问出错
  - 2 EAGAIN：文件已被锁定，或者太多的内存已被锁定
  - 3 EBADF：fd 不是有效的文件描述词
  - 4 EINVAL：一个或者多个参数无效
  - 5 ENFILE：已达到系统对打开文件的限制
  - 6 ENODEV：指定文件所在的文件系统不支持内存映射
  - 7 ENOMEM：内存不足，或者进程已超出最大内存映射数量
  - 8 EPERM：权能不足，操作不允许
  - 9 ETXTBSY：已写的方式打开文件，同时指定 MAP_DENYWRITE 标志
  - 10 SIGSEGV：试着向只读区写入
  - 11 SIGBUS：试着访问不属于进程的内存区

```c
int munmap( void * addr, size_t len ) 
```
成功执行时，munmap() 返回 0。失败时，munmap 返回 -1，error 返回标志和 mmap 一致。

该调用在进程地址空间中解除一个映射关系，addr 是调用 mmap() 时返回的地址，len 是映射区的大小。

当映射关系解除后，对原来映射地址的访问将导致段错误发生。 

```c
int msync( void *addr, size_t len, int flags )
```
**一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用 munmap() 后才执行该操作，可以通过调用 msync() 实现磁盘上文件内容与共享内存区的内容一致**。

## 3. 原理分析

### 3.1. 过程分析

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/13/8e8062a0ca2e0501a94be3fa92322451.jpg)

1. 内存映射文件中的“映射”主要是指**硬盘上文件的位置与进程逻辑地址空间中一块大小相同的区域之间的一一对应。这种对应关系纯属是逻辑上的概念，物理上是不存在的**，原因是进程的逻辑地址空间本身就是不存在的。**在内存映射的过程中，并没有实际的数据拷贝，文件没有被载入内存，只是逻辑上被放入了内存**，具体到代码，就是建立并初始化了相关的数据结构（struct address_space），这个过程有系统调用 mmap() 实现，所以建立内存映射的效率很高。

    既然建立内存映射没有进行实际的数据拷贝，那么进程又怎么能最终直接通过内存操作访问到硬盘上的文件呢？那就要看内存映射之后的几个相关的过程了。

1. mmap() 会返回一个指针 ptr，它指向进程逻辑地址空间中的一个地址，这样以后，**进程无需再调用 read 或 write 对文件进行读写，而只需要通过 ptr 就能够操作文件**。但是 ptr 所指向的是一个逻辑地址，要操作其中的数据，必须通过 MMU 将逻辑地址转换成物理地址，这个过程与内存映射无关。

1. 由于建立内存映射并没有实际拷贝数据，因此 MMU 在地址映射表中是无法找到与 ptr 相对应的物理地址的，也就是将会发生 MMU 失败。这将产生一个**缺页中断，缺页中断的中断响应函数会在 swap 内存中寻找相对应的页面**，如果找不到（也就是该文件从来没有被读入内存的情况），则会通过 mmap() 建立的映射关系，从硬盘上将文件读取到物理内存中，这个过程与内存映射无关。

1. 如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘上，这个过程也与内存映射无关。

### 3.2. 效率分析

从过程分析中可以看到，无论是通过内存映射的方法访问硬盘上的文件，还是直接从硬盘上将文件读入内存，都要经过文件系统进行数据拷贝，而数据拷贝操作是由文件系统和硬件驱动实现的，因此理论上来说，拷贝数据的效率应该是一样的。但是通过内存映射的方法访问硬盘上的文件，效率要比 read 和 write 系统调用高，这是为什么呢？

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/13/0be39dba93de5fac435d342b0378a05b.jpg)

- 系统调用 read() 在执行的过程中，首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，然后再将这些数据拷贝到用户空间。在这个过程中，实际上完成了两次数据拷贝。
- 系统调用 mmap() 在执行的过程中，并没有进行数据拷贝，真正的数据拷贝是在缺页中断处理时进行的，**由于 mmap() 将文件直接映射到用户空间，所以中断处理函数根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝** 。因此，内存映射的效率要比 read/write 效率高，mmap 也被称为 zero-copy 技术。

## 4. 优缺点

### 4.1. 优点

- 内存映射文件的主要用处是增加 I/O 性能，对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代 I/O 读写，提高了文件读取效率。
  
  访问内存映射文件比直接文件读写要快几个数量级，特别是用于大文件。而对于小文件，内存映射文件会导致碎片空间浪费，因为内存映射总是要对齐页边界，这起码是 4 KB。因而一个 5 KB 文件将会映射占用 8 KiB 内存，浪费了 3 KB 内存。

- 内存映射文件可以只加载一部分内容到用户的逻辑内存空间，这对非常大的文件特别有用，可用于实现高效的大规模数据传输。

  内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件 I/O 操作，极大影响效率。这个问题可以通过 mmap 映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap 都可以发挥其功效。

### 4.2. 缺点

- 内存映射文件需要在进程中占用一块很大的连续逻辑地址空间。对于 Intel 的 IA-32 的 4 GB 逻辑地址空间，可用的连续地址空间远远小于 2-3 GiB。

- 相关联的文件的 I/O 错误（如可拔出驱动器或光驱被弹出，磁盘满时写操作等）的内存映射文件会向应用程序报告 SIGSEGV/SIGBUS 信号（POSIX 环境）或 EXECUTE_IN_PAGE_ERROR 结构化异常（Windows 环境）。而通常的内存操作是无需考虑这些异常的。

- CPU 含有内存管理单元（MMU）才支持内存映射文件。

## 5. 分类与用途

- 普通文件映射
  
  普通文件映射与硬盘文件相关联，当关闭内存映射时，数据被写入对应的硬盘文件中。
  
  **可用于提高对大文件的读写 IO 的性能，以及创建没有亲缘关系的进程间通信的共享内存**。

- 匿名文件映射
  
  https://www.zhihu.com/question/57653599 todo:

  匿名文件映射并不关联于硬盘文件，而是会将一个内核创建的全为进制零文件映射到虚拟内存中。当关闭内存映射文件，所有数据被抛弃。
  
  **适用于创建具有亲缘关系（父子关系）的进程间通信的共享内存，避免被其它进程共享**。
  
## 6. 实现支持

- POSIX 系统调用 `mmap()`: 创建一个内存映射文件，需要提供文件描述符、开始位置的文件指针、映射长度等参数。
- Java 语言的 `FileChannel`。
- Ruby 语言的 gem（库) `Mmap`。
- Python 语言的 `mmap` 标准库模块。
- PHP 的库函数 `file_get_contents()`。

## 7. Refer Links

[Wikipedia 内存映射文件](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6)

[内存映射文件原理探索](https://blog.csdn.net/mg0832058/article/details/5890688)

[认真分析 mmap：是什么 为什么 怎么用](https://www.cnblogs.com/huxiao-tee/p/4660352.html)

[Linux 中 mmap() 函数的内存映射问题理解？](https://www.zhihu.com/question/48161206)