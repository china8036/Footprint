- [进程与线程：死锁](#进程与线程死锁)
  - [1. 基本概念](#1-基本概念)
  - [2. 发生条件](#2-发生条件)
  - [3. 死锁检测](#3-死锁检测)
  - [4. 死锁避免](#4-死锁避免)
    - [4.1. 资源轨迹图](#41-资源轨迹图)
    - [4.2. 银行家算法 (banker's algorithm)](#42-银行家算法-bankers-algorithm)
      - [4.2.1. 调度过程](#421-调度过程)
      - [4.2.2. 算法缺点](#422-算法缺点)
  - [5. 死锁预防](#5-死锁预防)
  - [6. 死锁恢复](#6-死锁恢复)
  - [7. Refer Links](#7-refer-links)

# 进程与线程：死锁

## 1. 基本概念

如果一个进程集合中的每个进程，都在等待只能由进程集合中的其它进程才能引发的事件，那么，该进程集合就是死锁的。

## 2. 发生条件

1971 年 Coffman 等人总结出了发生（资源）死锁的 4 个必要条件：
- 对于资源
  - **互斥 (Mutual exclusion)：每个资源要么已经分配给了一个进程，要么就是可用的**。
  - **不可抢占 (No pre-emption)：已经被分配给某个进程的资源不能被强制的抢占，只能由占有它的进程显式的释放**。
- 对于进程
  - **占有和等待 (Hold and wait)：已经拥有了某个资源的进程还可以请求新的资源**。
  - **环路等待 (Circular wait)：死锁发生时，系统中一定有由 2 个或 2 个以上进程组成的一条环路，环路中的每个进程都在等待下一个进程所占有的资源**。

**死锁发生时，以上 4 个条件必定是同时被满足的。如果任意一个不成立，死锁就不会发生**。

## 3. 死锁检测

## 4. 死锁避免

### 4.1. 资源轨迹图

### 4.2. 银行家算法 (banker's algorithm)

1965 年，Dijkstra 提出了一种能够避免死锁的调度算法：银行家算法 (banker's algorithm)。

该算法的模型基于一个小镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会导致进入不安全状态：
- 如果是，就拒绝请求。
- 如果满足请求后系统仍然是安全的，就予以分配。

#### 4.2.1. 调度过程

图 6-12 中分别通过 3 个向量表示现有资源 E、已分配资源 P 和可用资源 A。其中，向量 P 可以通过将左边矩阵的各列相加获得，向量 A 可通过从向量 E 中减去向量 P 获得。另外，由于各个进程在一个状态执行前都会给出其所需的全部资源量，因此在系统运行的每一步都可以计算出右边的矩阵。

![image](http://img.cdn.firejq.com/Snipaste_2019-08-18_19-31-10.png)

检查一个状态是否安全的算法过程如下：
1. 查找右边矩阵中是否有一行，其没有被满足的资源数均小于或等于 A。如果不存在这样的行，那么系统将会死锁，因为任何进程都无法运行结束（假定进程会一直占有资源直到它们终止为止）。
1. 假如找到这样一行，那么可以假设它获得所需的资源并运行结束，将该进程标记为终止，并将其资源加到 A 上。另外，如果找到了多行都符合条件，那么不管选择哪一个运行都没有关系，因为可用资源需求只会增多或保持不变，而不可能会减少。
1. 重复以上两步，或者直到所有的进程都标记为终止，其初始状态是安全的，或者所有进程的资源需求都得不到满足，此时就是发生了死锁。

根据以上流程，图 6-12 的状态是安全的。

#### 4.2.2. 算法缺点

banker's algorithm 虽然很有意义，但却缺乏实用价值：
- 很少有进程能够在运行前就知道其所需要资源的最大值。
- 进程数是不确定的，且往往在不断变化（如新用户的登录或退出）。
- 原本可用的资源也有可能忽然变成不可用（如磁带机可能会偶然坏掉）。

因此，在实际中也极少有系统使用 banker's algorithm 来避免死锁。

## 5. 死锁预防

死锁避免需要预知未来的请求，因此从本质上来说是不可能的。但在实际系统中，我们可以通过破坏死锁发生的 4 个必要条件的任意一个，来预防死锁的发生。
- 破坏互斥条件
- 破坏不可抢占条件
- 破坏占有等待条件
- 破坏环路等待条件

具体措施：
- **设置加锁顺序**

  例如加锁顺序是 A->B->C，现在想要线程 C 想要获取锁，那么他必须等到线程 A 和线程 B 获取锁之后才能轮到他获取（排队执行，获取锁）。

  - 缺点：按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁，并知道他们之间获取锁的顺序是什么样的。

- **设置加锁时限**

  若一个线程在一定的时间里没有成功的获取到锁，则会进行回退并释放之前获取到的锁，然后等待一段时间后进行重试。在这段等待时间中其他线程有机会尝试获取相同的锁，这样就能保证在没有获取锁的时候继续执行比的事情。

  - 缺点：假如现在只有两个线程，这种方法可以很好的避免出现死锁。但假如有大量的线程同时去执行，大的基数让事件出现的概率变大，而线程还是等待那么长时间，多个线程的等待时间就有可能重叠，因此又会出现竞争超时，由于他们的超时发生时间正好赶在了一起，而超时等待的时间又是一致的，那么他们下一次又会竞争，等待，这就又出现了死锁。

- **设置线程优先级**

  发生死锁时使优先级较低的线程回退，其余的线程继续保持着他们获取的锁。

- **避免使用锁**

  使用 Lock-free 无锁数据结构、消息队列、管道等。

## 6. 死锁恢复

- 利用抢占恢复
- 利用回滚恢复
- 杀死进程恢复

## 7. Refer Links

[避免死锁](http://ifeve.com/deadlock-prevention/)

[编程可以避免死锁吗，怎样做到？](https://www.zhihu.com/question/29268623)