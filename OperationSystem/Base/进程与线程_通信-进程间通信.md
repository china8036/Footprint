- [进程与线程：进程间通信](#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1)
  - [1. 基本概念](#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [1.1. 目的](#11-%E7%9B%AE%E7%9A%84)
    - [1.2. 发展历史](#12-%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2)
  - [2. 文件 (File)](#2-%E6%96%87%E4%BB%B6-file)
  - [3. 管道](#3-%E7%AE%A1%E9%81%93)
    - [3.1. 普通管道 (Pipe)](#31-%E6%99%AE%E9%80%9A%E7%AE%A1%E9%81%93-pipe)
      - [3.1.1. 基本概念](#311-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
      - [3.1.2. 基本使用](#312-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8)
      - [3.1.3. 实现原理](#313-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)
    - [3.2. 流管道 (s_pipe)](#32-%E6%B5%81%E7%AE%A1%E9%81%93-spipe)
    - [3.3. 有名管道 (FIFO)](#33-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93-fifo)
      - [3.3.1. 基本概念](#331-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
      - [3.3.2. 基本使用](#332-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8)
      - [3.3.3. 实现原理](#333-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)
  - [4. 信号 (Signal)](#4-%E4%BF%A1%E5%8F%B7-signal)
    - [4.1. 基本概念](#41-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
      - [4.1.1. 信号来源](#411-%E4%BF%A1%E5%8F%B7%E6%9D%A5%E6%BA%90)
      - [4.1.2. 信号分类](#412-%E4%BF%A1%E5%8F%B7%E5%88%86%E7%B1%BB)
    - [4.2. 实现原理](#42-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)
  - [5. 消息队列](#5-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)
    - [5.1. XSI System V 消息队列 (Message Queue)](#51-xsi-system-v-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-message-queue)
    - [5.2. POSIX 消息队列](#52-posix-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)
  - [6. 共享内存](#6-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98)
    - [6.1. XSI System V 共享内存 (Shared Memory)](#61-xsi-system-v-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-shared-memory)
    - [6.2. POSIX 共享内存](#62-posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98)
  - [7. 域套接字 (Domain Socket)](#7-%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97-domain-socket)
  - [8. Refer Links](#8-refer-links)

# 进程与线程：进程间通信

## 1. 基本概念

IPC 问题主要包括 3 个方面的内容：
- 如何把信息从一个进程传递到另一个
- 如何确保多个进程在关键活动中不出现交叉
- 如何确保多个进程正确的执行顺序

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/13/f22f5a436544d8aeb35acffa3c65ca0f.jpg)

### 1.1. 目的

- 数据传输 

  一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几 M 字节之间

- 共享数据 

  多个进程想要操作共享数据，一个进程对共享数据

- 通知事件

  一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）

- 资源共享 

  多个进程之间共享同样的资源。为了实现这一点，需要内核提供锁和同步机制

- 进程控制 

  有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变

### 1.2. 发展历史

Linux 下的进程通信手段基本上是从 Unix 平台上的进程通信手段继承而来的。而对 Unix 发展做出重大贡献的两大主力：AT&T 的贝尔实验室、BSD（加州大学伯克利分校的伯克利软件发布中心）在进程间通信方面的侧重点有所不同。前者对 Unix 早期的进程间通信手段进行了系统的改进和扩充，形成了“system V IPC”，通信进程局限在单个计算机内。后者则跳过了该限制，形成了基于套接口（socket）的进程间通信机制。Linux 则把两者继承了下来。

- 早期 UNIX 进程间通信，方式包括：管道、FIFO、信号

- System V 进程间通信，方式包括：System V 消息队列、System V 信号量、System V 共享内存

- BSD 进程间通信：Domian Socket

- POSIX 进程间通信，方式包括：POSIX 消息队列、POSIX 信号量、POSIX 共享内存

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/14/394fcf1a08a8dcac531edfcd80506d4a.jpg)

| 类型             | 无连接 | 可靠 | 流控制 | 记录消息类型 | 优先级 |
| ---------------- | ------ | ---- | ------ | ------------ | ------ |
| 普通 PIPE         | N      | Y    | Y      |              | N      |
| 流 PIPE           | N      | Y    | Y      |              | N      |
| 命名 PIPE (FIFO)  | N      | Y    | Y      |              | N      |
| 消息队列         | N      | Y    | Y      |              | Y      |
| 信号量           | N      | Y    | Y      |              | Y      |
| 共享存储         | N      | Y    | Y      |              | Y      |
| UNIX 流 SOCKET     | N      | Y    | Y      |              | N      |
| UNIX 数据包 SOCKET | Y      | Y    | N      |              | N      |

## 2. 文件 (File)

文件的存在与否来当锁，文件内容来交互数据。

## 3. 管道

### 3.1. 普通管道 (Pipe)

#### 3.1.1. 基本概念

管道是 Linux 支持的最初 Unix IPC 形式之一，具有以下特点：
- 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。
- 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。
- 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是单独构成一种文件系统，并且只存在于内存中。
- 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

管道这种通讯方式有两种限制:
- 一是半双工的通信，数据只能单向流动。
- 二是只能在具有亲缘关系的进程间使用（通常是指父子进程关系）。

#### 3.1.2. 基本使用

- 创建
  ```c
  #include <unistd.h>
  int pipe(int fd[2])
  ```
  该函数创建的管道的两端处于一个进程中间，在实际应用中没有太大意义，因此，一个进程在由 pipe() 创建管道后，一般再 fork 一个子进程，然后通过管道实现父子进程间的通信（因此也不难推出，只要两个进程中存在亲缘关系，这里的亲缘关系指的是具有共同的祖先，都可以采用管道方式来进行通信）。

- 读写
  
  管道两端可分别用描述字 fd[0] 以及 fd[1] 来描述，需要注意的是，管道的两端是固定了任务的。即一端只能用于读，由描述字 fd[0] 表示，称其为管道读端；另一端则只能用于写，由描述字 fd[1] 来表示，称其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将导致错误发生。一般文件的 I/O 函数都可以用于管道，如 close、read、write 等。

#### 3.1.3. 实现原理

Linux 下的进程的用户态地址空间都是相互独立的，因此两个进程在用户态找不到彼此的存在，故没法直接通信。而**内核是进程间共享的，因此进程间想通信只能通过内核作为中间人，来传达信息**。

下图显示了两个进程间通过内核缓存进行通信的过程：
```
                写 | 入         +-------+
    +--------------+------------<       |
    |              |            | 进程 1 |
+---v----+         |            |       |
|        |         |            +-------+
| 缓 存  |     内  |  用
| (page) |     核  |  户
|        |         |  态
+---v----+         |            +-------+
    |              |            |       |
    |              |            | 进程 2 |
    +--------------+------------>       |
                读 | 取         +-------+
                   |
```

在一个进程中，向管道中写入数据时，其实就是写入这个缓存中；然后在另一个进程读取管道时，其实就是从这个缓存读取，实现进程的通信。

这个缓存也可以解释为什么管道是单通道的：由于只有一个缓存，如果是双通道，那么两个进程同时向这块缓存写数据时，这样会导致数据覆盖，即一个进程的数据被另一个进程的数据覆盖。而套接字有读写缓存，因此套接字是双通道的。

可见，管道是由内核管理的一个缓冲区。管道的一端连接一个进程的输出，这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区一般大小为 4K，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。

一般过程：

管道利用 fork 机制建立，从而让两个进程可以连接到同一个 PIPE 上。最开始的时候，上面的两个箭头都连接在同一个进程 Process 1 上 ( 连接在 Process 1 上的两个箭头 )。当 fork 复制进程的时候，会将这两个连接也复制到新的进程 (Process 2)。随后，每个进程关闭自己不需要的一个连接 ( Process 1 关闭从 PIPE 来的输入连接，Process 2 关闭输出到 PIPE 的连接 )，这样，剩下的连接就构成了 PIPE。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/14/f3669038fc16d29f2bc1438cdb344090.jpg)

由于基于 fork 机制，所以管道只能用于父进程和子进程之间，或者拥有相同祖先的两个子进程之间 （有亲缘关系的进程之间)。

在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的 file 结构和 VFS 的索引节点 inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/14/50cd4a039da2fa3dc002faf54021ee8e.jpg)

### 3.2. 流管道 (s_pipe)

流管道克服了普通管道的第一种限制，允许双向传输。

### 3.3. 有名管道 (FIFO)

#### 3.3.1. 基本概念

有名管道是为了解决无名管道只能用于近亲进程之间通信的缺陷而设计的，**虽然它也是半双工的通信方式，但它克服了普通管道的第二种限制，允许无亲缘关系进程间通信**。

FIFO 不同于管道之处在于它提供一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中。这样，即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信（能够访问该路径的进程以及 FIFO 的创建进程之间），因此，通过 FIFO 不相关的进程也能交换数据。

FIFO 严格遵循先进先出（first in first out），对管道及 FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek() 等文件定位操作。

#### 3.3.2. 基本使用

- 创建
  ```c
  #include <sys/types.h>
  #include <sys/stat.h>

  int mkfifo(const char * pathname, mode_t mode)
  ```
  - 第一个参数是一个普通的路径名，也就是创建后 FIFO 的名字。

    如果 mkfifo 的第一个参数是一个已经存在的路径名时，会返回 EEXIST 错误，所以一般典型的调用代码首先会检查是否返回该错误，如果确实返回该错误，那么只要调用打开 FIFO 的函数就可以了。一般文件的 I/O 函数都可以用于 FIFO，如 close、read、write 等等。

  - 第二个参数与打开普通文件的 open() 函数中的 mode 参数相同。

- 打开

  有名管道比管道多了一个打开操作：open。

  - 如果当前打开操作是为读而打开 FIFO 时，若已经有相应进程为写而打开该 FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为写而打开该 FIFO（当前打开操作设置了阻塞标志）；或者，成功返回（当前打开操作没有设置阻塞标志）。
  - 如果当前打开操作是为写而打开 FIFO 时，如果已经有相应进程为读而打开该 FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为读而打开该 FIFO（当前打开操作设置了阻塞标志）；或者，返回 ENXIO 错误（当前打开操作没有设置阻塞标志）。

- 读写
  - 如果一个进程为了从 FIFO 中读取数据而阻塞打开 FIFO，那么称该进程内的读操作为设置了阻塞标志的读操作。
  - 如果一个进程为了向 FIFO 中写入数据而阻塞打开 FIFO，那么称该进程内的写操作为设置了阻塞标志的写操作。  

#### 3.3.3. 实现原理

命名管道引入了一种新的特殊文件类型：FIFO 文件，实现一个命名管道实际上就是实现一个 FIFO 文件。之所以叫 FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据被最先读出来，从而保证信息交流的顺序。

**FIFO 在文件系统中有对应的路径，它借用了文件系统 (file system) 的路径来为管道命名，通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接**。

当一个进程以读 (r) 的方式打开该文件，而另一个进程以写 (w) 的方式打开该文件，那么内核就会在这两个进程之间建立管道，所以 FIFO 实际上也由内核管理，不与硬盘打交道。虽然 FIFO 文件的 inode 节点在磁盘上，但是仅是一个节点而已，文件的数据还是存在于内存缓冲页面中，和普通管道相同。当删除 FIFO 文件时，管道连接也随之消失。

## 4. 信号 (Signal)

### 4.1. 基本概念

信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。

- 信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。
- 信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。
- **信号是进程间通信机制中唯一的异步通信机制**，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。
- 信号机制经过 POSIX 实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。

#### 4.1.1. 信号来源

信号事件的发生有两个来源：
- 硬件来源（比如我们按下了键盘或者其它硬件故障)。
- 软件来源，最常用发送信号的系统函数是 kill, raise, alarm 和 setitimer 以及 sigqueue 函数，软件来源还包括一些非法运算等操作。

#### 4.1.2. 信号分类

可以从两个不同的分类角度对信号进行分类：
- 可靠性方面：可靠信号与不可靠信号。
  - Linux 信号机制基本上是从 Unix 系统中继承过来的。早期 Unix 系统中的信号机制比较简单和原始，后来在实践中暴露出一些问题，因此，把那些建立在早期机制上的信号叫做"不可靠信号"，信号值小于 SIGRTMIN(Red hat 7.2 中，SIGRTMIN=32，SIGRTMAX=63) 的信号都是不可靠信号。这就是"不可靠信号"的来源。
  - 信号值位于 SIGRTMIN 和 SIGRTMAX 之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。Linux 在支持新版本的信号安装函数 sigation（）以及信号发送函数 sigqueue() 的同时，仍然支持早期的 signal（）信号安装函数，支持信号发送函数 kill()。

- 与时间的关系上：实时信号与非实时信号。

  早期 Unix 系统只定义了 32 种信号，Ret hat7.2 支持 64 种信号，编号 0-63(SIGRTMIN=31，SIGRTMAX=63)，将来可能进一步增加，这需要得到内核的支持。
  - 前 32 种信号表示非实时信号，已经有了预定义值，每个信号有了确定的用途及含义，并且每种信号都有各自的缺省动作。如按键盘的 CTRL ^C 时，会产生 SIGINT 信号，对该信号的默认反应就是进程终止。
  - 后 32 个信号表示实时信号，等同于前面阐述的可靠信号。这保证了发送的多个实时信号都被接收。实时信号是 POSIX 标准的一部分，可用于应用进程。

  非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。

### 4.2. 实现原理

todo:

## 5. 消息队列

消息队列实际上是一个由消息组成的链表，存放在内核中，由消息队列标识符标识。对消息队列有写权限的进程可以向中按照一定的规则添加新消息；对消息队列有读权限的进程则可以从消息队列中读走消息。**消息队列是随内核持续的**。

**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点**。

目前主要有两种类型的消息队列：POSIX 消息队列以及 System V 消息队列，System V 消息队列目前被大量使用。

消息队列与管道以及有名管道相比，
- 消息队列具有更大的灵活性：
  - 首先，它提供有格式字节流，有利于减少开发人员的工作量。
  - 其次，消息具有类型，在实际应用中，可作为优先级使用。
  这两点是管道以及有名管道所不能比的。
- 消息队列可以在几个进程间复用，而不管这几个进程是否具有亲缘关系，这一点与有名管道很相似；但**消息队列是随内核持续的，与有名管道（随进程持续）相比，生命力更强，应用空间更大**。

### 5.1. XSI System V 消息队列 (Message Queue)

### 5.2. POSIX 消息队列

## 6. 共享内存

共享内存可以说是最有用的进程间通信方式，也是最快的 IPC 形式，它是针对其他进程间的通信方式运行效率低而专门设计的。两个不同进程 A、B 共享内存的意思是，同一块物理内存被映射到进程 A、B 各自的进程地址空间。进程 A 可以即时看到进程 B 对共享内存中数据的更新，反之亦然。**由于多个进程共享同一块内存区域，因此必然需要某种同步机制，互斥锁和信号量都可以**。

采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。**对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据：一次从输入文件到共享内存区，另一次从共享内存区到输出文件**。

进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。

- 原理：
  
  https://www.zhihu.com/question/29973022

  进程间需要共享的数据被放在一个叫做 IPC 共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。

  共享内存共享的东西，准确的说不是内存，而是基于 RAM 的文件。共享内存机制获得的东西，准确的说不是内存！而是基于 RAM 的文件。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/18/26402b624e286b12ba354912332d7400.jpg)

  https://blog.csdn.net/Al_xin/article/details/38602093

  SHMMNI 为 128，表示系统中最多可以有 128 个共享内存对象。

### 6.1. XSI System V 共享内存 (Shared Memory)

### 6.2. POSIX 共享内存

## 7. 域套接字 (Domain Socket)

UNIX Domain Socket 是目前最广泛使用的 IPC 机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。Domain Socket 起初是由 Unix 系统的 BSD 分支开发出来的，但现在一般可以移植到其它类 Unix 系统上：Linux 和 System V 的变种都支持套接字。

## 8. Refer Links

todo: 

https://github.com/clpsz/linux-ipcs

https://github.com/clpsz/linux-itss

[linux 下进程间的同步机制有哪些？](https://www.zhihu.com/question/36529093)

[Linux 进程间通信的几种方式总结 --linux 内核剖析（七）](https://blog.csdn.net/gatieme/article/details/50908749)

[深刻理解 Linux 进程间通信（IPC）](https://blog.csdn.net/21aspnet/article/details/7420091)

[从内核源码聊聊 pipe 实现](http://luodw.cc/2016/08/01/pipeof/)

[Linux 管道 pipe 的实现原理](https://www.2cto.com/os/201607/528773.html)

[目前 linux 进程间通信的常用方法是什么 (pipe？信号量？消息队列？)?](https://www.zhihu.com/question/23995948)