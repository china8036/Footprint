- [进程与线程](#进程与线程)
  - [1. 进程](#1- 进程)
    - [1.1. 进程模型](#11- 进程模型)
    - [1.2. 进程的创建](#12- 进程的创建)
    - [1.3. 进程的终止](#13- 进程的终止)
    - [1.4. 进程状态](#14- 进程状态)
    - [1.5. 进程层次结构](#15- 进程层次结构)
    - [1.6. 进程实现](#16- 进程实现)
    - [1.7. 父子进程](#17- 父子进程)
  - [2. 轻量级进程](#2- 轻量级进程)
  - [3. 线程](#3- 线程)
    - [3.1. 线程演变](#31- 线程演变)
    - [3.2. 线程模型](#32- 线程模型)
    - [3.3. 线程实现](#33- 线程实现)
      - [3.3.1. 内核级线程](#331- 内核级线程)
      - [3.3.2. 用户级线程](#332- 用户级线程)
      - [3.3.3. 混合型线程](#333- 混合型线程)
    - [3.4. POSIX 线程](#34-posix- 线程)
      - [3.4.1. POSIX 线程演变](#341-posix- 线程演变)
      - [3.4.2. pthread 库使用](#342-pthread- 库使用)
  - [4. 多任务程序](#4- 多任务程序)
    - [4.1. 实现方式](#41- 实现方式)
    - [4.2. 并发 & 并行](#42- 并发 -- 并行)
    - [4.3. 多线程 & 多进程](#43- 多线程 -- 多进程)
    - [4.4. 多并发程序优化](#44- 多并发程序优化)
  - [5. Refer Links](#5-refer-links)

# 进程与线程

## 1. 进程

### 1.1. 进程模型

一个进程就是一个正在执行的程序的实例，包括**程序计数器、寄存器和变量的当前值**，**进程是资源分配的最小单位**。

https://www.seas.upenn.edu/~cit595/cit595s10/lectures/processvsthreads.pdf

A process is a name given to a program instance that has been loaded into memory and managed by the operating system.

Process address space is generally organized into code, data (static/global), heap, and stack segments.

![image](http://img.cdn.firejq.com/jpg/2018/7/13/f89c38b7844f7209296cbe78da9ae510.jpg)

### 1.2. 进程的创建

<!-- TODO: 看课本补充 -->

![image](http://img.cdn.firejq.com/jpg/2019/9/7/f2f964085f0b4003152f603f9799cdfc.jpg)

### 1.3. 进程的终止

<!-- TODO: 看课本补充 -->

![image](http://img.cdn.firejq.com/jpg/2019/9/7/4ab88bcacd0a914b318b55c9b2e6ad20.jpg)

### 1.4. 进程状态

在大多数操作系统中，进程有 3 种基本状态：

- 就绪态 (Ready): 当进程已拥有除 CPU 以外的所有必要的资源，只要获得 CPU 调度即可立即执行时，此时的进程状态称为就绪态。
- 运行态 (Running): 当进程已被 CPU 调度，其程序进入 CPU 中执行（实际占用着 CPU 资源），则此时的进程状态称为运行态。
- 阻塞态 (Blocked): 当处于运行态的进程，由于等待某个事件的发生而无法继续执行时，操作系统将使该进程让出 CPU 而进入阻塞状态。引起进程阻塞的事件可有很多种，常见的如：等待 I/O 完成、申请缓冲区不能满足、等待信号的到来等。

一个进程在运行期间，不断地从一种状态转换到另一种状态，它可以多次处于就绪状态和运行状态，也可以多次处于阻塞状态：

![image](http://img.cdn.firejq.com/jpg/2019/9/7/8866a2adef5608d0cf04da6f6853bb89.jpg)

- 就绪态 → 运行态：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成运行状态。
- 运行态 → 就绪态：处于运行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从运行状态转变成就绪状态。
- 运行态 → 阻塞：正在运行的进程因等待外部资源而无法继续执行时，便从运行状态变成阻塞状态。
- 阻塞 → 就绪态：处于阻塞状态的进程，若其等待外部资源充足，于是进程由阻塞状态转变为就绪状态。

### 1.5. 进程层次结构

<!-- TODO: 看课本补充 -->

![image](http://img.cdn.firejq.com/jpg/2019/9/7/4f681840a6f674db18a30f3bfda2f316.jpg)

### 1.6. 进程实现

为实现进程模型，**操作系统维护着一张进程表，每个进程都占用着一个表项（进程控制块），该表项包括了该进程的状态信息（程序计数器、堆栈指针、内存分配状态、所打开的文件的状态、调度信息以及其它在进程由运行态转换到就绪态或阻塞态必须保存的信息）**。

e.g.

典型进程表表项中的一些字段：
- 进程管理
  - 寄存器
  - 程序计数器
  - 程序状态字
  - 堆栈指针
  - 进程状态
  - 调度参数
  - 进程 ID
  - 父进程
  - 进程组
  - 信号
  - 进程开始时间
  - 使用的 CPU 时间
  - 子进程的 CPU 时间
  - 下次报警时间
- 存储管理
  - 正文段指针
  - 数据段指针
  - 堆栈段指针
- 文件管理
  - 根目录
  - 工作目录
  - 文件描述符
  - 用户 ID
  - 组 ID

实际上，当一个中断发生时，首先硬件层的中断硬件就是将进程表表项中的关键内容（程序计数器、程序状态字以及一个或多个寄存器）压入堆栈，计算机随即跳转到中断向量所指的地址，然后软件层特别是中断服务程序就接管一切剩余的工作。

中断发生后操作系统最底层的工作步骤：
1. 硬件压入堆栈程序计数器
1. 硬件从中断向量装入新的程序计数器
1. 汇编语言过程保存寄存器值
1. 汇编语言过程设置新的堆栈
1. C 中断服务程序运行（典型地读和缓冲输入）
1. 调度程序决定下一个将运行的进程
1. 汇编语言过程开始运行新的当前进程

所有的中断都从保存寄存器开始，对于当前进程而言，通常是在进程表项中，随后，会从堆栈中删除由中断硬件机制存入堆栈的那部分信息，并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。一些诸如保存寄存器值和设置堆栈指针等操作，无法用 C 语言这一类高级语言描述，所以这些操作通过一个短小的汇编语言程序来完成，通常该程序可以供所有的中断使用，因为无论中断是怎样引起的，有关保存寄存器的工作则是完全一样的。

### 1.7. 父子进程

TODO:

当通过 fork 创建了一个子进程时，子进程会继承父进程的包括（不限于）以下内容：
- 环境 (environment)
- 堆栈
- 内存
- 打开的文件资源 (Data)
- 信号 (signal) 控制设定
- nice 值
- 进程组号
- 当前工作目录
- 控制终端

不会继承父进程的以下内容：
- 进程号和父进程号
- 锁定内存 (memory locks)
- 在 tms 结构中的系统时间
- 阻塞信号集
- 由 timer_create 函数创建的计时器
- 异步输入和输出

## 2. 轻量级进程

## 3. 线程

### 3.1. 线程演变

TODO:

在操作系统设计上，从进程演化出线程，最主要的目的就是更好的支持对称多处理机以及减小进程的上下文切换开销。

### 3.2. 线程模型

在一个线程中拥有一个程序计数器（记录着要执行哪一条指令）、寄存器（保存线程当前的工作变量）以及堆栈（记录执行历史），**线程是任务调度的最小单位**。

多个线程共享一个进程的地址空间，也就是说，它们共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写甚至清除另一个线程的堆栈。

线程之间是没有保护的，因为既没有必要，也不可能做到，这和多个进程是有差别的：

- 对于不同进程来说，它们可能来自不同的用户，彼此之间可能存在“敌意”（例如对资源的争抢）。
- 对于不同线程来说，它们“属于”同一个进程，被同一个用户创建出来应该是为了共同合作来完成同一个任务而不是彼此争斗。

**哪些东西是一个线程私有的**？答案中必须包含寄存器，否则悲催：

![image](http://img.cdn.firejq.com/jpg/2018/7/13/fd397bc7156a99ccac2b98bc6bfe190d.jpg)

TODO:

https://stackoverflow.com/questions/1762418/what-resources-are-shared-between-threads

共有：
- 地址空间
- 打开的文件资源 (Data)
- 全局变量 (Heap)
- 信号及信号处理程序 http://www.linuxprogrammingblog.com/all-about-linux-signals?page=11

私有：
- 程序计数器
- 寄存器
- 调用栈 (Call Stack)

  > Threads share all segments except the stack. Threads have independent call stacks, however the memory in other thread stacks is still accessible and in theory you could hold a pointer to memory in some other thread's local stack frame.
- 状态

### 3.3. 线程实现

线程是比进程更加轻量的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件 I/O 等），又可以独立调度。

实现线程主要有 3 种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。

#### 3.3.1. 内核级线程

内核线程 (Kernel-Level Thread, KLT) 是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器 Scheduler 对线程进行调度，并负责将线程的任何映射到各个 CPU 上。从而使得操作系统有能力同时处理多个事务，支持多线程的内核称为多线程内核 (Multi-Threads Kernel)。

在实际应用中，程序一般不会直接使用 KLT，而是使用 KLT 的抽象接口 --**轻量级进程 (Light Weight Process, LWP)**。轻量级进程是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个进程有一个或多个 LWP，每个 LWP 由一个内核线程支持。
- 与线程相比：每一个 LWP 都有自己的进程标识符，并与一个特定的内核线程关联。在内核线程的支持下，LWP 是一个独立的调度单元，**只能由内核管理并像普通进程一样被调度**。
- 与普通进程相比：LWP 只有一个最小的执行上下文和调度程序所需的统计信息，并且与其他进程共享所有（或大部分）它的逻辑地址空间和系统资源。

事实上，LWP 就是我们通常意义上的线程，由于每个 LWP 都由一个内核线程支持，因此只有支持内核线程的操作系统，才能支持轻量级进程。

这种轻量级进程与内核线程之间 1:1 的关系称为一对一线程模型：

![image](http://img.cdn.firejq.com/jpg/2018/3/30/d636ec2d3f77ccf8a9906fc06580cda7.jpg)

优点：
- 由于内核线程的支持，每个 LWP 都称为一个独立的调度单元，即使有一个 LWP 在系统调用中阻塞了，也不会影响整个进程继续工作。

缺点：
- 由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中来回切换。
- 其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。

Linux 内核是支持 LWP 的典型例子，实际上 Linux 内核也只提供了轻量级进程的支持（没有内核线程和用户级线程的支持），虽限制了更高效的线程模型的实现，但 Linux 着重优化了进程的调度开销，一定程度上也弥补了这一缺陷。**目前最流行的线程机制 LinuxThreads 所采用的就是一对一线程模型，将 CPU 资源调度交给内核态，而在用户态实现一个包括信号处理在内的线程管理机制。**

#### 3.3.2. 用户级线程

从广义上看，一个线程只要不是内核线程，就可以认为是用户线程（从这个意义上看，LWP 也属于用户线程）。

从狭义上看，用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。这种进程与用户线程之间 1:N 的关系称为一对多线程模型。

![image](http://img.cdn.firejq.com/jpg/2018/3/30/02a3cd9f98b0248c3f7dad3a5706d26b.jpg)

优点：
- 如果程序实现得当，用户现场不需要切换到内核态，因此操作可以是非常快速且低消耗的，也因此可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。

缺点：
- 用户线程的创建、切换和调度都需要开发者自己实现，且由于操作系统只把 CPU 资源分配到进程，诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其它处理器上”这类问题处理起来将会异常困难，因而使用用户线程实现的程序一般都会比较复杂。

这种用户级线程实际上只需要完成线程运行栈的切换，调度开销非常小，但由于核心信号（无论是同步的还是异步的）都是以进程为单位的，因而无法定位到线程，所以这种实现方式不能用于多处理器系统，而这个需求正变得越来越大。因此，在实际应用中，除了算法研究目的以及在不支持多线程的操作系统（如 DOS）中的多线程程序外，纯用户级线程的实现已经逐渐消失了，Java、Ruby 等语言都曾经使用用户线程作为线程的实现，但最终都又放弃使用它。

#### 3.3.3. 混合型线程

除了依赖于内核线程实现和完全由用户程序在用户态中实现线程，还有一种将内核线程与用户线程混合实现的方式。**在这种混合实现下，既存在用户线程，也存在轻量级进程，用户线程与轻量级进程的映射数量比是不确定的**。

在这种混合模式下，用户线程与轻量级进程的数量比是不确定的，即 N:M，这样的关系称为多对多线程模型。

![image](http://img.cdn.firejq.com/jpg/2018/3/31/9b34b10991ae9051204c254ea8a2dc7d.jpg)

优点：
- 由于用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。
- 操作系统提供的轻量级进程则作为用户线程和内核线程之间的桥梁，这样就可以使用内核提供的线程调度功能及处理器映射而无需由程序员实现。
- 用户线程的系统调用需要通过轻量级进程来完成，大大降低了整个进程被阻塞的风险。

正如很多技术一样，“混合”通常都能带来更高的效率，但同时也带来更大的实现难度，**出于”简单”的设计思路，Linux 从一开始就没有实现混合模型的计划**。

### 3.4. POSIX 线程

![image](http://img.cdn.firejq.com/jpg/2018/7/13/2c5dd8d5f3bd2ba65dda83221aae7605.jpg)

#### 3.4.1. POSIX 线程演变

TODO: [Linux 下调用 pthread 库创建的线程是属于用户级线程还是内核级？](https://www.zhihu.com/question/35128513)

#### 3.4.2. pthread 库使用

## 4. 多任务程序

### 4.1. 实现方式

多任务的实现有 3 种方式：
- 多进程单线程模式：启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。
- 单进程多线程模式：启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。
- 多进程多线程模式：启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。

要实现多任务，通常我们会设计 Master-Worker 模式，Master 负责分配任务，Worker 负责执行任务，因此，多任务环境下，通常是一个 Master，多个 Worker。

### 4.2. 并发 & 并行

并发和并行从宏观上来讲都是同时处理多路请求的概念，但并发和并行又有区别：
- 并行是指两个或者多个事件在**同一时刻**发生。
- 并发是指两个或多个事件在**同一时间间隔**内发生。

P.S.

- 由于 CPU 执行代码都是顺序执行的，每个 CPU 在同一时间只能执行一个线程（在单核 CPU 下的多线程其实都只是并发，不是并行），那么单核 CPU 是怎么执行多任务的呢？

  答案就是操作系统轮流让各个任务交替执行，任务 1 执行 0.01 秒，切换到任务 2，任务 2 执行 0.01 秒，再切换到任务 3，执行 0.01 秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于 CPU 的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。

- 由于每个进程至少要干一件事，所以，一个进程至少有一个线程；多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核 CPU 才可能实现。

### 4.3. 多线程 & 多进程

TODO:

多线程和多进程的区别（重点 面试官最最关心的一个问题，必须从 cpu 调度，上下文切换，数据共享，多核 cpu 利用率，资源占用，等等各方面回答）

为什么线程切换开销比进程切换小？

http://ourcoders.com/thread/show/4327/

https://www.zhihu.com/question/19903801

P.S. [多线程有什么用？](https://www.zhihu.com/question/19901763)

- 对于 Windows 系统：创建进程的时间开销很大，因此 Windows 编程中建议在一个进程中进行多线程操作。因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。
- 对于 Linux 系统：创建进程的时间开销很小，因此 Linux 鼓励使用多进程操作。这带来新的问题是：坐在两张不同的桌子上，说话不方便。因此，Linux 下的学习重点大家要学习进程间通讯的方法。

可以做个实验：创建一个进程，在进程中往内存写若干数据，然后读出该数据，然后退出。此过程重复 1000 次，相当于创建 / 销毁进程 1000 次。在我机器上的测试结果是：
- UbuntuLinux：耗时 0.8 秒
- Windows7：耗时 79.8 秒
两者开销大约相差一百倍。

换句话说就是，Windows 编程中不建议你创建进程，如果你的程序架构需要大量创建进程，那么最好是切换到 Linux 系统。大量创建进程的典型例子有两个，一个是 gnu autotools 工具链，用于编译很多开源代码的，他们在 Windows 下编译速度会很慢，因此软件开发人员最好是避免使用 Windows。另一个是服务器，某些服务器框架依靠大量创建进程来干活，甚至是对每个用户请求就创建一个进程，这些服务器在 Windows 下运行的效率就会很差。这"可能"也是放眼全世界范围，Linux  服务器远远多于 Windows 服务器的原因。

P.S.

如果你是写服务器端应用的，其实在现在的网络服务模型下，开桌子的开销是可以忽略不计的，因为现在一般流行的是按照 CPU 核心数量开进程或者线程，开完之后在数量上一直保持，进程与线程内部使用协程或者异步通信来处理多个并发连接，因而开进程与开线程的开销可以忽略了。

另外一种新的开销被提上日程：核心切换开销。现代的体系，一般 CPU 会有多个核心，而多个核心可以同时运行多个不同的线程或者进程。当每个 CPU 核心运行一个进程的时候，由于每个进程的资源都独立，所以 CPU 核心之间切换的时候无需考虑上下文。当多个 CPU 核心运行一个线程的时候，由于每个线程需要共享资源，所以这些资源必须从 CPU 的一个核心被复制到另外一个核心，才能继续运算，这占用了额外的开销。换句话说，**在 CPU 为多核的情况下，多线程在性能上不如多进程。因而，当前面向多核的服务器端编程中，需要习惯多进程而非多线程**。

<!-- ----------- -->

多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是 Master 进程只负责分配任务，挂掉的概率低）著名的 Apache 最早就是采用多进程模式。
多进程模式的缺点是创建进程的代价大，在 Unix/Linux 系统下，用 fork 调用还行，在 Windows 下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和 CPU 的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。多线程模式还有一个致命的缺点，就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在 Windows 上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。
在 Windows 下，多线程的效率比多进程要高，所以微软的 IIS 服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS 的稳定性就不如 Apache。为了缓解这个问题，IIS 和 Apache 现在又有多进程 + 多线程的混合模式。

对于 python 的并发：·
1)	CPU 密集型代码（各种循环处理、计数等等)，在这种情况下，由于计算工作多，ticks 计数很快就会达到阈值，然后触发 GIL 的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以 python 下的多线程对 CPU 密集型代码并不友好。
2)	IO 密集型代码（文件处理、网络爬虫等)，多线程能够有效提升效率（单线程下有 IO 操作会进行 IO 等待，造成不必要的时间浪费，而开启多线程能在线程 A 等待时，自动切换到线程 B，可以不浪费 CPU 的资源，从而能提升程序执行效率)。所以 python 的多线程对 IO 密集型代码比较友好。

### 4.4. 多并发程序优化

TODO:

http://blog.51cto.com/casey/1740987

https://www.zhihu.com/question/24465233

多并发又可以分为 CPU 密集型和 IO 密集型。

（1）CPU 密集型即需要非常多的 CPU 计算资源，如有多颗 CPU 核心，可以让每一颗 CPU 都参与计算，从而不浪费服务器资源，CPU 密集型的典型例子，例如文件排序、图形搜索、动态规划等需要复杂的科学计算的情况，CPU 密集型需要减少线程数，减少线程的上下文切换导致的资源损耗。

（2）IO 密集型即需要大量的数据读写，例如网络传输、数据库读写等，大部分的网站、企业应用系统都属于 IO 密集型，当发生 IO 读写的时候，由于 IO 操作时间很长（受限于硬盘的读写速度和网络传输速度），线程会处于等待状态，此时 CPU 空闲，这时 CPU 可以调度其他线程进行处理，IO 密集型需要增加线程数，这样在 IO 处理的时候，可以去做其他事情，以提高并发量。

对于多并发，目前主要采用多进程和多线程两种模式，例如一台服务器上有多个应用服务器，然后多个应用服务器接收多个线程并发执行，因为线程之间的切换也有成本，所以也有观点认为应该采用多进程的模式。总之，进程数和线程数应该要根据实际情况进行综合选择。

那么，到底启动多少线程合适呢？根据以上分析，线程数应该和 CPU 核心数量成正比，而和 IO 阻塞时间成反比，因此有两个公式可供参考：

（1）线程数 = [ 任务执行时间 /（任务执行时间 -IO 等待时间) ] * CPU 内核数

（2）线程数 = CPU 核心数 /(1- 阻塞系数)

   这个阻塞系数一般为 0.8~0.9 之间，也可以取 0.8 或者 0.9。

**如果是 CPU 密集型，则线程数不超过 CPU 内核数；如果是 IO 密集型，则应该增加线程数，提高并发量**。

当发现系统运行慢的时候，不是盲目去加 CPU 加内存或者加硬盘，应该充分了解系统资源的使用情况，从而决定如何升级系统配置，例如在 Linux 环境下用 TOP 指令观察 CPU、硬盘的使用情况：
```
Tasks: 29 total, 1 running, 28 sleeping,0 stopped, 0 zombie
Cpu(s): 0.3% us, 1.0% sy, 0.0% ni, 98.7%id, 0.0% wa, 0.0% hi, 0.0% si
```

0.3% us 反应 CPU 使用情况，0.0% wa 则大致体现出当前的磁盘 io 请求是否频繁。如果 wa 的数量比较大，说明等待输入输出的的 io 比较多，另外还可以通过交互命令 H 了解各个线程对 CPU 的使用情况。

在 Mysql 中还可以通过 `SHOW PROCESSLIST` 命令查看高导致磁盘频繁读写的查询语句。

## 5. Refer Links

[线程的 3 种实现方式 -- 内核级线程，用户级线程和混合型线程](https://blog.csdn.net/gatieme/article/details/51892437)

[Linux 下调用 pthread 库创建的线程是属于用户级线程还是内核级？](https://www.zhihu.com/question/35128513)

TODO:

[通过网络图片小爬虫对比 Python 中单线程与多线（进）程的效率](https://www.jianshu.com/p/d87c951d8416)