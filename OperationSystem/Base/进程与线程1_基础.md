- [进程与线程](#进程与线程)
  - [1. 进程](#1-进程)
    - [1.1. 进程模型](#11-进程模型)
    - [1.2. 进程状态](#12-进程状态)
    - [1.3. 进程实现](#13-进程实现)
    - [1.4. 父子进程](#14-父子进程)
  - [2. 轻量级进程](#2-轻量级进程)
  - [3. 线程](#3-线程)
    - [3.1. 线程演变](#31-线程演变)
    - [3.2. 线程模型](#32-线程模型)
    - [3.3. 线程实现](#33-线程实现)
      - [3.3.1. 内核级线程](#331-内核级线程)
      - [3.3.2. 用户级线程](#332-用户级线程)
      - [3.3.3. 混合型线程](#333-混合型线程)
    - [3.4. POSIX 线程](#34-posix-线程)
      - [3.4.1. POSIX 线程演变](#341-posix-线程演变)
      - [3.4.2. pthread 库使用](#342-pthread-库使用)
  - [4. 多线程和多进程的区别](#4-多线程和多进程的区别)
  - [5. 并发优化](#5-并发优化)
  - [6. Refer Links](#6-refer-links)

# 进程与线程

## 1. 进程

### 1.1. 进程模型

一个进程就是一个正在执行的程序的实例，包括**程序计数器、寄存器和变量的当前值**。

https://www.seas.upenn.edu/~cit595/cit595s10/lectures/processvsthreads.pdf

A process is a name given to a program instance that has been loaded into memory and managed by the operating system.

Process address space is generally organized into code, data (static/global), heap, and stack segments.

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/13/f89c38b7844f7209296cbe78da9ae510.jpg)

### 1.2. 进程状态

- 运行态
- 阻塞态
- 就绪态

### 1.3. 进程实现

为实现进程模型，**操作系统维护着一张进程表，每个进程都占用着一个表项（进程控制块），该表项包括了该进程的状态信息（程序计数器、堆栈指针、内存分配状态、所打开的文件的状态、调度信息以及其它在进程由运行态转换到就绪态或阻塞态必须保存的信息）**。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/13/915f53e7fd8a4d87cad3105943776b20.jpg)

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/13/b8a9d31013b2cfe1d003ccf1a648b625.jpg)

### 1.4. 父子进程

TODO:

当通过 fork 创建了一个子进程时，子进程会继承父进程的包括（不限于）以下内容：
- 环境 (environment)
- 堆栈
- 内存
- 打开的文件资源 (Data)
- 信号 (signal) 控制设定
- nice 值
- 进程组号
- 当前工作目录
- 控制终端

不会继承父进程的以下内容：
- 进程号和父进程号
- 锁定内存 (memory locks)
- 在 tms 结构中的系统时间
- 阻塞信号集
- 由 timer_create 函数创建的计时器
- 异步输入和输出

## 2. 轻量级进程

## 3. 线程

### 3.1. 线程演变

TODO:

在操作系统设计上，从进程演化出线程，最主要的目的就是更好的支持对称多处理机以及减小进程和线程的上下文切换开销。

### 3.2. 线程模型

在一个线程中拥有一个程序计数器（记录着要执行哪一条指令）、寄存器（保存线程当前的工作变量）以及堆栈（记录执行历史）。

多个线程共享一个进程的地址空间。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/13/26ec09ee39f7a8db1d013e7b5cca3b34.jpg)

**哪些东西是一个线程私有的**？答案中必须包含寄存器，否则悲催：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/13/fd397bc7156a99ccac2b98bc6bfe190d.jpg)

TODO:

https://stackoverflow.com/questions/1762418/what-resources-are-shared-between-threads

共有：
- 地址空间
- 打开的文件资源 (Data)
- 全局变量 (Heap)
- 信号及信号处理程序 http://www.linuxprogrammingblog.com/all-about-linux-signals?page=11

私有：
- 程序计数器
- 寄存器
- 调用栈 (Call Stack)
  > Threads share all segments except the stack. Threads have independent call stacks, however the memory in other thread stacks is still accessible and in theory you could hold a pointer to memory in some other thread's local stack frame.
- 状态

### 3.3. 线程实现

线程是比进程更加轻量的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件 I/O 等），又可以独立调度。

实现线程主要有 3 种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。

#### 3.3.1. 内核级线程

内核线程 (Kernel-Level Thread, KLT) 是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器 Scheduler 对线程进行调度，并负责将线程的任何映射到各个 CPU 上。从而使得操作系统有能力同时处理多个事务，支持多线程的内核称为多线程内核 (Multi-Threads Kernel)。

在实际应用中，程序一般不会直接使用 KLT，而是使用 KLT 的抽象接口 --**轻量级进程 (Light Weight Process, LWP)**。轻量级进程是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个进程有一个或多个 LWP，每个 LWP 由一个内核线程支持。
- 与线程相比：每一个 LWP 都有自己的进程标识符，并与一个特定的内核线程关联。在内核线程的支持下，LWP 是一个独立的调度单元，**只能由内核管理并像普通进程一样被调度**。
- 与普通进程相比：LWP 只有一个最小的执行上下文和调度程序所需的统计信息，并且与其他进程共享所有（或大部分）它的逻辑地址空间和系统资源。

事实上，LWP 就是我们通常意义上的线程，由于每个 LWP 都由一个内核线程支持，因此只有支持内核线程的操作系统，才能支持轻量级进程。

这种轻量级进程与内核线程之间 1:1 的关系称为一对一线程模型：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/30/d636ec2d3f77ccf8a9906fc06580cda7.jpg)

优点：
- 由于内核线程的支持，每个 LWP 都称为一个独立的调度单元，即使有一个 LWP 在系统调用中阻塞了，也不会影响整个进程继续工作。

缺点：
- 由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中来回切换。
- 其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。

Linux 内核是支持 LWP 的典型例子，实际上 Linux 内核也只提供了轻量级进程的支持（没有内核线程和用户级线程的支持），虽限制了更高效的线程模型的实现，但 Linux 着重优化了进程的调度开销，一定程度上也弥补了这一缺陷。目前最流行的线程机制 LinuxThreads 所采用的就是一对一线程模型，将 CPU 资源调度交给内核态，而在用户态实现一个包括信号处理在内的线程管理机制。

#### 3.3.2. 用户级线程

从广义上看，一个线程只要不是内核线程，就可以认为是用户线程（从这个意义上看，LWP 也属于用户线程）。

从狭义上看，用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。这种进程与用户线程之间 1:N 的关系称为一对多线程模型。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/30/02a3cd9f98b0248c3f7dad3a5706d26b.jpg)

优点：
- 如果程序实现得当，用户现场不需要切换到内核态，因此操作可以是非常快速且低消耗的，也因此可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。

缺点：
- 用户线程的创建、切换和调度都需要开发者自己实现，且由于操作系统只把 CPU 资源分配到进程，诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其它处理器上”这类问题处理起来将会异常困难，因而使用用户线程实现的程序一般都会比较复杂。

这种用户级线程实际上只需要完成线程运行栈的切换，调度开销非常小，但由于核心信号（无论是同步的还是异步的）都是以进程为单位的，因而无法定位到线程，所以这种实现方式不能用于多处理器系统，而这个需求正变得越来越大。因此，在实际应用中，除了算法研究目的以及在不支持多线程的操作系统（如 DOS）中的多线程程序外，纯用户级线程的实现已经逐渐消失了，Java、Ruby 等语言都曾经使用用户线程作为线程的实现，但最终都又放弃使用它。

#### 3.3.3. 混合型线程

除了依赖于内核线程实现和完全由用户程序在用户态中实现线程，还有一种将内核线程与用户线程混合实现的方式。**在这种混合实现下，既存在用户线程，也存在轻量级进程，用户线程与轻量级进程的映射数量比是不确定的**。

在这种混合模式下，用户线程与轻量级进程的数量比是不确定的，即 N:M，这样的关系称为多对多线程模型。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/31/9b34b10991ae9051204c254ea8a2dc7d.jpg)

优点：
- 由于用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。
- 操作系统提供的轻量级进程则作为用户线程和内核线程之间的桥梁，这样就可以使用内核提供的线程调度功能及处理器映射而无需由程序员实现。
- 用户线程的系统调用需要通过轻量级进程来完成，大大降低了整个进程被阻塞的风险。

正如很多技术一样，“混合”通常都能带来更高的效率，但同时也带来更大的实现难度，出于”简单”的设计思路，Linux 从一开始就没有实现混合模型的计划。

### 3.4. POSIX 线程

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/7/13/2c5dd8d5f3bd2ba65dda83221aae7605.jpg)

#### 3.4.1. POSIX 线程演变

TODO: [Linux 下调用 pthread 库创建的线程是属于用户级线程还是内核级？](https://www.zhihu.com/question/35128513)

#### 3.4.2. pthread 库使用

## 4. 多线程和多进程的区别

TODO:

多线程和多进程的区别（重点 面试官最最关心的一个问题，必须从 cpu 调度，上下文切换，数据共享，多核 cpu 利用率，资源占用，等等各方面回答）

## 5. 并发优化

TODO:

http://blog.51cto.com/casey/1740987

https://www.zhihu.com/question/24465233

多并发又可以分为 CPU 密集型和 IO 密集型。

（1）CPU 密集型即需要非常多的 CPU 计算资源，如有多颗 CPU 核心，可以让每一颗 CPU 都参与计算，从而不浪费服务器资源，CPU 密集型的典型例子，例如文件排序、图形搜索、动态规划等需要复杂的科学计算的情况，CPU 密集型需要减少线程数，减少线程的上下文切换导致的资源损耗。

（2）IO 密集型即需要大量的数据读写，例如网络传输、数据库读写等，大部分的网站、企业应用系统都属于 IO 密集型，当发生 IO 读写的时候，由于 IO 操作时间很长（受限于硬盘的读写速度和网络传输速度），线程会处于等待状态，此时 CPU 空闲，这时 CPU 可以调度其他线程进行处理，IO 密集型需要增加线程数，这样在 IO 处理的时候，可以去做其他事情，以提高并发量。

对于多并发，目前主要采用多进程和多线程两种模式，例如一台服务器上有多个应用服务器，然后多个应用服务器接收多个线程并发执行，因为线程之间的切换也有成本，所以也有观点认为应该采用多进程的模式。总之，进程数和线程数应该要根据实际情况进行综合选择。

那么，到底启动多少线程合适呢？根据以上分析，线程数应该和 CPU 核心数量成正比，而和 IO 阻塞时间成反比，因此有两个公式可供参考：

（1）线程数 = [ 任务执行时间 /（任务执行时间 -IO 等待时间) ] * CPU 内核数

（2）线程数 = CPU 核心数 /(1- 阻塞系数)

   这个阻塞系数一般为 0.8~0.9 之间，也可以取 0.8 或者 0.9。

如果是 CPU 密集型，则线程数不超过 CPU 内核，如果是 IO 密集型，则应该增加线程数，提高并发量。

当发现系统运行慢的时候，不是盲目去加 CPU 加内存或者加硬盘，应该充分了解系统资源的使用情况，从而决定如何升级系统配置，例如在 Linux 环境下用 TOP 指令观察 CPU、硬盘的使用情况：
```
Tasks: 29 total, 1 running, 28 sleeping,0 stopped, 0 zombie
Cpu(s): 0.3% us, 1.0% sy, 0.0% ni, 98.7%id, 0.0% wa, 0.0% hi, 0.0% si
```

0.3% us 反应 CPU 使用情况，0.0% wa 则大致体现出当前的磁盘 io 请求是否频繁。如果 wa 的数量比较大，说明等待输入输出的的 io 比较多，另外还可以通过交互命令 H 了解各个线程对 CPU 的使用情况。

在 Mysql 中还可以通过 `SHOW PROCESSLIST` 命令查看高导致磁盘频繁读写的查询语句。

## 6. Refer Links

[线程的 3 种实现方式 -- 内核级线程，用户级线程和混合型线程](https://blog.csdn.net/gatieme/article/details/51892437)

[Linux 下调用 pthread 库创建的线程是属于用户级线程还是内核级？](https://www.zhihu.com/question/35128513)
