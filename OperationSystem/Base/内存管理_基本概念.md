- [内存管理：基本概念](#内存管理基本概念)
  - [1. 分层存储器体系 (Memory Hierarchy)](#1-分层存储器体系-memory-hierarchy)
  - [2. 存储管理器](#2-存储管理器)
  - [3. 存储器抽象](#3-存储器抽象)
    - [3.1. 无存储器抽象（直接访问物理内存）](#31-无存储器抽象直接访问物理内存)
    - [3.2. 地址空间抽象](#32-地址空间抽象)
      - [3.2.1. 基本概念](#321-基本概念)
      - [3.2.2. 交换技术](#322-交换技术)
      - [3.2.3. 虚拟内存技术](#323-虚拟内存技术)
  - [4. Refer Links](#4-refer-links)

# 内存管理：基本概念

## 1. 分层存储器体系 (Memory Hierarchy)

在分层存储器体系中，计算机有若干兆 (MB) 快速、昂贵且易失的高速缓存 (cache)，数千兆 (GB) 速度与价格适中且同样易失的内存，以及几兆兆 (TB) 低速、廉价、非易失的磁盘存储，除此之外还有一些可移动存储设备（如 DVD 和 USB 等）。

## 2. 存储管理器

操作系统在分层存储器体系中的任务是将这个存储体系抽象为一个有用的模型并管理这个抽象模型，其中，操作系统管理分层存储器体系的部分称为存储管理器 (Memory Manager)。

存储管理器的任务是有效地管理内存，即记录哪些内存是正在使用的，哪些内存是空闲的；在进程需要时为其分配内存，在进程使用完后释放内存。

## 3. 存储器抽象

### 3.1. 无存储器抽象（直接访问物理内存）

- 优点

  

- 缺点

  把物理地址暴露给进程会带来下面几个严重问题：

  - 如果用户程序可以寻址内存的每个字节，用户就可以轻易地（偶然或刻意地）破坏操作系统，从而使操作系统慢慢地停止运行（除非有特殊的硬件进行保护，如 IBM 360 的锁键模式）。
  - 在这种模型下，系统没有对物理内存进行抽象，因此进行多道程序设计是非常困难的。

### 3.2. 地址空间抽象

地址空间是一个进程可用于寻址内存的一套地址集合，每个进程都有一个自己的地址空间，并且这个地址空间独立于其它进程的地址空间（除了在一些特殊情况下进程需要共享它们的地址空间外）。

#### 3.2.1. 基本概念

  todo:

  ![image](http://img.cdn.firejq.com/jpg/2018/7/13/7685b9572ba47ef3f8bb3a580367ad9e.jpg)

  https://www.cnblogs.com/jijiji/p/4857356.html

  - 虚拟内存 / 逻辑内存 / 地址空间
  - 物理内存 / 物理空间

  - 交换内存

#### 3.2.2. 交换技术

#### 3.2.3. 虚拟内存技术

![image](http://img.cdn.firejq.com/jpg/2018/7/25/56cdcf0e5ea5b7a8d6e51e235a829660.jpg)

http://blog.codinglabs.org/articles/a-malloc-tutorial.html#21-linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86

为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时，都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片 2^N 字节的内存，其中 N 是机器位数。例如在 64 位 CPU 和 64 位操作系统下，每个进程的虚拟地址空间为 2^64 Byte。

这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。

由于在机器语言层面都是采用虚拟地址，**当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫 MMU（Memory Management Unit）的硬件完成**。

## 4. Refer Links

