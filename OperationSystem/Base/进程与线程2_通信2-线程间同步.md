- [进程与线程：线程间同步](#进程与线程线程间同步)
  - [1. POSIX 无名信号量](#1-posix-无名信号量)
  - [2. 锁机制](#2-锁机制)
    - [2.1. 互斥锁 (Mutex)](#21-互斥锁-mutex)
    - [2.2. 条件变量](#22-条件变量)
    - [2.3. 读写锁](#23-读写锁)
    - [2.4. 自旋锁](#24-自旋锁)
  - [3. 栅栏 (Barrier)](#3-栅栏-barrier)
  - [5. Refer Links](#5-refer-links)

# 进程与线程：线程间同步

同一个进程的多个线程在同一个地址空间，通信是很容易的事情，因此多线程间只要同步就好了。

- 竞争条件

- 临界区

  ![image](http://img.cdn.firejq.com/jpg/2018/7/13/6368e050a281db2072fc613c3e09e046.jpg)

  ![image](http://img.cdn.firejq.com/jpg/2018/7/13/456fd391a22be00559e33d206945000e.jpg)

  ![image](http://img.cdn.firejq.com/jpg/2018/7/13/1dc2659fbd13efb3cec8760dce1608bb.jpg)

## 1. POSIX 无名信号量

POSIX 的无名信号量一般用于线程同步，无名信号量是进程持续的，无名信号量的 api 为：sem_init、sem_destroy。

## 2. 锁机制

### 2.1. 互斥锁 (Mutex)

提供了以排它方式阻止数据结构被并发修改的方法。

P.S. **如果将 mutex 放在共享内存里，当然可以实现进程间同步，但只能说明“共享内存是进程间通讯的手段”，不能说明 mutex 是进程间通讯的手段**。

### 2.2. 条件变量

可以以原子的方式阻塞进程，直到某个特定条件为真为止。

对条件测试是在互斥锁的保护下进行的，因此**条件变量始终与互斥锁一起使用**。

### 2.3. 读写锁

允许多个线程同时读共享数据，而对写操作互斥。

### 2.4. 自旋锁

## 3. 栅栏 (Barrier)

## 5. Refer Links
