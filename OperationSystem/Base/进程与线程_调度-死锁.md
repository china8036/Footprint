- [进程与线程：死锁](#进程与线程死锁)
  - [1. 基本概念](#1-基本概念)
  - [2. 发生条件](#2-发生条件)
  - [3. 死锁检测](#3-死锁检测)
  - [5. 死锁避免](#5-死锁避免)
    - [5.1. 资源轨迹图](#51-资源轨迹图)
    - [5.2. 银行家算法](#52-银行家算法)
  - [6. 死锁预防](#6-死锁预防)
  - [4. 死锁恢复](#4-死锁恢复)
  - [7. Refer Links](#7-refer-links)

# 进程与线程：死锁

## 1. 基本概念

如果一个进程集合中的每个进程，都在等待只能由进程集合中的其它进程才能引发的事件，那么，该进程集合就是死锁的。

## 2. 发生条件

1971 年 Coffman 等人总结出了发生（资源）死锁的 4 个必要条件：
- 对于资源
  - 互斥 (Mutual exclusion)：每个资源要么已经分配给了一个进程，要么就是可用的。、
  - 不可抢占 (No pre-emption)：已经被分配给某个进程的资源不能被强制的抢占，只能由占有它的进程显式的释放。

- 对于进程
  - 占有和等待 (Hold and wait)：已经拥有了某个资源的进程还可以请求新的资源。
  - 环路等待 (Circular wait)：死锁发生时，系统中一定有由 2 个或 2 个以上进程组成的一条环路，环路中的每个进程都在等待下一个进程所占有的资源。 

**死锁发生时，以上 4 个条件必定是同时被满足的。如果任意一个不成立，死锁就不会发生**。

## 3. 死锁检测

## 5. 死锁避免

### 5.1. 资源轨迹图

### 5.2. 银行家算法

## 6. 死锁预防

死锁避免需要预知未来的请求，因此从本质上来说是不可能的。但在实际系统中，我们可以通过破坏死锁发生的 4 个必要条件的任意一个，来预防死锁的发生。
- 破坏互斥条件
- 破坏不可抢占条件
- 破坏占有等待条件
- 破坏环路等待条件

具体措施：
- 设置加锁顺序

  例如加锁顺序是 A->B->C，现在想要线程 C 想要获取锁，那么他必须等到线程 A 和线程 B 获取锁之后才能轮到他获取（排队执行，获取锁）。

  - 缺点：按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁，并知道他们之间获取锁的顺序是什么样的。

- 设置加锁时限

  若一个线程在一定的时间里没有成功的获取到锁，则会进行回退并释放之前获取到的锁，然后等待一段时间后进行重试。在这段等待时间中其他线程有机会尝试获取相同的锁，这样就能保证在没有获取锁的时候继续执行比的事情。

  - 缺点：假如现在只有两个线程，这种方法可以很好的避免出现死锁。但假如有大量的线程同时去执行，大的基数让事件出现的概率变大，而线程还是等待那么长时间，多个线程的等待时间就有可能重叠，因此又会出现竞争超时，由于他们的超时发生时间正好赶在了一起，而超时等待的时间又是一致的，那么他们下一次又会竞争，等待，这就又出现了死锁。

- 设置线程优先级

  发生死锁时使优先级较低的线程回退，其余的线程继续保持着他们获取的锁。

- 避免使用锁

  使用 Lock-free 无锁数据结构、消息队列、管道等。

## 4. 死锁恢复

- 利用抢占恢复
- 利用回滚恢复
- 杀死进程恢复

## 7. Refer Links

[避免死锁](http://ifeve.com/deadlock-prevention/)

[编程可以避免死锁吗，怎样做到？](https://www.zhihu.com/question/29268623)