- [进程与线程](#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B)
  - [1. 进程](#1-%E8%BF%9B%E7%A8%8B)
  - [2. 轻量级进程](#2-%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B)
  - [3. 线程](#3-%E7%BA%BF%E7%A8%8B)
    - [3.1. 线程的演变](#31-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%BC%94%E5%8F%98)
    - [3.2. 线程的实现](#32-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0)
      - [3.2.1. 内核级线程](#321-%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B)
      - [3.2.2. 用户级线程](#322-%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B)
      - [3.2.3. 混合型线程](#323-%E6%B7%B7%E5%90%88%E5%9E%8B%E7%BA%BF%E7%A8%8B)
    - [3.3. POSIX线程的演变](#33-posix%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%BC%94%E5%8F%98)
  - [4. Refer Links](#4-refer-links)

# 进程与线程

## 1. 进程

## 2. 轻量级进程

## 3. 线程

### 3.1. 线程的演变

在操作系统设计上，从进程演化出线程，最主要的目的就是更好的支持对称多处理机以及减小进程和线程的上下文切换开销。
TODO:

### 3.2. 线程的实现

线程是比进程更加轻量的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件 I/O 等），又可以独立调度。

实现线程主要有 3 种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。

#### 3.2.1. 内核级线程

内核线程 (Kernel-Level Thread, KLT) 是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器 Scheduler 对线程进行调度，并负责将线程的任何映射到各个 CPU 上。从而使得操作系统有能力同时处理多个事务，支持多线程的内核称为多线程内核 (Multi-Threads Kernel)。

在实际应用中，程序一般不会直接使用 KLT，而是使用 KLT 的抽象接口 --**轻量级进程 (Light Weight Process, LWP)**。轻量级进程是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个进程有一个或多个 LWP，每个 LWP 由一个内核线程支持。
- 与线程相比：每一个 LWP 都有自己的进程标识符，并与一个特定的内核线程关联。在内核线程的支持下，LWP 是一个独立的调度单元，**只能由内核管理并像普通进程一样被调度**。
- 与普通进程相比：LWP 只有一个最小的执行上下文和调度程序所需的统计信息，并且与其他进程共享所有（或大部分）它的逻辑地址空间和系统资源。

事实上，LWP 就是我们通常意义上的线程，由于每个 LWP 都由一个内核线程支持，因此只有支持内核线程的操作系统，才能支持轻量级进程。

这种轻量级进程与内核线程之间 1:1 的关系称为一对一线程模型：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/30/d636ec2d3f77ccf8a9906fc06580cda7.jpg)

优点：
- 由于内核线程的支持，每个 LWP 都称为一个独立的调度单元，即时由一个 LWP 在系统调用中阻塞了，也不会影响整个进程继续工作。

缺点：
- 由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中来回切换。
- 其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。

Linux 内核是支持 LWP 的典型例子，实际上 Linux 内核也只提供了轻量级进程的支持（没有内核线程和用户级线程的支持），虽限制了更高效的线程模型的实现，但 Linux 着重优化了进程的调度开销，一定程度上也弥补了这一缺陷。目前最流行的线程机制 LinuxThreads 所采用的就是一对一线程模型，将 CPU 资源调度交给内核态，而在用户态实现一个包括信号处理在内的线程管理机制。

#### 3.2.2. 用户级线程

从广义上看，一个线程只要不是内核线程，就可以认为是用户线程（从这个意义上看，LWP 也属于用户线程）。

从狭义上看，用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。这种进程与用户线程之间 1:N 的关系称为一对多线程模型。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/30/02a3cd9f98b0248c3f7dad3a5706d26b.jpg)

优点：
- 如果程序实现得当，用户现场不需要切换到内核态，因此操作可以是非常快速且低消耗的，也因此可以支持规模更大的线程数量，部分高性能数据库中的多线程就算由用户线程实现的。

缺点：
- 用户线程的创建、切换和调度都需要开发者自己实现，且由于操作系统只把 CPU 资源分配到进程，诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其它处理器上”这类问题处理起来将会异常困难，因而使用用户线程实现的程序一般都会比较复杂。

这种用户级线程实际上只需要完成线程运行栈的切换，调度开销非常小，但由于核心信号（无论是同步的还是异步的）都是以进程为单位的，因而无法定位到线程，所以这种实现方式不能用于多处理器系统，而这个需求正变得越来越大。因此，在实际应用中，除了算法研究目的以及在不支持多线程的操作系统（如 DOS）中的多线程程序外，纯用户级线程的实现已经逐渐消失了，Java、Ruby 等语言都曾经使用用户线程作为线程的实现，但最终都又放弃使用它。

#### 3.2.3. 混合型线程

除了依赖于内核线程实现和完全由用户程序在用户态中实现线程，还有一种将内核线程与用户线程混合实现的方式。**在这种混合实现下，既存在用户线程，也存在轻量级进程，用户线程与轻量级进程的映射数量比是不确定的**。

在这种混合模式下，用户线程与轻量级进程的数量比是不确定的，即 N:M，这样的关系称为多对多线程模型。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/31/9b34b10991ae9051204c254ea8a2dc7d.jpg)

优点：
- 由于用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。
- 操作系统提供的轻量级进程则作为用户线程和内核线程之间的桥梁，这样就可以使用内核提供的线程调度功能及处理器映射而无需由程序员实现。
- 用户线程的系统调用需要通过轻量级进程来完全，大大降低了整个进程被阻塞的风险。

正如很多技术一样，“混合”通常都能带来更高的效率，但同时也带来更大的实现难度，出于”简单”的设计思路，Linux 从一开始就没有实现混合模型的计划。


### 3.3. POSIX线程的演变

TODO: [Linux 下调用 pthread 库创建的线程是属于用户级线程还是内核级？](https://www.zhihu.com/question/35128513)



## 4. Refer Links

[线程的 3 种实现方式 -- 内核级线程，用户级线程和混合型线程](https://blog.csdn.net/gatieme/article/details/51892437)

[Linux 下调用 pthread 库创建的线程是属于用户级线程还是内核级？](https://www.zhihu.com/question/35128513)