- [在数据库中存储树形结构数据](#%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%82%A8%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE)
  - [1. 应用场景](#1-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)
  - [2. 关系型数据库](#2-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93)
    - [2.1. Adjacency List 邻接表法](#21-adjacency-list-%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95)
    - [2.2. Path Enumerations 路径枚举法](#22-path-enumerations-%E8%B7%AF%E5%BE%84%E6%9E%9A%E4%B8%BE%E6%B3%95)
    - [2.3. 左右值编码法](#23-%E5%B7%A6%E5%8F%B3%E5%80%BC%E7%BC%96%E7%A0%81%E6%B3%95)
    - [2.4. Nested Sets 嵌套集法](#24-nested-sets-%E5%B5%8C%E5%A5%97%E9%9B%86%E6%B3%95)
    - [2.5. Closure Table 闭包表法](#25-closure-table-%E9%97%AD%E5%8C%85%E8%A1%A8%E6%B3%95)
    - [2.6. 比较](#26-%E6%AF%94%E8%BE%83)
  - [3. 文档型数据库](#3-%E6%96%87%E6%A1%A3%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93)

# 在数据库中存储树形结构数据

## 1. 应用场景

- 家谱管理系统；

- 限层评论系统：每一个主题（节点）可以有 n 个留言（子节点）。这些留言又可以有自己的留言；

## 2. 关系型数据库

对于关系型数据库，一般比较普遍的是以下四种方法：（具体见《SQL Anti-patterns》）

### 2.1. Adjacency List 邻接表法

https://www.biaodianfu.com/adjacency-list.html 

每一条记录存 parent_id，优点是简单，缺点是访问子树需要遍历，发出许多条 SQL，对数据库压力大。

查询某一个节点的直接子节点
```sql
select * from tree1 where parentid=4
```
在 id=4 节点下，插入一个直接子节点
```sql
INSERT INTO tree1 (value,parentid) VALUES('M',4)
```
这种结构在查找某个节点的所有子节点，就稍显复杂，无论是 SELECT 还是 DELETE 都可能涉及到获取所有子节点的问题。比如要删除一个节点并且该节点的子节点也要全部删除，那么首先要获得所有子节点的 ID，因为子节点并不只是直接子节点，还可能包含子节点的子节点。比如删除 D 节点及其子节点，必须先查出 D 节点下的所有子节点，然后再做删除，SQL 如下：
```sql
select nodeid from tree1 where parentid=4 -- 返回 8,9
select nodeid from tree1 where parentid in (8,9) -- 返回 10,11,12
select nodeid from tree1 where parentid in (10,11,12) -- 返回空
delete from tree1 where nodeid in (4,8,9,10,11,12)
```
如果是只删除 D 节点，对于其它节点不做删除而是做提升，那么必须先修改子节点的 parentid，然后才能删除 D 节点。

### 2.2. Path Enumerations 路径枚举法

https://www.biaodianfu.com/path-enumeration.html 

每一条记录存整个 tree path 经过的 node 枚举，优点是查询方便，缺点是插入新记录时要手工更改此节点以下所有路径，很容易出错；并且 path 字段的长度是有限的，这意味着，不能无限制的增加节点深度，只适用于存储小型的树结构。

例：
```
├── a
│   ├── d
│   │   ├── p
│   │   ├── q
│   │   └── r
│   ├── e
│   └── f
├── b
│   ├── x
│   ├── y
│   └── z
├── c
```
对应的数据库表值为：
```
| id | value | parent_id | key   | level |                                
| 1  | a     | 0         | "-"    | 1     |
| 2  | b     | 0         | "-"    | 1     |
| 3  | c     | 0         | "-"    | 2     |
| 4  | d     | 1         | "1-"   | 2     |
| 5  | e     | 1         | "1-"   | 2     |
| 6  | f     | 1         | "1-"   | 2     |
| 7  | x     | 2         | "2-"   | 2     |
| 8  | y     | 2         | "2-"   | 2     |
| 9  | z     | 2         | "2-"   | 2     |
| 10 | p     | 4         | "1-4-" | 3     |
| 11 | q     | 4         | "1-4-" | 3     |
| 12 | r     | 4         | "1-4-" | 3     |
```

如果要查询某个节点下的子节点，只需要根据 path 的路径去匹配，比如要查询 D 节点下的所有子节点。
```sql
select * from tree2 where path like '%/4/%'
```
或者出于效率考虑，直接写成
```sql
select * from tree2 where path like '1/4/%'
```

### 2.3. 左右值编码法

https://www.biaodianfu.com/the-nested-set-model.html 

### 2.4. Nested Sets 嵌套集法

https://www.biaodianfu.com/nested-intervals.html 

每一条记录存 nleft 和 nright，缺点是复杂难操作。

（前提必须是二叉树）http://blog.csdn.net/monkey_d_meng/article/details/6647488 

（可以将任何树转换位二叉树）https://www.cnblogs.com/honghuamin/archive/2011/07/24/2115635.html 

### 2.5. Closure Table 闭包表法

https://www.biaodianfu.com/closure-table.html

维护一个表，所有的 tree path 作为记录进行保存。优点是查询效率最高；缺点是占用空间大，操作不直观；

空间换时间的方式；

能明晰任意两结点关系而无须多余查询，级联删除和结点移动也很方便。但是它的存储开销会大一些，除了表示结点的 Meta 信息，还需要一张专用的关系表；

例：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/3/14e30e826eb0a03113cbf5d93a88916e.jpg)

数据库中：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/3/fcbeebb313ee3bbcf521867dc280d7c1.jpg)

查询 D 节点的子元素
```sql
select * from NodeRelation where ancestor=4;
```
查询节点 D 的直接子节点
```sql
select * from NodeRelation where ancestor=4 and depth=1;
```
查询节点 J 的所有父节点
```sql
select * from NodeRelation where descendant=10;
```
	
存进数据库
```cpp
bool GenealogyManagerSystem::insertTreeToDb(treeNode * root) {
	//treeNode * cur = root;
	
	stack<treeNode *> myStack;
	myStack.push(root);
	
	while (!myStack.empty()) {
		treeNode * cur = myStack.top();
		myStack.pop();

		if (cur->nextBrother != NULL) {
			myStack.push(cur->nextBrother);
		}
		if (cur->firstChild != NULL) {
			myStack.push(cur->firstChild);
		}

		//cout << cur->id << endl;
		//vist the node

		stack<treeNode *> tmpStack;
		this->db->addToTree(cur->id, cur->id, 0, cur->distance);
		if (cur->firstChild != NULL) {
			tmpStack.push(cur->firstChild);
		}
		while (!tmpStack.empty()) {
			treeNode * tmp = tmpStack.top();
			tmpStack.pop();

			if (tmp->nextBrother != NULL) {
				tmpStack.push(tmp->nextBrother);
			}
			if (tmp->firstChild != NULL) {
				tmpStack.push(tmp->firstChild);
			}
			this->db->addToTree(cur->id, tmp->id, tmp->distance - cur->distance, tmp->distance);
			// bool mySqlite::addToTree(int ancestorId, int descendantId, int distance, int absDistance)
		}
	}

}
```

从数据库中还原
```cpp
void GenealogyManagerSystem::buildTreeFromDb() {
	vector<Person *> people = this->db->selectFromPerson();
	for (int i = 0; i < people.size(); i++) {
		//cout << "id = " << people.at(i)->getId() << " name = " << people.at(i)->getName() << endl;
		string absDistance = this->db->selectFromTree("abs_distance", "`descendant_id` = " + int2string(people.at(i)->getId()))[0];
		// 若该节点未注册
		if (this->GenealogyTree->getNodes().find(int2string(people.at(i)->getId())) == this->GenealogyTree->getNodes().end()) {
			treeNode * node = new treeNode;
			node->id = people.at(i)->getId();
			node->distance = atoi(absDistance.data());
			node->name = people.at(i)->getName();
			if (node->id == 1) {
				this->GenealogyTree->setRoot(node);
			}
			// 在节点 map 中注册该节点
			this->GenealogyTree->getNodes()[int2string(node->id)] = node;
		}

		// 从 tree 表中获取 firstChild 的 id
		vector<string> res = this->db->selectFromTree("descendant_id", "`ancestor_id` = " + int2string(people.at(i)->getId()) + " AND `distance` = 1");
		if (!res.empty()) {
			string childId = res[0];
			//cout << "childId：" << childId << endl;
			// 若该 ID 的节点未注册
			if (this->GenealogyTree->getNodes().find(childId) == this->GenealogyTree->getNodes().end()) {
				treeNode * childNode = new treeNode;
				string absChildDistance = this->db->selectFromTree("abs_distance", "`descendant_id` = " + childId)[0];
				childNode->id = atoi(childId.data());
				childNode->distance = atoi(absChildDistance.data());
				childNode->name = this->db->selectFromPerson(atoi(childId.data()))[0]->getName();
				// 在节点 map 中注册该节点
				this->GenealogyTree->getNodes()[childId] = childNode;
			}
			// 设置 firstChild 指针
			this->GenealogyTree->getNodes()[int2string(people.at(i)->getId())]->firstChild = this->GenealogyTree->getNodes()[childId];
		}

		// 从 tree 表中获取 nextBrother 的 id
		string nextBrotherId = "";
		if (absDistance != "0") {
			string pId = this->db->selectFromTree("ancestor_id", "`descendant_id` = " + int2string(people.at(i)->getId()) + " AND `distance` = 1")[0];
			//cout << "pId:" << pId << endl;
			vector<string> brotherIds = this->db->selectFromTree("descendant_id", "`abs_distance` = " + absDistance + " AND `ancestor_id` = " + pId);
			if (!brotherIds.empty()) {
				for (int j = 0; j < brotherIds.size(); j++) {
					//cout << brotherIds[j] << endl;
					if (brotherIds[j] == int2string(people.at(i)->getId()) && j + 1 < brotherIds.size()) {
						string nextId = brotherIds[j + 1];
						vector<string> res = this->db->selectFromTree("abs_distance", "`descendant_id` = " + nextId);
						if (!res.empty() && res[0] == absDistance) {
							nextBrotherId = nextId;
						}
						break;
					}
				}
				//cout << "nextBrotherId:" << nextBrotherId << endl;
				if (nextBrotherId != "") {
					// 若该 ID 的节点未注册
					if (this->GenealogyTree->getNodes().find(nextBrotherId) == this->GenealogyTree->getNodes().end()) {
						treeNode * nextBrotherNode = new treeNode;
						string absBroDistance = this->db->selectFromTree("abs_distance", "`descendant_id` = " + nextBrotherId)[0];
						nextBrotherNode->id = atoi(nextBrotherId.data());
						nextBrotherNode->distance = atoi(absBroDistance.data());
						nextBrotherNode->name = this->db->selectFromPerson(atoi(nextBrotherId.data()))[0]->getName();
						// 在节点 map 中注册该节点
						this->GenealogyTree->getNodes()[nextBrotherId] = nextBrotherNode;
					}
					// 设置 nextBrother 指针
					this->GenealogyTree->getNodes()[int2string(people.at(i)->getId())]->nextBrother = this->GenealogyTree->getNodes()[nextBrotherId];
				} else {
					this->GenealogyTree->getNodes()[int2string(people.at(i)->getId())]->nextBrother = NULL;
				}

			}
		} else {
			this->GenealogyTree->getNodes()[int2string(people.at(i)->getId())]->nextBrother = NULL;
		}

	}

}
```

### 2.6. 比较

各种方法的常用操作代价见下图：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/3/547ba568157d662e1ee6c6ae969cc432.jpg)

## 3. 文档型数据库

关系型数据库和文档型数据库存储树结构设计模式的比较：https://www.cnblogs.com/huangfox/archive/2012/04/11/2442408.html 
