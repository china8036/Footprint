- [数据库：索引](#数据库索引)
  - [1. 基本概念](#1-基本概念)
    - [1.1. 基本原理](#11-基本原理)
    - [1.2. 优缺点](#12-优缺点)
  - [2. 适用场景](#2-适用场景)
    - [2.1. 适用情况](#21-适用情况)
    - [2.2. 不适用情况](#22-不适用情况)
  - [3. 性能因素](#3-性能因素)
  - [4. 顺序索引](#4-顺序索引)
    - [4.1. 基础概念](#41-基础概念)
      - [4.1.1. 搜索码](#411-搜索码)
      - [4.1.2. 聚集索引 / 主索引 (clustered index) & 非聚集索引 (non-clustered index)](#412-聚集索引--主索引-clustered-index--非聚集索引-non-clustered-index)
      - [4.1.3. 稠密索引 & 稀疏索引](#413-稠密索引--稀疏索引)
      - [4.1.4. 多级索引](#414-多级索引)
      - [4.1.5. 普通索引 / 单列索引 & 多列索引 / 复合索引](#415-普通索引--单列索引--多列索引--复合索引)
    - [4.2. 顺序组织实现](#42-顺序组织实现)
    - [4.3. BTree 实现](#43-btree-实现)
      - [4.3.1. MyISAM 引擎实现](#431-myisam-引擎实现)
      - [4.3.2. InnoDB 引擎实现](#432-innodb-引擎实现)
      - [4.3.3. 最左前缀原则](#433-最左前缀原则)
        - [4.3.3.1. 基本原理](#4331-基本原理)
        - [4.3.3.2. 实例分析](#4332-实例分析)
      - [4.3.4. 常见问题](#434-常见问题)
  - [5. Hash 索引](#5-hash-索引)
  - [6. 位图索引](#6-位图索引)
  - [7. R-Tree 索引](#7-r-tree-索引)
  - [8. Full-text 索引](#8-full-text-索引)
  - [9. Refer Links](#9-refer-links)

# 数据库：索引

## 1. 基本概念

[维基百科](https://en.wikipedia.org/wiki/Database_index):
> 数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。

[百度百科](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95/5716853):
> 在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。

### 1.1. 基本原理

索引在数据库中的工作角色，就类似于一本书中“目录“的角色，如果想在整本书中找到某一个特定的主题，可以对整本书进行遍历，一页一页的查找，但如果先在目录中查找，找到该主题对应的页码，便可以直接快速的找到该主题的位置。

- 在没有索引的情况下，查询操作必须从第一条记录开始然后读完整个表直到找出所有匹配的相关行，表越大，花费的时间越多。
- 但在查找条件有索引的情况下，执行查询操作时可以先在索引中找到匹配的对应值，然后根据匹配的索引记录直接在外存中找到实际表中所对应的记录行。

**创建索引的方法：直接创建和间接创建（在表中定义主键约束或者唯一性约束时，同时也创建了索引）**。

### 1.2. 优缺点

优点
- 索引可以减少服务器需要扫描的数据量，将随机 I/O 变为顺序 I/O，从而大大提高查询速度。
- 利用索引可以管理数据库约束，例如 UNIQUE, EXCLUSION, PRIMARY KEY 和 FOREIGN KEY 等。
- 利用索引对数据存储的特性，可以使查询语句避免排序和创建临时表。

缺点
- 创建索引和维护索引需要消耗时间，这种时间随着数量的增加而增加。
- 当对表中的数据进行增加，删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
- 索引需要占物理空间，除了数据表占据数据空间之外，每一个索引还要占一定的物理空间。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。

## 2. 适用场景

### 2.1. 适用情况

以下情况应该创建索引：
- 在作为**主键**的列上，强制该列的唯一性和组织表中数据的排列结构。
- 在经常用于**连接**的列上，这些列主要是一些外键，可以加快连接的速度。
- 在经常需要**范围查询**的列上创建索引，因为索引已经排序，其指定的范围是连续的。
- 在经常需要**排序**的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- 在经常使用在 WHERE 子句中的列上面创建索引，加快条件的判断速度。

### 2.2. 不适用情况

以下情况不适合创建索引：
- 在查询中很少使用或者作为参考的列不应该创建索引。

- 对于选择性较低的列，不应该使用索引。

  选择性 (Selectivity) 是指不重复的索引值（也叫基数，Cardinality）与表记录数 (#T) 的比值：
  > Index Selectivity = Cardinality / #T
  **显然选择性的取值范围为 (0, 1]，选择性越高的索引价值越大，这是由 B+Tree 的性质决定的。例：存放出生日期的列具有不同的值，很容易区分行，而用来记录性别的列，只有"M"和"F"，则对此进行索引没有多大用处，因为不管搜索哪个值，都会得出大约一半的行**。

- 对于记录比较少的表（可以 2000 为分界线），维护索引的成本要高于查询效率的提升，因此没有必要建索引，让查询做全表扫描就好了。

- 对于那些定义为 text，image 和 bit 数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

## 3. 性能因素

**索引是在存储引擎层中实现的，而不是在服务层实现的**。因此，对于不同存储引擎，索引没有同一的标准：不同的存储引擎的索引的工作方式不一样，所支持的索引类型也不一样；即便多个存储引擎都支持同一种类型的索引，其底层的实现原理也可能互不相同。

对于不同的索引，没有哪一种技术是最好的，只能说某种技术对特定的数据库应用是最合适的。对每种技术的评价必须基于以下因素：
- 访问类型

  能有效支持的访问类型。访问类型可以包括找到具有特定属性值的记录，以及找到属性值落在某个特定范围内的记录。

- 访问时间

  在查询中使用该技术找到一个特定数据项或数据项集所需的时间。

- 插入时间

  插入一个新数据项所需的时间。该值包括找到插入这个新数据项的正确位置所需的时间，以及更新索引结构所需的时间。

- 删除时间

  删除一个数据项所需的时间。该值包括找到待删除项所需的时间，以及更新索引结构所需的时间。

- 空间开销

  索引结构所占用的额外存储空间。若存储索引结构的额外空间大小适度，通常牺牲一定的空间代价来换取性能的提高是值得的。
  
## 4. 顺序索引

顺序索引基于值的顺序进行排序，按顺序存储搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。

顺序索引一般有顺序组织和 B-Tree 组织两种结构。

### 4.1. 基础概念

#### 4.1.1. 搜索码

用于在文件中查找记录的属性或属性集称为搜索码。如果一个文件上有多个索引，那么它就有多个搜索码。

#### 4.1.2. 聚集索引 / 主索引 (clustered index) & 非聚集索引 (non-clustered index)

一个文件中可以有多个索引，分别基于不同的搜索码。**如果包含记录的文件按照某个索引码指定的顺序排序，那么该搜索码对应的索引称为聚集索引 / 主索引**。

**搜索码指定的顺序与文件中记录的物理顺序不同的索引称为非聚集索引 / 辅助索引**。

NOTE: 主索引这个名称看上去是建立在主码上的，但实际上主索引可建立在任何搜索码上。

#### 4.1.3. 稠密索引 & 稀疏索引

在稠密索引中，文件中的每个搜索码值都有一个索引项。

在稀疏索引中，只为搜索码的某些值创建索引项。只有当关系按搜索码顺序进行存储时才能使用稀疏索引，即只有聚集索引才能使用稀疏索引。

**利用稠密索引通常可以比稀疏索引更快地定位一条记录，但稀疏索引所占空间较小，并且插入删除时所需的维护开销也较小**。因此，系统设计者必须在存取时间和空间开销之间进行权衡，通常**为每个磁盘块建立一个索引项的稀疏索引是一个较好的折中方案**。因为处理查询的开销主要取决于访问外存的时间开销，一旦将块放入主存，扫描所需的时间是少到可以忽略的。使用这样的稀疏索引，可以定位包含所要查找记录的块，只要记录不在溢出块中，就能在保存索引尽可能小的同时使访问外存的次数最少。

#### 4.1.4. 多级索引

如果索引过大导致无法放在主存中，那么当需要时就必须从磁盘中读取索引块，即便采用二分查找搜索索引项，搜索的开销依然很大。

因此，可以将原来的索引视为内层索引，并在内层索引上构造一个稀疏的外层索引。当要定位一条记录时，首先在外层索引上使用二分法找到其最大搜索码值小于或等于所需搜索码值的记录，记录指针指向一个内层索引块；再扫描这一块，直到找到其最大搜索码值小于或等于所需搜索码值得记录。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/3/e26cde05be6efd764297f3a5cdc4c483.jpg)

如果文件极其大，甚至外层索引也无法装入主存，此时可根据需要重复以上过程，在外层索引上再创建一层索引。利用多级索引搜索记录与用二分法搜索记录相比，需要的 I/O 操作要少得多。

#### 4.1.5. 普通索引 / 单列索引 & 多列索引 / 复合索引

一个搜索码可以有多个属性，一个包含多个属性的搜索码称为复合索引。复合索引的结构和普通索引的结构完全一样，唯一不同的地方在于复合索引拥有一个属性列表而不是单个属性。

**使用基于 B-Tree 的复合索引时遵循最左前缀集合，即只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用**。

对于某些类型的查询来说，使用多列索引会比使用普通索引具有更高的效率。
- 假设数据表中有字段 a、b，已创建单列索引 a 和 b。对于以下查询：
  ```sql
  SELECT * FROM `test` WHERE a = 1 AND b = 2;
  ```
  处理该查询，若利用单列索引 a/b，在最坏情况下为了得到一个很小的结果集我们必须扫描大量的记录指针。

  但若使用复合索引 (a,b)，可将查询效率提高最高。

### 4.2. 顺序组织实现

在搜索码上有聚集索引的文件称为索引顺序文件，这种组织模式针对既需顺序处理整个文件又需随机访问某个记录的应用而设计，是数据库系统中最早采用的索引模式之一。

在采用顺序组织结构的索引顺序文件中，记录按照搜索码的顺序进行存放。

顺序索引文件组织的最大缺点在于，随着文件的增大，索引查找性能和数据顺序扫描性能都会下降。这种性能往往需要通过对文件进行重新组织来弥补，但频繁地进行文件重组也需要很大的性能开销。

### 4.3. BTree 实现

BTree 索引结构是在数据插入和删除的情况下仍能保持其执行效率的索引结构，也是最常见的顺序索引实现，目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。

B- Tree 实现：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/3/36db50b90bd6cf316835c7acd8598180.jpg)

B+ Tree 实现：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/3/be8daa5fe0505f1803a227cd59aecc7d.jpg)

根据 BTree 的定义，可知检索一次最多需要访问 h 个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个 node 只需一次 I/O。

InnoDB 引擎和 MyISAM 引擎都支持 BTree 索引，但其底层实现截然不同。

#### 4.3.1. MyISAM 引擎实现

MyISAM 引擎中，BTree 索引的实现基于带有顺序访问指针的 B+ Tree，使用**非聚集索引**。

- 在 MyISAM 中，索引文件和数据文件是分离的，索引文件仅保存数据记录的地址，即通过数据的物理地址引用被索引的行，叶节点的 data 域存放的是数据记录的地址：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/3/3dfa4658ca7c3375068a263cf202a2b9.jpg)

  因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。

- 在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。

#### 4.3.2. InnoDB 引擎实现

InnoDB 引擎中，BTree 索引的实现基于带有顺序访问指针的 B+ Tree，使用**聚集索引**。

- 在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引，根据主键引用被索引的行：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/3/86c51a47297997c24c9d67ce5bb18b48.jpg)

  在 InnoDB 中，因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整形。

- 在 InnoDB 中，辅助索引 data 域存储相应记录主键的值而不是地址，即 InnoDB 的所有辅助索引都引用主键作为 data 域：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/3/59a9e621bc7c56e3a218939d5c05fc76.jpg)

  **聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引**：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

从 InnoDB 引擎中 BTree 索引的实现可见：
- 在 InnoDB 中，不应使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。

- 在 InnoDB 中，不应使用非单调的字段作为主键，因为 InnoDB 数据文件本身是一棵 B+Tree，非单调的主键每次插入主键的值近似于随机，因此会造成在插入新记录时数据文件为了维持 B+Tree 的特性而进行频繁的分裂调整，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过 OPTIMIZE TABLE 来重建表并优化填充页面。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/3/23a3f6b6ef00d80efd1047f6c1c2a376.jpg)

- 在 InnoDB 中，使用一个与业务无关的自增字段作为主键是一个最佳实践方案。如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/3/c083a793bc74b1e6ad720e9f93d5b1c6.jpg)

#### 4.3.3. 最左前缀原则

根据 BTree 索引的存储方式，在使用基于 BTree 实现的复合索引时，需要遵循最左前缀原则：
> 匹配的规则采用 b+ 树的查询原理，按照最左前缀原则进行匹配：即对查询的条件，会从等值查询 (=、IN) 一直向右匹配直到遇到范围查询 (>、<、BETWEEN、LIKE) 就停止匹配。

##### 4.3.3.1. 基本原理

- 复合索引
  
  MySQL 在创建复合索引时，实际上是对组合索引的每个列从左到右进行了多层次排序，即先将第一列排好序，再在第一列的排序基础上对第二列进行排序，依次递推到最后一列。因此，若单看某一列，除了第一列是绝对有序的，其他列都是无序的。例：对于复合索引 (a, b, c)，创建索引时会将记录根据 a->b->c 进行多级排序，因此 a 相同的值会都放在一起，而 b、c 相同的值则不会放在一起。

  例：[假设有数据表 T (a,b,c), 下表中 rowid 为物理位置](https://bbs.csdn.net/topics/390727789)
  ```
  rowid 	a b c
  (1) 	1 1 1
  (2) 	2 1 13
  (3) 	2 2 14
  (4) 	1 3 3
  (5) 	2 3 12
  (6) 	1 2 5
  (7) 	2 3 9
  (8) 	1 2 2
  (9) 	1 3 6
  (10) 	2 2 11
  (11) 	2 2 8
  (12) 	1 1 7
  (13) 	2 3 15
  (14) 	1 1 4
  (15) 	2 1 10
  ```
  当创建一个索引 `create index xxx on t(a,b)`, 则索引文件逻辑上等同于如下：
  ```
  a b rowid
  1 1 1
  1 1 12
  1 1 14
  1 2 6
  1 2 8
  1 3 4
  1 3 9
  2 1 2
  2 1 15
  2 2 3
  2 2 10
  2 2 11
  2 3 5
  2 3 7
  2 3 13
  ```
  容易看出，当执行 `select * from T where a=1 and b=3` 的时候，数据库系统可以直接从索引文件中直接二分法找到 `a=1` 的记录，然后再 `b=3` 的记录。但如果你 `where b=3` 则需要遍历这个索引表的全部。

- 单列索引

  单列索引可以看成是列数为 1 的复合索引，因此最左前缀匹配原则同样适用。

##### 4.3.3.2. 实例分析

假设有数据表字段`a, b, c, d`，同时已建立复合索引 (a,b,c,d)。

- 等值匹配 (=、IN) 
  ```sql
  SELECT * FROM tb FROM WHERE a = 1 and b = 2 and c = 3 and d = 4 
  SELECT * FROM tb FROM WHERE a = 1 and d = 4 and c = 3 and b = 2
  ```
  当按照索引中所有列进行精确匹配（“=”或“IN”）时，索引都可以被用到。
  
  需要注意的是，**索引的多级排序理论上索引对顺序是敏感的，但是由于 MySQL 的查询优化器会对等值匹配进行自动调整，即自动调整 where 子句中的条件顺序以使用适合的索引，因此即便将 where 中的条件顺序颠倒效果也是一样的**。

  ```sql
  SELECT * FROM tb FROM WHERE a = 1 -- 只用到 (a) 索引
  SELECT * FROM tb FROM WHERE a = 1 and b = 2 -- 用到 (a、b) 索引
  SELECT * FROM tb FROM WHERE a = 1 and c = 3 -- 只用到 (a) 索引
  SELECT * FROM tb FROM WHERE a = 1 and b = 2 and c = 3 -- 用到 (a、b、c) 索引
  SELECT * FROM tb FROM WHERE a = 1 and b = 2 and d = 4 -- 用到 (a、b) 索引
  SELECT * FROM tb FROM WHERE a = 1 and b = 2 and c = 3 and d = 4 -- 用到 (a、b、c、d) 索引
  ```
  上边的查询都可以使用到复合索引，但所用到的长度不同。

  ```sql
  SELECT * FROM tb FROM WHERE b = 2 
  SELECT * FROM tb FROM WHERE b = 2 and c = 3 and d = 4 
  SELECT * FROM tb FROM WHERE c = 3
  SELECT * FROM tb FROM WHERE c = 3 and d = 4 
  ```
  上边的查询都无法使用到复合索引，因为在不使用 a 索引的情况下，b、c、d 都是无序的。

- 非等值匹配 (<、<=、>、 >=、BETWEEN、LIKE)
  
  **对于 LIKE 匹配，以通配符 `%` 或 `_` 开头时无法使用索引**：
  ```sql
  SELECT * FROM tb FROM WHERE a = 1 and b LIKE '222%' -- 可以用到 (a,b) 索引
  SELECT * FROM tb FROM WHERE a = 1 and b LIKE '%222' -- 只用到 (a) 索引
  ```

  ```sql
  SELECT * FROM tb FROM WHERE a < 1 and b = 2 -- 只能用到 (a) 索引
  SELECT * FROM tb FROM WHERE a = 1 and b = 2 and c > 3 and d = 4 -- 用到 (a,b,c) 索引
  SELECT * FROM tb FROM WHERE a = 1 and b = 2 and c = 3 and d > 4 -- 用到 (a,b,c,d) 索引
  ```

  ```sql
  SELECT * FROM tb FROM WHERE a = 1 and MAX(b, 2) and c = 3 and d = 4 -- 只能用到 (a) 索引
  SELECT * FROM tb FROM WHERE a - 1 = 0 and b = 2 and c = 3 and d = 4 -- 复合索引整个都用不到
  ```
  **如果查询条件中含有函数或表达式，则 MySQL 不会为该列使用索引**。因此在写查询语句时尽量避免表达式出现在查询的 WHERE 子句中，而是先手工私下代数运算，转换为无表达式的查询语句。

#### 4.3.4. 常见问题

- 为什么使用 B/B+ 树作为索引实现而不用红黑树等其它平衡树？
  
  B-Tree 中一次检索最多需要 h-1 次 I/O（根节点常驻内存），渐进复杂度为 O(h)=O(log(d)N)。一般实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过 3）。

  而红黑树的 h 明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性原理进行磁盘预读，所以红黑树的 I/O 渐进复杂度也为 O(h)，效率明显比 B-Tree 差很多。

- 为什么使用 B+ 树实现索引比 B 树实现索引更多？

  - 内节点出度更大，读取性能更好
    
    由于 B+Tree 内节点去掉了 data 域，而出度的上限取决于节点内 key 和 data 的大小：
    > dmax = floor(pagesize / (keysize + datasize + pointsize))
    即内节点可以拥有更大的出度，而出度越大索引的性能越好，因此 B+Tree 比 B Tree 更适合外存索引。

  - 更利于区间查询

    一般在数据库系统或文件系统中使用的 B+Tree 结构都在经典 B+Tree 的基础上进行了优化，增加了顺序访问指针，即在 B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针。这个优化提高了区间访问的性能，例如要查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。

## 5. Hash 索引

基于 Hash 表实现，将值平均分布到若干个散列桶中。

**Hash 索引只支持精确查找（"=","IN"和"<=>"），不支持范围查找也不支持排序，这意味着范围查找或 ORDER BY 都要依赖服务层的额外工作**。

Hash 索引的等值检索效率非常高，索引的检索可以在 O(1) 时间内完成定位，不像 B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的 I/O 访问，所以 Hash 索引的等值查询效率要远高于 B-Tree 索引，在不需要进行范围查询的情况下，使用 Hash 索引是更好的选择。

目前只有 Memory 引擎支持显式的 Hash 索引（但是它的 Hash 是 nonunique 的，冲突太多时也会影响查找性能）。Memory 引擎默认的索引类型就是 Hash 索引，虽然它也支持 B-Tree 索引。

## 6. 位图索引

位图索引是一种为多玛上的简单查询设计的特殊索引，在其最简单的形式中，关系 r 的属性 A 上的位图索引是由 A 能取的每个值建立的位图构成的。

位图索引的一个重要应用是统计满足条件的元组数，处理时甚至可以在不访问关系的条件下从位图索引中得到所需结果完成查询。

## 7. R-Tree 索引

基于 R-Tree 实现。用于对 GIS 数据类型创建 SPATIAL 索引（空间索引）。

目前只有 MyISAM 引擎支持，并且支持的不好。

## 8. Full-text 索引

主要用于查找文本中的关键字，而不是直接与索引中的值相比较。Full-text 索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的 WHERE 语句的参数匹配。你可以对某列分别进行 full-text 索引和 B-Tree 索引，两者互不冲突。Full-text 索引配合 MATCH AGAINST 操作使用，而不是一般的 WHERE 语句加 LIKE。

InnoDB 引擎和 MyISAM 引擎都支持 Full-text 索引。  

## 9. Refer Links

[查询容易，优化不易，且写且珍惜](https://tech.meituan.com/mysql-index.html)

[索引原理讲解](https://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html)

[MySQL 有哪些索引类型 ?](https://segmentfault.com/q/1010000003832312)

[CSDN 论坛 - 为什么索引中有最左前缀原则](https://bbs.csdn.net/topics/390727789)

[MySQL 索引，最左前缀匹配的内部原理是什么？](https://www.zhihu.com/question/52536048)

[MySQL 索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

[MySQL 索引与 Index Condition Pushdown](http://blog.codinglabs.org/articles/index-condition-pushdown.html)