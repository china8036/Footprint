- [数据库：数据库规范](#数据库数据库规范)
  - [1. 命名规范](#1-命名规范)
    - [1.1. 数据库命名规范](#11-数据库命名规范)
    - [1.2. 表命名规范](#12-表命名规范)
    - [1.3. 字段命名规范](#13-字段命名规范)
  - [2. 表结构规范](#2-表结构规范)
    - [2.1. 数据类型选择](#21-数据类型选择)
    - [2.2. 主键设计方案](#22-主键设计方案)
      - [2.2.1. 主键设计要求](#221-主键设计要求)
      - [2.2.2. 主键设计原则](#222-主键设计原则)
      - [2.2.3. 自增 ID 方案](#223-自增-id-方案)
      - [2.2.4. UUID 方案](#224-uuid-方案)
      - [2.2.5. snowflake 方案](#225-snowflake-方案)
      - [2.2.6. 自定义序列表方案](#226-自定义序列表方案)
      - [2.2.7. MaxID 集群方案](#227-maxid-集群方案)
    - [2.3. 其他](#23-其他)
  - [3. 文档规范](#3-文档规范)
  - [4. 业务规范](#4-业务规范)
    - [4.1. 企业应用](#41-企业应用)
    - [4.2. 互联网应用](#42-互联网应用)
  - [5. Refer Links](#5-refer-links)

# 数据库：数据库规范

## 1. 命名规范

基本规则：
- **命名字符采用 26 个英文字母（区分大小写) 和 0-9 这十个自然数，加上下划线'_'组成，共 63 个字符，不能出现其他字符**。
- **命名不得超过 30 个字符的系统限制**。变量名的长度限制为 29（不包括标识字符 `@`)。
- **数据对象、变量的命名都采用英文字符，禁止使用中文命名**。

范例：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/29/12c09269e71e624bb484b267b7212734.jpg)

### 1.1. 数据库命名规范

规范：
- 数据库名采用前缀，前缀名称一般不超过 5 个字符。
- 使用小写英文以及下划线组成。
- 尽量能说明是那个应用或者系统在使用的。
- 备份数据库名使用正式库名加上备份时间组成。

举例：

### 1.2. 表命名规范

- 规范
  - 数据表名采用前缀，表前缀用项目名称首字母缩写，相关应用的数据表使用同一前缀，如论坛的表使用  `cdb_` 前缀，博客的数据表使用 `supe_` 前缀，前缀名称一般不超过 5 个字符。
  - 使用小写英文以及下划线组成，单词之间用下划线分开，单词都用单数形式。

- 常用约定表名
  - user – 用户
  - category – 分类
  - goods – 商品、产品等一切可交易网站的物品都用此命名
  - good_gallery – 物品的相册
  - good_cate – 物品的分类，除了单独作为表名，其他地方分类单词一律用缩写 cate
  - attr – 属性
  - article – 文章、新闻、帮助中心等以文章形式出现的，一般都用此命名
  - cart – 购物车
  - feedback – 用户反馈
  - order – 订单
  - site_nav – 包括页头和页尾导航
  - site_config – 系统配置表
  - admin – 后台用户 【RBAC 标准表】
  - role – 后台用户角色【RBAC 标准表】
  - access – 后台操作权限，相当于 action【RBAC 标准表】
  - role_admin – 后台用户对应的角色【RBAC 标准表】
  - access_role – 后台角色对应的权限【RBAC 标准表】

### 1.3. 字段命名规范

- 规范：
  - 使用小写英文以及下划线组成，单词之间用下划线分开，如 open_id, create_time。
  - 对应 java 代码中：采用驼峰命名规范，如 openId, createTime。
  - 表与表之间的相关联字段要用统一名称。

- 常用约定字段名：
  - 表名_id – 通常用作外键命名
  - cid – 特殊的编号，带有元数据，方便关联查询，你可以把它理解成类别（层次) 编号。举个例子，产品在分类时，往往需要将其归类到子分类下，相应的字段中也一般只记录子分类的 id，这时若需要知道该产品属于哪个主分类，就需要通过子分类信息再查询到主分类信息，这是比较麻烦的，cid 字段就是要解决这个问题。一般的站点几十个分类肯定是够用了，所以这里假设某一主分类的 cid 为 11，则子分类的 cid 从 1101 开始编号，处理时只需截取前两位数值便可知道该产品属于哪一个主分类了。
  - add_time – 添加时间、上架时间等
  - last_time – 最后操作时间，如登录、修改记录
  - expire_time – 过期时间
  - name – 商品名称、商家名称等，不要跟 title 混用，title 只用于文章标题、职称等
  - price – 价格
  - thumb – 只要是列表页面中的窗口图，一律用此命名
  - image_src – 相册中的图片地址一律用此命名，不要出现各种 img,image,img_url,thumb_url 等
  - head_thumb – 用户头像， 虽然有点长，一定要遵守。不要出现上述情况
  - image_alt – 相册中图片的 alt 属性
  - desc – 描述、简介，比如 goods_desc，不要出现 goods_txt 这种
  - details – 详情、文章内容等
  - order_id – 排序
  - telephone – 座机号码
  - mobile – 手机号码
  - phone – 当不区分手机和座机时，请用 phone 命名
  - address – 地址，单独出现不要用 addr 缩写，组合出现时需用缩写，比如 mac 地址，mac_addr
  - zipcode – 邮编
  - region – 地区，大的区域，比如记录杭州市、温州市等
  - area – 区域，小的，比如上城区，江干区等
  - avg_cost – 人均消费

## 2. 表结构规范

### 2.1. 数据类型选择

规则：用尽量少的存储空间来存数一个字段的数据。
- 能用 int 的就不用 char 或者 varchar 
- 能用 tinyint 的就不用 int 
- 能用 varchar(20) 的就不用 varchar(255) 
- 时间戳字段尽量用 int 型，如 created: 表示从'1970-01-01 08:00:00′开始的 int 秒数，采用英文单词的过去式；gmtCreated: 表示 datetime 类型的时间，即形如'1980-01-01 00:00:00′的时间串，Java 中对应的类型为 Timestamp。

### 2.2. 主键设计方案

https://www.cnblogs.com/xiekeli/p/5398374.html 

#### 2.2.1. 主键设计要求

业务系统对 ID 号的要求有哪些呢？
1. 全局唯一性：不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求。
1. 趋势递增：在 MySQL InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。
1. 单调递增：保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求。
1. 信息安全：如果 ID 是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定 URL 即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要 ID 无规则、不规则。
上述 123 对应三类不同的场景，3 和 4 需求还是互斥的，无法使用同一个方案满足。

同时除了对 ID 号码自身的要求，业务还对 ID 号生成系统的可用性要求极高，想象一下，如果 ID 生成系统瘫痪，整个美团点评支付、优惠券发券、骑手派单等关键动作都无法执行，这就会带来一场灾难。

由此总结下一个 ID 生成系统应该做到如下几点：
- 平均延迟和 TP999 延迟都要尽可能低。
- 可用性 5 个 9。
- 高 QPS。

#### 2.2.2. 主键设计原则

- 主键应当是对用户没有意义的。
- 主键应该是单列的，以便提高连接和筛选操作的效率。
- 永远也不要更新 MySQL 主键。
- 主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等。
- 主键应当有计算机自动生成。

#### 2.2.3. 自增 ID 方案

优点：
- 数据库自动编号，**速度快**，而且是增量增长，**聚集型主键按顺序存放，对于检索非常有利**。
- 数字型，**占用空间小，易排序**，在程序中传递方便。

缺点：
- 不支持分布式的水平分片架构，**在分布式水平分片的设计当中，这种方法显然不能保证全局唯一**。
- 表锁。
- 自增主键不连续。
- **泄露数据记录信息**。

#### 2.2.4. UUID 方案

[UUID (universally unique identifiers)](https://en.wikipedia.org/wiki/Universally_unique_identifier) 是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分，到目前为止业界一共有 5 种方式生成 UUID，详情见 IETF 发布的 UUID 规范 [A Universally Unique IDentifier (UUID) URN Namespace](http://www.ietf.org/rfc/rfc4122.txt)。其中应用最广泛的 UUID 是微软公司的[全局唯一标识符  GUID](https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6)。

> A **universally unique identifier** (**UUID**) is a 128-bit number used to identify information in computer systems. 

UUID 的标准形式由 32 个 16 进制的数字组成，共 128 位，并以连字号分为五段，如 `550e8400-e29b-41d4-a716-446655440000`。因此，UUID 理论上的总数为 `16^32 = 2^128 = 3.4 * 10^38`，如果每纳秒产生 1 兆个 UUID，要花 100 亿年才会将所有 UUID 用完。

优点：
- **全局唯一性、安全性、可移植性，适用于分布式数据库环境**。
- 能够保证独立性，程序可以在不同的数据库间迁移，效果不受影响。
- 保证生成的 ID 不仅是表独立的，而且是库独立的，在切分数据库的时候尤为重要。

缺点：
- 针对 InnoDB 引擎会徒增 IO 压力，**InnoDB 为聚集主键类型的引擎，数据会按照主键进行排序，由于 UUID 的无序性，InnoDB 会产生巨大的 IO 压力**。InnoDB 主键索引和数据存储位置相关（簇类索引），uuid 主键可能会引起数据位置频繁变动，严重影响性能。
- UUID 长度过长，一个 UUID 占用 128 个比特（16 个字节）。**主键索引 KeyLength 长度过大，而影响能够基于内存的索引记录数量，进而影响基于内存的索引命中率，而基于硬盘进行索引查询性能很差**。严重影响数据库服务器整体的性能表现。

#### 2.2.5. snowflake 方案

TODO:

snowflake 是 Twitter 开源的分布式 ID 生成算法，结果是一个 long 型的 ID。其核心思想是：使用 41bit 作为毫秒数，10bit 作为机器的 ID（5 个 bit 是数据中心，5 个 bit 的机器 ID），12bit 作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是 0。

优点
- 毫秒数在高位，自增序列在低位，整个 ID 都是趋势递增的。
- 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成 ID 的性能也是非常高的。
- 可以根据自身业务特性分配 bit 位，非常灵活。

缺点
- 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。

实例：
- MongoDB ObjectID 就可以算作是类 snowflake 方案，通过“时间 + 机器码 +pid+inc”共 12 个字节，通过 4+3+2+3 的方式最终标识成一个 24 长度的十六进制字符。

#### 2.2.6. 自定义序列表方案

**在库中建一张用于生成序列的表来存储序列信息，序列生成的策略通过应用程序层来实现**。通过独立的应用程序事先在数据库中生成一系列唯一的 ID，各应用程序通过接口或者自己去读取再和数据一起插入到切分后的集群中。

优点
- 全局唯一主键简单，维护相对容易。

缺点
- 实现复杂，需要应用开发。

#### 2.2.7. MaxID 集群方案

TODO:

专门一个数据库，记录各个表的 MaxId 值，**建一个存储过程来取 Id，逻辑大致为**：开启事务，对于在表中不存在记录，直接返回一个默认值为 1 的键值，同时插入该条记录到 table_key 表中。而对于已存在的记录，key 值直接在原来的 key 基础上加 1 更新到 MaxId 表中并返回 key。

优化：建立两台以上的数据库 ID 生成服务器，每个服务器都有一张记录各表当前 ID 的 MaxId 表，但是 MaxId 表中 Id 的增长步长是服务器的数量，起始值依次错开，这样相当于把 ID 的生成散列到每个服务器节点上。例如：如果我们设置两台数据库 ID 生成服务器，那么就让一台的 MaxId 表的 Id 起始值为 1（或当前最大 Id+1），每次增长步长为 2，另一台的 MaxId 表的 ID 起始值为 2（或当前最大 Id+2），每次步长也为 2。这样就将产生 ID 的压力均匀分散到两台服务器上，同时配合应用程序控制，当一个服务器失效后，系统能自动切换到另一个服务器上获取 ID，从而解决的单点问题保证了系统的容错。（Flickr 思想）

进一步优化：当使用数据库来生成 ID 性能不够要求的时候，我们可以尝试使用 Redis 来生成 ID。这主要依赖于 Redis 是单线程的，所以也可以用生成全局唯一的 ID。可以用 Redis 的原子操作 INCR 和 INCRBY 来实现。可以使用 Redis 集群来获取更高的吞吐量。假如一个集群中有 5 台 Redis。可以初始化每台 Redis 的值分别是 1,2,3,4,5，然后步长都是 5。

但是要注意：1、多服务器就必须面临负载均衡的问题；2、倘若添加新节点，需要对原有数据重新根据步长计算迁移数据。

结论：适合大型应用，生成 Id 较短，友好性比较好。（强烈推荐）

### 2.3. 其他

- 表中的第一个 id 字段一定是主键且为自动增长。
- 数值类型的字段请使用 UNSIGNED 属性。
- **排序字段 order_id 在程序中默认使用降序排列**。
- 所有字段都设置 NOT NULL，并设置默认值。
- 所有的布尔值字段，如 is_hot、is_deleted，都必须设置一个默认值，并设为 0。
- 所有的数字类型字段，都必须设置一个默认值，并设为 0。
- 针对 varchar 类型字段的程序处理，请验证用户输入，不要超出其预设的长度。
- 建表时将数据字典中的字段中文名和属性备注写入数据表的备注中 (“PK、自动增长”不用写)。

## 3. 文档规范

所有数据库设计要写成文档，文档以模块化形式表达。大致格式如下： 
```sql
-- ——————————————- 
--  表名： web_user 
--  作者： Aeolus（傻鱼) 
--  日期： 2007-04-11 
--  版本： 1.0 
--  描述： 保存用户资料 
--  具体内容： 
--  UserID int, 自动增量 用户代码 
--  UserName char(12) 用户名字 
--  …… 
-- ——————————————–
```

## 4. 业务规范

数据库应用领域基本分为两种：互联网高并发应用、企业内部业务管理应用。

### 4.1. 企业应用

**在企业应用中，业务逻辑可适当放在数据库层**。

如 SAP、peopleSoft、ERP 等企业级别应用，**由于业务逻辑修改频繁，而且大多为通用**，因此会使用存储过程和触发器，把一些业务逻辑编写成存储过程，减少开发成本。

**服务器的负载是可控，即系统访问量可控且相对稳定**，因此，性能的影响在这时不是主要因素。

### 4.2. 互联网应用

**在互联网应用中，业务逻辑应完全放在应用层**。

如淘宝、知乎、微博，数据库访问量和并发量都不可控制且量级一般较大，**数据库的 I/O 是 web 应用的主要瓶颈**，因此一般会尽可能的减少数据库的操作，把业务逻辑放到服务端的代码 / 应用层，而且可以借助一些 LVS 等类型软硬件做负载均衡，以及平滑增减 Web 层的服务器，从而减轻数据库压力，达到线性的增减而支持大规模的访问。

## 5. Refer Links

TODO:

[Leaf——美团点评分布式 ID 生成系统](https://tech.meituan.com/MT_Leaf.html)

[分布式环境下数据库主键方案](https://my.oschina.net/dolphinboy/blog/864567)

[分布式系统唯一 ID 生成方案汇总](https://www.cnblogs.com/haoxinyue/p/5208136.html)

[分布式唯一 ID 极简教程](https://cloud.tencent.com/developer/article/1082117)