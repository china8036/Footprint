- [数据库：事务管理](#)
  - [1. 基本概念](#1)
  - [2. ACID 属性](#2-acid)
  - [3. 事务隔离级别](#3)

# 数据库：事务管理

## 1. 基本概念

## 2. ACID 属性

事务具有 4 个属性，通常称为事务的 ACID 属性：
- 原性性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都回滚。
- 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如 B 树索引或双向链表）也都必须是正确的。
- 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
- 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

## 3. 事务隔离级别

在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。

“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。

数据库的事务隔离级别越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的，同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。

为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了４个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己业务逻辑要求，通过选择不同的隔离级别来平衡＂隔离＂与＂并发＂的矛盾：

| 事务隔离级别             | 描述                                                         | 读数据一致性                             | 解决的问题                                       | 备注                                 |
| ------------------------ | ------------------------------------------------------------ | ---------------------------------------- | ------------------------------------------------ | ------------------------------------ |
| READ_UNCOMMITTED 未提交读 | 事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据 | 最低级别，只能保证不读取物理上损坏的数据 | 第一类丢失更新                                   |                                      |
| READ_COMMITTED 已提交读   | 保证一个事务修改的数据提交后才能被另外一个事务读取，即另外一个事务不能读取该事务未提交的数据 | 语句级                                   | 第一类丢失更新和脏读                             |                                      |
| REPEATABLE_READ 可重复读  | 保证一个事务相同条件下前后两次获取的数据是一致的             | 事务级                                   | 第一类丢失更新，脏读、不可重复读、第二类丢失更新 | REPEATABLE_READ 是 MySQL 默认的隔离级别 |
| SERIALIZABLE 可序列化     | 事务被处理为顺序执行                                         | 最高级别，事务级                         | 全部问题                                         |                                      |

NOTE:
- 如果一个事务请求的锁模式与当前的锁兼容，InnoDB 就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。	
- 各具体数据库并不一定完全实现了上述 4 个隔离级别，如 Oracle 只提供 Read committed 和 Serializable 两个标准级别，但 MySQL 支持全部４个隔离级别。
