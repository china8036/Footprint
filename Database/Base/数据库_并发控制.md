- [数据库：并发控制](#数据库并发控制)
  - [1. 概述](#1-概述)
    - [1.1. 多用户数据库系统](#11-多用户数据库系统)
    - [1.2. 并发操作带来的问题](#12-并发操作带来的问题)
    - [1.3. 并发控制的主要技术](#13-并发控制的主要技术)
  - [2. 封锁](#2-封锁)
    - [2.1. 基本封锁类型](#21-基本封锁类型)
    - [2.2. 封锁协议](#22-封锁协议)
      - [2.2.1. 一级封锁协议](#221-一级封锁协议)
      - [2.2.2. 二级封锁协议](#222-二级封锁协议)
      - [2.2.3. 三级封锁协议](#223-三级封锁协议)
    - [2.3. 活锁与死锁](#23-活锁与死锁)
      - [2.3.1. 活锁](#231-活锁)
      - [2.3.2. 死锁](#232-死锁)
        - [2.3.2.1. 死锁的预防](#2321-死锁的预防)
        - [2.3.2.2. 死锁的诊断与解除](#2322-死锁的诊断与解除)
    - [2.4. 并发调度](#24-并发调度)
      - [2.4.1. 可串行性](#241-可串行性)
      - [2.4.2. 两段锁协议](#242-两段锁协议)
    - [2.5. 锁的粒度](#25-锁的粒度)
    - [2.6. 意向锁](#26-意向锁)
    - [2.7. 悲观锁与乐观锁](#27-悲观锁与乐观锁)
      - [2.7.1. 悲观锁](#271-悲观锁)
      - [2.7.2. 乐观锁](#272-乐观锁)

# 数据库：并发控制

## 1. 概述

### 1.1. 多用户数据库系统

数据库是一个共享资源，可以供多个用户使用。允许多个用户同时使用同一个数据库的数据库系统称为多用户数据库系统，如飞机订票数据库系统、银行数据库系统等。在这样的系统中，在同一时刻并发运行的事务数量可达成百上千个。

当多个用户并发地存取数据库时就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制，就可能会出现存取和存储不正确的情况，破坏事务的一致性和数据库的一致性。因此，数据库管理系统的并发控制机制是衡量一个数据库管理系统性能的重要标志之一。

**事务是并发控制的基本单位，保证事务 ACID 特性是事务处理的重要任务，而事务的 ACID 特性被破坏的可能原因之一就是多个事务对数据库的并发操作造成的**。为保证事务的隔离性和一致性，数据库管理系统需要对并发操作进行正确调度。

### 1.2. 并发操作带来的问题

当事务并发时，会产生什么问题？

- 第一类丢失更新 (First Lost Update)

  在没有事务隔离的情况下，两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。

  例如：张三的工资为 5000，事务 A 中获取工资为 5000，事务 B 获取工资为 5000，汇入 100，并提交数据库，工资变为 5100。随后，事务 A 发生异常，回滚了，恢复张三的工资为 5000，这样就导致事务 B 的更新丢失了。

- 脏读 (Dirty Reads)

  脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

  例如：

  张三的工资为 5000, 事务 A 中把他的工资改为 8000, 但事务 A 尚未提交。

  与此同时，事务 B 正在读取张三的工资，读取到张三的工资为 8000。

  随后，事务 A 发生异常，而回滚了事务。张三的工资又回滚为 5000。
  最后，事务 B 读取到的张三工资为 8000 的数据即为脏数据，事务 B 做了一次脏读。

- 不可重复读 (Non-Repeatable Reads)

  是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。

  例如：

  在事务 A 中，读取到张三的工资为 5000，操作没有完成，事务还没提交。

  与此同时，事务 B 把张三的工资改为 8000，并提交了事务。

  随后，在事务 A 中，再次读取张三的工资，此时工资变为 8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。

- 第二类丢失更新 (Second Lost Update)

  不可重复读的特例。有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。 

  例如：

  在事务 A 中，读取到张三的存款为 5000，操作没有完成，事务还没提交。

  与此同时，事务 B，存储 1000，把张三的存款改为 6000，并提交了事务。

  随后，在事务 A 中，存储 500，把张三的存款改为 5500，并提交了事务，这样事务 A 的更新覆盖了事务 B 的更新。

- 幻读 (Phantom Reads)

  是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，且这个修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

  例如：
  　　
  目前工资为 5000 的员工有 10 人，事务 A 读取所有工资为 5000 的人数为 10 人。
  　　
  此时，事务 B 插入一条工资也为 5000 的记录。
  　　
  这是，事务 A 再次读取工资为 5000 的员工，记录为 11 人。此时产生了幻读。

辨析：
- **不可重复读问题的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了**。
- **幻读问题的重点在于新增或者删除，同样的条件，第 1 次和第 2 次读出来的记录数不一样**。

### 1.3. 并发控制的主要技术

数据库管理系统（DBMS）中的并发控制 (Concurrency control) 的任务是确保在多个事务同时存取数据库中同一数据时**不破坏事务的隔离性和统一性以及数据库的统一性**。

并发控制主要采用的技术手段如下：

- 封锁
  - 乐观并发控制（乐观锁)
  - 悲观并发控制（悲观锁）
- 时间戳
- 多版本并发控制

其中，**封锁是众多数据库产品采用的并发控制的基本方法**。

## 2. 封锁

封锁是实现并发控制的一个非常重要的技术。**封锁指的是事务 T 在对某个数据对象例如表、记录进行操作之前，先向系统发出请求，对其加锁。加锁后事务 T 就对该数据对象有了一定的控制，在事务 T 释放它的锁之前，其它事务不能更新此数据对象**。

确切的控制逻辑由封锁的类型决定，**基本的封锁类型有两种：排他锁和共享锁**。

### 2.1. 基本封锁类型

- 排他锁（写锁）（exclusive lock, 简称 X 锁）
  
  若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其它任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁为止。这就保证了其它事务在 T 释放 A 上的锁之前不能再读取和修改 A。

- 共享锁（读锁）（share lock, 简称 S 锁）
  
  若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其它事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁为止。这就保证了其它事务可以读 A，但再 T 释放 A 上的 S 锁之前不能对 A 做任何修改。

### 2.2. 封锁协议

在运用 X 锁和 S 锁这两种基本封锁对数据对象加锁时，需要约定一些规则，这些规则称为封锁协议，对封锁方式制定不同的规则，就形成了各种不同的封锁协议。

对并发操作的不正确调度可能会带来许多问题，三级封锁协议分别在不同程度上解决了这些问题，为并发操作的正确调度提供了一定的保证。**三级协议的主要区别在于什么操作需要申请封锁，以及何时释放锁（即持锁时间）**。

#### 2.2.1. 一级封锁协议

一级封锁协议指的是，事务 T 在修改数据 R 之前必须先对其加 X 锁，**直到事务结束**才释放（事务结束包括正常结束 COMMIT 和非正常结束 ROLLBACK）。

一级封锁协议可防止丢失修改，并保证事务 T 是可恢复的。但在该协议中，如果仅读取数据而不修改，是不需要加锁的，这就不能保证可重复读和不读“脏”数据。

#### 2.2.2. 二级封锁协议

二级封锁协议指的是，在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，**读完后**即可释放 S 锁。

二级封锁协议除防止丢失修改，还可进一步防止读“脏”数据。但由于读完数据后即可释放 S 锁，因此不能保证可重复读。

#### 2.2.3. 三级封锁协议

三级封锁协议指的是，在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，**直到事务结束**才释放。

三级封锁协议除了防止丢失修改和读“脏”数据外，还解决了不可重复读问题。

### 2.3. 活锁与死锁

和操作系统一样，封锁的方法可能引起活锁和死锁等问题。

#### 2.3.1. 活锁

若事务 T1 封锁了数据 R，事务 T2 又请求封锁 R，于是 T2 等待。T3 也请求封锁 R，当 T1 释放了 R 上的封锁之后系统首先批准了 T3 的请求，T2 仍然等待……由于存在“插队”情况，T2 有可能永远等待，这就是活锁的情形。

避免活锁的简单方法是采用先来先服务的策略。

#### 2.3.2. 死锁

若事务 T1 封锁了数据 R1，T2 封锁了数据 R2，然后 T1 又请求封锁 R2，因 T2 已封锁了 R2，于是 T1 等待 T2 释放 R2 上的锁。接着 T2 又申请封锁 R1，因 T1 已封锁了 R1，T2 也只能等待 T1 释放 R1 上的锁。这就出现了 T1 在等待 T2，而 T2 又在等待 T1 的情形，T1 和 T2 两个事务永远不能结束，形成死锁。

在数据库中解决死锁问题主要有两类方法：
- 采取一定措施来预防死锁的发生。
- 允许发生死锁，采用一定手段定期诊断系统中有无死锁，若有则解除之。

##### 2.3.2.1. 死锁的预防

防止死锁的发生其实就是要破坏产生死锁的条件，可以从2方面进行操作：
- 一次封锁法

  一次封锁法要求每个事务都必须一次将所有要使用的数据全部加锁，否则就不能继续执行。

  一次封锁法虽然可以有效地防止死锁的发生，但扩大了封锁的范围，从而降低了系统的并发度；且数据库中数据是不断变化的，很难事先精确地确定每个事务所要封锁的数据对象，为此只能扩大封锁范围，进一步降低了并发度。

- 顺序封锁法

  顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实施封锁。例如，在 B 树结构的索引中，可规定封锁的顺序必须是从根结点开始，然后是下一级的子结点，逐级封锁。

  顺序封锁法虽然可以有效地防止死锁的发生，但同样存在问题：
  - 数据库系统的封锁的数据对象极多，并且不断变化，要维护这样的资源的封锁顺序非常困难，成本非常高。
  - 事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此很难按规定顺序去施加封锁。

具体做法：
- 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
- 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。
- 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。

可见，在操作系统中广为采用的预防死锁的方法并不太适合数据库的特点，因此**数据库管理系统在解决死锁的问题上普遍采用的是诊断并解除死锁的方法**。

##### 2.3.2.2. 死锁的诊断与解除

数据库系统中诊断死锁的方法与操作系统类似，一般使用超时法或事务等待图法。

- 超时法

  如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。

  该方法实现简单，但其不足也很明显：
  - 有可能会误判
  - 时限若设置太长，死锁发生后不能及时实现

- 等待图法

  事务等待图是一个有向图 G=(T, U)，T 为结点的集合，每个结点表示正运行的事务，U 为边的集合，每条边表示事务等待的情况（若 T1 等待 T2，则从 T1 指向 T2）。

  事务等待图是最常用的死锁诊断方法。它动态地反映了所有事务的等待情况。并发控制子系统周期地生成事务等待图，并进行检测。如果发现图中存在回路，则表示系统中出现了死锁。

通常解除死锁的方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，使其它事务得以继续运行下去。当然，对撤销的事务所执行的数据修改操作必须加以恢复。

### 2.4. 并发调度

数据库管理系统对并发事务不同的调度可能会产生不同的结果，其中，串行调度和执行结果等价于串行调度的调度是正确的调度。

#### 2.4.1. 可串行性

多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行执行这些事务时的结果相同，称这种调度策略为可串行化调度。

可串行性是并发事务正确调度的准则，按这个准则规定，一个给定的并发调度，当且仅当它是可串行化的，才认为是正确的调度。

冲突操作是指不同的事务对同一个数据的读写操作和写写操作。不同事务的冲突操作和同一事务的两个操作是不能交换的。

一个调度 Sc 在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度 Sc'，如果 Sc'是串行的，称调度 Sc 为冲突可串行化的调度。若一个调度是冲突可串行化的，则一定是可串行化的调度。

应该指出的是，**冲突可串行化调度是可串行化调度的充分条件，不是必要条件。**

#### 2.4.2. 两段锁协议

为保证并发调度的正确性，数据库管理系统的并发控制机制必须提供一定的手段来保证调度是可串行化的。目前，数据库管理系统普遍采用两段锁协议 (2 PL) 的方法实现并发调度的可串行性，从而保证调度的正确性。

**两端锁协议要求所有事务必须分为两个阶段对数据项进行加锁和解锁**。事务都分为两个阶段：
- 扩展阶段：在这个阶段，事务可以申请获得任何数据项上的任何类型的锁，但不能释放任何锁。
- 收缩阶段：在这个阶段，事务可以释放任何数据项上的任何类型的锁，但不能再申请锁。

可以证明，**若并发执行的所有事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的**。

应该指出的是，**事务遵守两段锁协议是可串行化调度的充分条件，不是必要条件**。

两段锁协议与一次封锁法的异同：
- 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，因此一次封锁法遵守两段锁协议。
- 两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。

### 2.5. 锁的粒度

封锁对象的大小称为封锁粒度。所谓粒度，即细化的程度。锁的粒度越大，则并发性越低且开销大；锁的粒度越小，则并发性高且开销小。

- 根据锁的粒度分类，主要有以下几种类型的锁：
  - 行锁：行锁是粒度中最小的资源。行锁就是指事务在操作数据的过程中，锁定一行或多行的数据，其他事务不能同时处理这些行的数据。行级锁占用的数据资源最小，所以在事务的处理过程中，允许其它事务操作同一表的其他数据。
  - 页锁：一次锁定一页。25 个行锁可升级为一个页锁。
  - 表锁：锁定整个表。当整个数据表被锁定后，其他事务就不能够使用此表中的其他数据。使用表锁可以使事务处理的数据量大，并且使用较少的系统资源。但是在使用表锁时，会延迟其他事务的等待时间，降低系统并发性。
  - 数据库锁：防止任何事务和用户对此数据库进行访问。可控制整个数据库的操作。

- 锁的粒度选择

  在一个系统中同时支持多种封锁粒度供不同的事务选择是比较理想的，这种封锁方法称为多粒度封锁。选择封锁粒度时应同时考虑封锁开销和并发度两个因素，适当选择封锁粒度以求得最优的效果。一般情况下：
  - 只需要处理少量元组的用户事务可以以元组为封锁粒度。
  - 需要处理某个关系的大量元组的事务可以以关系为封锁粒度。
  - 需要处理多个关系的大量元组的事务可以以数据库为封锁粒度。

### 2.6. 意向锁

对某个数据对象加锁，系统要检查该数据对象上有无显式封锁与之冲突，再检查其所有上级结点，看本事务的显式封锁是否与该数据对象上的隐式封锁冲突；还要检查其所有下级结点，看其显式封锁是否与本事务的隐式封锁冲突。这样的检查方法显然效率很低，因此，可以使用意向锁，从而无须再诸葛检查下一级结点的显式封锁。

意向锁的含义是如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。对任一结点加锁时，都必须先对它的上层节点加意向锁。

常用的意向锁包括：
- 意向共享锁 (IS 锁): 如果对一个数据对象加 IS 锁，表示它的后裔结点拟加 S 锁。
- 意向排他锁 (IX 锁): 如果对一个数据对象加 IX 锁，表示它的后裔结点拟加 X 锁。
- 共享意向排他锁 (SIX 锁): 如果对一个数据对象加 SIX 锁，表示对它的 S 锁，再加 IX 锁，即 SIX=S+IX。

在具有意向锁的多粒度封锁方法中，任意事务 T 要对一个数据对象加锁，必须先对它的上层结点加意向锁。申请封锁时应该按照自上而下的次序进行，释放封锁时则应该按自下而上的次序进行。

具有意向锁的多粒度封锁方法提高了系统的并发度，减少了加锁和解锁的开销，已经在实际的数据库管理系统产品中得到广泛应用。

### 2.7. 悲观锁与乐观锁

http://www.hollischuang.com/archives/934 

**乐观并发控制（乐观锁) 和悲观并发控制（悲观锁）是并发控制主要采用的技术手段**。

**无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想**。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像 memcache、hibernate、tair 等都有类似的概念。

针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为 DBMS 中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在 DBMS 中，悲观锁正是利用数据库本身提供的锁机制来实现的。

#### 2.7.1. 悲观锁

在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。**如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。**

悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

例：
```sql
--0. 开始事务
begin;/begin work;/start transaction; （三者选一就可以)
--1. 查询出商品信息
select status from t_goods where id=1 for update;
--2. 根据商品信息生成订单
insert into t_orders (id,goods_id) values (null,1);
--3. 修改商品 status 为 2
update t_goods set status=2;
--4. 提交事务
commit;/commit work;
```
要使用悲观锁，我们必须关闭 MySQL 数据库的自动提交属性，因为 MySQL 默认使用 autocommit 模式，也就是说，当你执行一个更新操作后，MySQL 会立刻将结果进行提交：
```sql
set autocommit=0; 
```

优缺点：

悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。

#### 2.7.2. 乐观锁

在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。**在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。**

相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。**一般的实现乐观锁的方式就是记录数据版本，而实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳**。

例：使用版本号实现乐观锁

使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行 +1 操作。并判断当前版本号是不是该数据的最新的版本号。
```sql
--1. 查询出商品信息
select (status,status,version) from t_goods where id=#{id}
--2. 根据商品信息生成订单
--3. 修改商品 status 为 2
update t_goods 
set status=2,version=version+1
where id=#{id} and version=#{version};
```

优缺点：

乐观并发控制相信事务之间的数据竞争 (data race) 的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。
