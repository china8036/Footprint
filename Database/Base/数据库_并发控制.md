- [数据库：并发控制](#%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6)
  - [1. 概述](#1-%E6%A6%82%E8%BF%B0)
    - [1.1. 多用户数据库系统](#11-%E5%A4%9A%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F)
    - [1.2. 并发操作带来的问题](#12-%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98)
    - [1.3. 并发控制的主要技术](#13-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8A%80%E6%9C%AF)
  - [2. 封锁](#2-%E5%B0%81%E9%94%81)
    - [2.1. 基本封锁类型](#21-%E5%9F%BA%E6%9C%AC%E5%B0%81%E9%94%81%E7%B1%BB%E5%9E%8B)
    - [2.2. 三级封锁协议](#22-%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE)
      - [2.2.1. 一级封锁协议](#221-%E4%B8%80%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE)
      - [2.2.2. 二级封锁协议](#222-%E4%BA%8C%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE)
      - [2.2.3. 三级封锁协议](#223-%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE)
    - [2.3. 活锁与死锁](#23-%E6%B4%BB%E9%94%81%E4%B8%8E%E6%AD%BB%E9%94%81)
      - [2.3.1. 活锁](#231-%E6%B4%BB%E9%94%81)
      - [2.3.2. 死锁](#232-%E6%AD%BB%E9%94%81)
        - [2.3.2.1. 死锁的预防](#2321-%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2)
        - [2.3.2.2. 死锁的诊断与解除](#2322-%E6%AD%BB%E9%94%81%E7%9A%84%E8%AF%8A%E6%96%AD%E4%B8%8E%E8%A7%A3%E9%99%A4)
    - [2.4. 并发调度](#24-%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6)
      - [2.4.1. 可串行性](#241-%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7)
      - [2.4.2. 两段锁协议](#242-%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE)
    - [2.5. 锁的粒度](#25-%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6)
    - [2.6. 意向锁](#26-%E6%84%8F%E5%90%91%E9%94%81)

# 数据库：并发控制

## 1. 概述

### 1.1. 多用户数据库系统

数据库是一个共享资源，可以供多个用户使用。允许多个用户同时使用同一个数据库的数据库系统称为多用户数据库系统，如飞机订票数据库系统、银行数据库系统等。在这样的系统中，在同一时刻并发运行的事务数量可达成百上千个。

当多个用户并发地存取数据库时就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制，就可能会出现存取和存储不正确的情况，破坏事务的一致性和数据库的一致性。因此，数据库管理系统的并发控制机制是衡量一个数据库管理系统性能的重要标志之一。

**事务是并发控制的基本单位**，保证事务 ACID 特性是事务处理的重要任务，而事务的 ACID 特性被破坏的可能原因之一就是多个事务对数据库的并发操作造成的。为保证事务的隔离性和一致性，数据库管理系统需要对并发操作进行正确调度。

### 1.2. 并发操作带来的问题

当事务并发时，会产生什么问题？

- 第一类丢失更新 (First Lost Update)

  在没有事务隔离的情况下，两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。

  例如：张三的工资为 5000，事务 A 中获取工资为 5000，事务 B 获取工资为 5000，汇入 100，并提交数据库，工资变为 5100。随后，事务 A 发生异常，回滚了，恢复张三的工资为 5000，这样就导致事务 B 的更新丢失了。

- 脏读 (Dirty Reads)

  脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
  
  例如：
  
  张三的工资为 5000, 事务 A 中把他的工资改为 8000, 但事务 A 尚未提交。
  
  与此同时，事务 B 正在读取张三的工资，读取到张三的工资为 8000。
  
  随后，事务 A 发生异常，而回滚了事务。张三的工资又回滚为 5000。
  　　
  最后，事务 B 读取到的张三工资为 8000 的数据即为脏数据，事务 B 做了一次脏读。

- 不可重复读 (Non-Repeatable Reads)

  是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
  
  例如：
  
  在事务 A 中，读取到张三的工资为 5000，操作没有完成，事务还没提交。
  
  与此同时，事务 B 把张三的工资改为 8000，并提交了事务。
  
  随后，在事务 A 中，再次读取张三的工资，此时工资变为 8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。

- 第二类丢失更新 (Second Lost Update)

  不可重复读的特例。有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。 
  
  例如：
  
  在事务 A 中，读取到张三的存款为 5000，操作没有完成，事务还没提交。
  
  与此同时，事务 B，存储 1000，把张三的存款改为 6000，并提交了事务。
  
  随后，在事务 A 中，存储 500，把张三的存款改为 5500，并提交了事务，这样事务 A 的更新覆盖了事务 B 的更新。

- 幻读 (Phantom Reads)

  是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。
  
  例如：
  　　
  目前工资为 5000 的员工有 10 人，事务 A 读取所有工资为 5000 的人数为 10 人。
  　　
  此时，事务 B 插入一条工资也为 5000 的记录。
  　　
  这是，事务 A 再次读取工资为 5000 的员工，记录为 11 人。此时产生了幻读。

辨析：
- 不可重复读问题的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了。
- 幻读问题的重点在于新增或者删除，同样的条件，第 1 次和第 2 次读出来的记录数不一样。

### 1.3. 并发控制的主要技术

并发控制的主要技术有：
- 封锁
- 时间戳
- 乐观控制法
- 多版本并发控制
其中，封锁技术是众多数据库产品采用的基本方法。

## 2. 封锁

封锁是实现并发控制的一个非常重要的技术。所谓封锁指的是事务 T 在对某个数据对象例如表、记录进行操作之前，先向系统发出请求，对其加锁。加锁后事务 T 就对该数据对象有了一定的控制，在事务 T 释放它的锁之前，其它事务不能更新此数据对象。

确切的控制由封锁的类型决定。基本的封锁类型有两种：排他锁和共享锁。

### 2.1. 基本封锁类型

- 排他锁（写锁）（exclusive lock, 简称 X 锁）: 若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其它任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁为止。这就保证了其它事务在 T 释放 A 上的锁之前不能再读取和修改 A。

- 共享锁（读锁）（share lock, 简称 S 锁）: 若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其它事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁为止。这就保证了其它事务可以读 A，但再 T 释放 A 上的 S 锁之前不能对 A 做任何修改。

### 2.2. 三级封锁协议

在运用 X 锁和 S 锁这两种基本封锁对数据对象加锁时，需要约定一些规则。这些规则称为封锁协议，对封锁方式制定不同的规则，就形成了各种不同的封锁协议。

对并发操作的不正确调度可能会带来许多问题，三级封锁协议分别在不同程度上解决了这些问题，为并发操作的正确调度提供了一定的保证。三级协议的主要区别在于什么操作需要申请封锁，以及何时释放锁（即持锁时间）。

#### 2.2.1. 一级封锁协议

一级封锁协议指的是，事务 T 在修改数据 R 之前必须先对其加 X 锁，**直到事务结束**才释放（事务结束包括正常结束 COMMIT 和非正常结束 ROLLBACK）。

一级封锁协议可防止丢失修改，并保证事务 T 是可恢复的。但在该协议中，如果仅读取数据而不修改，是不需要加锁的，这就不能保证可重复度和不读“脏”数据。

#### 2.2.2. 二级封锁协议

二级封锁协议指的是，在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，**读完后**即可释放 S 锁。

二级封锁协议除防止丢失修改，还可进一步防止读“脏”数据。但由于读完数据后即可释放 S 锁，因此不能保证可重复读。

#### 2.2.3. 三级封锁协议

三级封锁协议指的是，在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，**直到事务结束**才释放。

三级封锁协议除了防止丢失修改和读“脏”数据外，还解决了不可重复读问题。

### 2.3. 活锁与死锁

和操作系统一样，封锁的方法可能引起活锁和死锁等问题。

#### 2.3.1. 活锁

若事务 T1 封锁了数据 R，事务 T2 又请求封锁 R，于是 T2 等待。T3 也请求封锁 R，当 T1 释放了 R 上的封锁之后系统首先批准了 T3 的请求，T2 仍然等待……由于存在“插队”情况，T2 有可能永远等待，这就是活锁的情形。

避免活锁的简单方法是采用先来先服务的策略。

#### 2.3.2. 死锁

若事务 T1 封锁了数据 R1，T2 封锁了数据 R2，然后 T1 又请求封锁 R2，因 T2 已封锁了 R2，于是 T1 等待 T2 释放 R2 上的锁。接着 T2 又申请封锁 R1，因 T1 已封锁了 R1，T2 也只能等待 T1 释放 R1 上的锁。这就出现了 T1 在等待 T2，而 T2 又在等待 T1 的情形，T1 和 T2 两个事务永远不能结束，形成死锁。

在数据库中解决死锁问题主要有两类方法：
- 采取一定措施来预防死锁的发生。
- 允许发生死锁，采用一定手段定期诊断系统中有无死锁，若有则解除之。

##### 2.3.2.1. 死锁的预防

防止死锁的发生其实就是要破坏产生死锁的条件：
- 一次封锁法

  一次封锁法要求每个事务都必须一次将所有要使用的数据全部加锁，否则就不能继续执行。

  一次封锁法虽然可以有效地防止死锁的发生，但扩大了封锁的范围，从而降低了系统的并发度；且数据库中数据是不断变化的，很难事先精确地确定每个事务所要封锁的数据对象，为此只能扩大封锁范围，进一步降低了并发度。

- 顺序封锁法

  顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实施封锁。例如，在 B 树结构的索引中，可规定封锁的顺序必须是从根结点开始，然后是下一级的子结点，逐级封锁。

  顺序封锁法虽然可以有效地防止死锁的发生，但同样存在问题：
  - 数据库系统的封锁的数据对象极多，并且不断变化，要维护这样的资源的封锁顺序非常困难，成本非常高。
  - 事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此很难按规定顺序去施加封锁。

可见，在操作系统中广为采用的预防死锁的方法并不太适合数据库的特点，因此**数据库管理系统在解决死锁的问题上普遍采用的是诊断并解除死锁的方法**。

##### 2.3.2.2. 死锁的诊断与解除

数据库系统中诊断死锁的方法与操作系统类似，一般使用超时法或事务等待图法。

- 超时法

  如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。

  该方法实现简单，但其不足也很明显：
  - 有可能会误判
  - 时限若设置太长，死锁发生后不能及时实现

- 等待图法

  事务等待图是一个有向图 G=(T, U)，T 为结点的集合，每个结点表示正运行的事务，U 为边的集合，每条边表示事务等待的情况（若 T1 等待 T2，则从 T1 指向 T2）。

  事务等待图是最常用的死锁诊断方法。它动态地反映了所有事务的等待情况。并发控制子系统周期地生成事务等待图，并进行检测。如果发现图中存在回路，则表示系统中出现了死锁。

通常解除死锁的方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，使其它事务得以继续运行下去。当然，对撤销的事务所执行的数据修改操作必须加以恢复。

### 2.4. 并发调度

数据库管理系统对并发事务不同的调度可能会产生不同的结果，其中，串行调度和执行结果等价于串行调度的调度是正确的调度。

#### 2.4.1. 可串行性

多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行执行这些事务时的结果相同，称这种调度策略为可串行化调度。

可串行性是并发事务正确调度的准则，按这个准则规定，一个给定的并发调度，当且仅当它是可串行化的，才认为是正确的调度。

冲突操作是指不同的事务对同一个数据的读写操作和写写操作。不同事务的冲突操作和同一事务的两个操作是不能交换的。

一个调度 Sc 在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度 Sc'，如果 Sc'是串行的，称调度 Sc 为冲突可串行化的调度。若一个调度是冲突可串行化的，则一定是可串行化的调度。

应该指出的是，**冲突可串行化调度是可串行化调度的充分条件，不是必要条件。**

#### 2.4.2. 两段锁协议

为保证并发调度的正确性，数据库管理系统的并发控制机制必须提供一定的手段来保证调度是可串行化的。目前，数据库管理系统普遍采用两段锁协议 ( 2 PL ) 的方法实现并发调度的可串行性，从而保证调度的正确性。

两端锁协议要求所有事务必须分为两个阶段对数据项进行加锁和解锁。事务都分为两个阶段：
- 扩展阶段：在这个阶段，事务可以申请获得任何数据项上的任何类型的锁，但不能释放任何锁。
- 收缩阶段：在这个阶段，事务可以释放任何数据项上的任何类型的锁，但不能再申请锁。
可以证明，若并发执行的所有事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。

应该指出的是，**事务遵守两段锁协议是可串行化调度的充分条件，不是必要条件**。

两段锁协议与一次封锁法的异同：
- 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，因此一次封锁法遵守两段锁协议。
- 两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。

### 2.5. 锁的粒度

封锁对象的大小称为封锁粒度。

在一个系统中同时支持多种封锁粒度供不同的事务选择是比较理想的，这种封锁方法称为多粒度封锁。选择封锁粒度时应同时考虑封锁开销和并发度两个因素，适当选择封锁粒度以求得最优的效果。一般情况下：
- 只需要处理少量元组的用户事务可以以元组为封锁粒度。
- 需要处理某个关系的大量元组的事务可以以关系为封锁粒度。
- 需要处理多个关系的大量元组的事务可以以数据库为封锁粒度。

### 2.6. 意向锁

对某个数据对象加锁，系统要检查该数据对象上有无显式封锁与之冲突，再检查其所有上级结点，看本事务的显式封锁是否与该数据对象上的隐式封锁冲突；还要检查其所有下级结点，看其显式封锁是否与本事务的隐式封锁冲突。这样的检查方法显然效率很低，因此，可以使用意向锁，从而无须再诸葛检查下一级结点的显式封锁。

意向锁的含义是如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。对任一结点加锁时，都必须先对它的上层节点加意向锁。

常用的意向锁包括：
- 意向共享锁 (IS 锁): 如果对一个数据对象加 IS 锁，表示它的后裔结点拟加 S 锁。
- 意向排他锁 (IX 锁): 如果对一个数据对象加 IX 锁，表示它的后裔结点拟加 X 锁。
- 共享意向排他锁 (SIX 锁): 如果对一个数据对象加 SIX 锁，表示对它的 S 锁，再加 IX 锁，即 SIX=S+IX。

在具有意向锁的多粒度封锁方法中，任意事务 T 要对一个数据对象加锁，必须先对它的上层结点加意向锁。申请封锁时应该按照自上而下的次序进行，释放封锁时则应该按自下而上的次序进行。

具有意向锁的多粒度封锁方法提高了系统的并发度，减少了加锁和解锁的开销，已经在实际的数据库管理系统产品中得到广泛应用。
