
- [数据结构：树结构 - 查找树 - 二叉查找树](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E7%BB%93%E6%9E%84---%E6%9F%A5%E6%89%BE%E6%A0%91---%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91)
    - [1. 基本概念](#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [2. 基本操作](#2-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)
        - [2.1. 查找元素](#21-%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0)
        - [2.2. 插入元素](#22-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0)
        - [2.3. 删除元素](#23-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0)
    - [3. Refer Links](#3-refer-links)

# 数据结构：树结构 - 查找树 - 二叉查找树

## 1. 基本概念

二叉查找树（Binary Search Tree）又称为二叉排序树（Binary Sort Tree）或 BST。

- 非递归形式定义：
  
  它是一颗二叉树，或者为空，或者具有下列性质：
  - 任一非叶子结点若有左孩子，则该结点的关键字值大于其左孩子结点的关键字值。
  - 任一非叶子结点若有右孩子，则该结点的关键字值小于其右孩子结点的关键字值。

- 递归形式定义：
  它是一棵树，或者为空，或者具有如下性质：
  - 若左子树不空，则左子树上所有结点的值均小于它的根结点的值。
  - 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。
  - 左、右子树也分别为二叉排序树。
  - 没有键值相等的节点。

- 性质
  
  若对二叉查找树进行中序遍历，可得到有序的数列。

- 时间复杂度
  
  二叉查找树的运行时间和树的形状有关，树的形状又和插入元素的顺序有关。在最好的情况下，节点完全平衡，从根节点到最底层叶子节点只有 lgN 个节点。在最差的情况下，根节点到最底层叶子节点会有 N 各节点。在一般情况下，树的形状和最好的情况接近。
  
  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/27/8f409dddd32c88b882ef7386c0442fbb.jpg)

  原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这也是平衡查找树设计的初衷。
　
  二叉查找树的高度决定了二叉查找树的查找效率。

## 2. 基本操作

### 2.1. 查找元素

当二叉排序树非空时，先将给定值和根结点的关键字进行比较，若相等，则查找成功，否则根据给定值和根结点的关键字之间的大小关系，分别在左子树或右子树上继续进行查找。

```cpp
//BST 搜索，递归实现
pnode search_BST(pnode p, int x)
{
  if(!p || p->val == x) {
    return p;
  }
  else if (x < p->val) {
    return search_BST(p->lchild, x);
  }
  else if (x > p->val) {
    return search_BST(p->rchild, x);
  }
}
```

```cpp
//BST 搜索，非递归实现
pnode search_BST(pnode p, int x)
{
    bool solve = false;
    while(p && !solve){
        if(x == p->val){
            solve = true;    
        }    
        else if(x < p->val){
            p = p->lchild;    
        }
        else{
            p = p->rchild;    
        }
    }
    if(p == NULL){
        cout << "没有找到" << x << endl;    
    } 
    return p;
}
```

### 2.2. 插入元素

根据二叉排序树的特点，新插入的结点肯定是叶子结点。

在二叉查找树插入元素的过程如下：
- 若当前的二叉查找树为空，则插入的元素为根节点。
- 若插入的元素值小于根节点值，则将元素插入到左子树中。
- 若插入的元素值不小于根节点值，则将元素插入到右子树中。

```cpp
struct node
{
    int val;
    pnode lchild;
    pnode rchild;
};
pnode BT = NULL;
```

```cpp
// 递归方法插入节点 
pnode insert(pnode root, int x)
{
    pnode p = (pnode)malloc(LEN);
    p->val = x;
    p->lchild = NULL;
    p->rchild = NULL;
    if(root == NULL){
        root = p;    
    }    
    else if(x < root->val){
        root->lchild = insert(root->lchild, x);    
    }
    else{
        root->rchild = insert(root->rchild, x);    
    }
    return root;
}
```
```cpp
// 非递归方法插入节点 
void insert_BST(pnode q, int x)
{
    pnode p = (pnode)malloc(LEN);
    p->val = x;
    p->lchild = NULL;
    p->rchild = NULL;
    if(q == NULL){
        BT = p;
        return ;    
    }        
    while(q->lchild != p && q->rchild != p){
        if(x < q->val){
            if(q->lchild){
                q = q->lchild;    
            } else{
                q->lchild = p;
            }        
        } else{
            if(q->rchild){
                q = q->rchild;    
            } else{
                q->rchild = p;    
            }
        }
    }
    return;
}
```

### 2.3. 删除元素

二叉查找树中元素的删除，分三种情况进行处理：
- p 为叶子节点，直接删除该节点，再修改其父节点的指针（注意区分是否是根节点），如图 a。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/27/28068b940df37fd51ded58edcd1396e7.jpg)

- p 为单支节点（即只有左子树或右子树）。让 p 的子树与 p 的父亲节点相连，删除 p 即可（注意区分是否是根节点），如图 b。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/27/5e446c5e5fd5248673e938082677a0aa.jpg)

- p 的左子树和右子树均不空。
  - 方法 Ⅰ：找到 p 的后继 y，因为 y 一定没有左子树，所以可以删除 y，并让 y 的父亲节点成为 y 的右子树的父亲节点，并用 y 的值代替 p 的值。
  - 方法 Ⅱ：找到 p 的前驱 x，x 一定没有右子树，所以可以删除 x，并让 x 的父亲节点成为 y 的左子树的父亲节点。如图 c。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/27/30ed7de87e4b66d091ef662a339846de.jpg)

```cpp
bool delete_BST(pnode p, int x) // 返回一个标志，表示是否找到被删元素 
{
    bool find = false;
    pnode q;
    p = BT;
    while(p && !find){  // 寻找被删元素 
        if(x == p->val){  // 找到被删元素 
            find = true;    
        }    
        else if(x < p->val){ // 沿左子树找 
            q = p;
            p = p->lchild;    
        }
        else{   // 沿右子树找 
            q = p;
            p = p->rchild;    
        }
    }
    if(p == NULL){   // 没找到 
        cout << "没有找到" << x << endl;    
    }
    
    if(p->lchild == NULL && p->rchild == NULL){  //p 为叶子节点 
        if(p == BT){  //p 为根节点 
            BT = NULL;    
        }
        else if(q->lchild == p){   
            q->lchild = NULL;
        }        
        else{
            q->rchild = NULL;    
        }
        free(p);  // 释放节点 p 
    }
    else if(p->lchild == NULL || p->rchild == NULL){ //p 为单支子树 
        if(p == BT){  //p 为根节点 
            if(p->lchild == NULL){
                BT = p->rchild;    
            }    
            else{
                BT = p->lchild;    
            }
        }    
        else{
            if(q->lchild == p && p->lchild){ //p 是 q 的左子树且 p 有左子树 
                q->lchild = p->lchild;    // 将 p 的左子树链接到 q 的左指针上 
            }    
            else if(q->lchild == p && p->rchild){
                q->lchild = p->rchild;    
            }
            else if(q->rchild == p && p->lchild){
                q->rchild = p->lchild;    
            }
            else{
                q->rchild = p->rchild;
            }
        }
        free(p);
    }
    else{ //p 的左右子树均不为空 
        pnode t = p;
        pnode s = p->lchild;  // 从 p 的左子节点开始 
        while(s->rchild){  // 找到 p 的前驱，即 p 左子树中值最大的节点 
            t = s;   
            s = s->rchild;    
        }
        p->val = s->val;   // 把节点 s 的值赋给 p 
        if(t == p){
            p->lchild = s->lchild;    
        }    
        else{
            t->rchild = s->lchild;    
        }
        free(s); 
    }
    return find;
}
```

## 3. Refer Links

https://www.v2ex.com/t/432927 

https://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html

https://www.cnblogs.com/maybe2030/p/4732377.html

http://www.cppblog.com/cxiaojia/archive/2016/06/03/186752.html