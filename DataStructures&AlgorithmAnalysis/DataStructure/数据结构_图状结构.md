- [数据结构：图结构](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9B%BE%E7%BB%93%E6%9E%84)
  - [1. 基本概念](#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [1.1. 图的二元组定义](#11-%E5%9B%BE%E7%9A%84%E4%BA%8C%E5%85%83%E7%BB%84%E5%AE%9A%E4%B9%89)
    - [1.2. 有向图和无向图](#12-%E6%9C%89%E5%90%91%E5%9B%BE%E5%92%8C%E6%97%A0%E5%90%91%E5%9B%BE)
    - [1.3. 度](#13-%E5%BA%A6)
    - [1.4. 图的分类](#14-%E5%9B%BE%E7%9A%84%E5%88%86%E7%B1%BB)
    - [1.5. 子图和补图](#15-%E5%AD%90%E5%9B%BE%E5%92%8C%E8%A1%A5%E5%9B%BE)
    - [1.6. 图的同构](#16-%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84)
    - [1.7. 通路与回路](#17-%E9%80%9A%E8%B7%AF%E4%B8%8E%E5%9B%9E%E8%B7%AF)
    - [1.8. 连通与可达](#18-%E8%BF%9E%E9%80%9A%E4%B8%8E%E5%8F%AF%E8%BE%BE)
    - [1.9. 生成树](#19-%E7%94%9F%E6%88%90%E6%A0%91)
  - [2. 存储结构](#2-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
    - [2.1. 邻接矩阵](#21-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5)
    - [2.2. 邻接表](#22-%E9%82%BB%E6%8E%A5%E8%A1%A8)
    - [2.3. 十字链表（有向图）](#23-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%89)
    - [2.4. 邻接多重表（无向图）](#24-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89)
  - [3. 图的遍历](#3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86)
    - [3.1. 深度优先遍历 DFS](#31-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-dfs)
      - [3.1.1. 递归实现](#311-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0)
      - [3.1.2. 非递归实现](#312-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0)
      - [3.1.3. 应用](#313-%E5%BA%94%E7%94%A8)
    - [3.2. 广度优先遍历 BFS](#32-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-bfs)
      - [3.2.1. 非递归实现](#321-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0)
      - [3.2.2. 应用](#322-%E5%BA%94%E7%94%A8)
  - [4. 图的连通性问题](#4-%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98)
    - [4.1. 求非连通图的连通分量](#41-%E6%B1%82%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F)
    - [4.2. 求连通图的生成树](#42-%E6%B1%82%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91)
    - [4.3. 求非连通图的生成森林](#43-%E6%B1%82%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97)
  - [5. AOV 和 AOE](#5-aov-%E5%92%8C-aoe)
    - [5.1. DAG](#51-dag)
    - [5.2. AOV 网与拓扑排序算法](#52-aov-%E7%BD%91%E4%B8%8E%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)
    - [5.3. AOE 网与关键路径算法](#53-aoe-%E7%BD%91%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95)
  - [6. 最小生成树算法](#6-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95)
    - [6.1. Prim](#61-prim)
    - [6.2. Kruskal](#62-kruskal)
  - [7. 最短路径算法](#7-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95)
    - [7.1. 单源最短路径算法：Dijkstra 算法](#71-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%EF%BC%9Adijkstra-%E7%AE%97%E6%B3%95)
    - [7.2. BFS、双向 BFS](#72-bfs%E3%80%81%E5%8F%8C%E5%90%91-bfs)
    - [7.3. 多源最短路径算法：floyd-warshall](#73-%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%EF%BC%9Afloyd-warshall)
    - [7.4. bellman-ford](#74-bellman-ford)
    - [7.5. SPFA](#75-spfa)
    - [7.6. A*](#76-a)
    - [7.7. D*](#77-d)
  - [8. Refer Links](#8-refer-links)

# 数据结构：图结构

图是一种比树更复杂的非线性结构。在这种结构中，任意两个结点之间都可能存在关系，即结点之间的连接关系是任意的，因此图可用来描述更加复杂的数据对象。

## 1. 基本概念

### 1.1. 图的二元组定义

图 G 由两个集合 V 和 E 组成，记为 G=(V, E)。其中，V 是顶点（Vertex，图中的数据元素）的有穷非空集合，E 是 V 中顶点对（也称为边，表示两个顶点之间的关系）的有穷集。通常，也将图 G 的顶点集和边集分别记为 V(G) 和 E(G)。E(G) 可以是空集，若 E(G) 为空，则图 G 只有顶点而没有边。

### 1.2. 有向图和无向图

- 有向图

  若图 G 中的每条边都是有方向的，则称 G 为有向图（digraph）。在有向图中，一条有向边是由两个顶点组成的有序对，有序对通常用尖括号表示，一个有向图可表示为：D=<V, E>。

  **有向边也称为弧（arc），边的始点称为弧尾（tail），终点称为弧头（head）**。例如，<vi, vj>表示一条有向边，vi 是边的始点（起点），vj 是边的终点。因此，<vi, vj>和<vj, vi>是两条不同的有向边。

- 无向图

  若图 G 中的每条边都是没有方向的，则称 G 为无向图（undigraph）。无向图中的边均是顶点的无序对，无序对通常用圆括号表示，一个无向图可以表示为：G=(V, E)。

- 平行边：如果关联一对结点的边多于一条，则称这些边为平行边。

- 邻接：如果有边关联于一对结点，则称这对结点是邻接的（邻接是针对结点的概念，而不是针对边的概念）。

- 环：一条边的两个端点如果关联于同一个结点，则称为环。

- 孤立点：和任何边都不关联的点称为孤立点。

- n 阶图：n 个顶点的图。

- 零图：E 为空集的图，即只有顶点没有边的图。

- 平凡图：1 阶零图，即只有 1 个顶点没有边的图。

- 空图：V 为空集的图，即没有顶点也没有边的图。

### 1.3. 度

- 度：设 G=<V,E>为无向图，v ∈ V, v 所关联的边数称为 v 的度数，简称度，记作 d(v)。注：在无向图中每个环提供给它的结点 2 度。

- 悬挂顶点：度数为 1 的顶点。

- 悬挂边：与悬挂顶点关联的边。

- **握手定理：任何图中所有结点的度数之和为边数的两倍**。

### 1.4. 图的分类

- 简单图：设图 G=（V，E）为无向图或有向图，如果 G 中**不含平行边，也不含环**，则称为简单图。

- 多重图：设图 G=（V，E）为无向图或有向图，如果 G 中**含有平行边**，则称为多重图。

- 完全图
  - 无向完全图：设 G =（V，E）是 n 阶无向简单图，若 **G 中任何结点都与其余的 n-1 个结点相邻**，则称 G 为 n 阶无向完全图，记作 Kn。n 阶无向完全图中，每个结点的度数为 n-1，所有结点的总度数为 n(n-1)，边数为 n(n-1)/2。

  - 有向完全图：设 G =（V，E）为 n 阶有向简单图，若**对于 V 中任意的两个结点 u 和 v，既有有向边<u，v>，又有有向边<v，u>**，则称 G 是 n 阶有向完全图。n 阶有向完全图中，每个结点的度数为 n-1，所有结点的总度数为 n(n-1)，边数为 n(n-1)。

  **无特别说明时，完全图均指无向完全图。**n 阶完全图的总边数和总度数都是确定的。

- 正则图：设 G 为 n 阶无向简单图，若对于任意 v ∈ V（G），均有 d(v)=k, 则称 G 为 k - 正则图，即 k - 正则图中每个结点的度数都等于 k。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/fcea8216d1e0a11f6a65b636858108a9.jpg)

- 环图：如果图 G =（V，E）的结点集 V={v1, v2, ..., vn}（n >= 3），边集 E={(v1, v2), (v2, v3), , ( vn-1, vn), (vn, v1)}，则称 G 为环图，记为 Cn。环图都是 2 - 正则图。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/12d046cec77472d8e4c19928090f7012.jpg)

- 轮图：当给环图 Cn-1（n >= 4）添加一个结点，并把这个结点和 Cn-1 里的每个结点逐个连接后得到的图成为轮图，记作 Wn。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/d608c08b4dd74cb74920e976ba8604e3.jpg)

- 方体图：如果图 G =（V，E）有 2^n 个结点，每个结点表示一个长度为 n 的位串，任何两个相邻的结点表示的位串只有一位不同，则称 G 称为 n 方体图，记作 Qn。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/9ffdcf42db33caf1d5def7e8cd822d8e.jpg)

- 二分图：如果图 G =（V，E）的结点集 V 能划分为两个子集：V1 和 V2，使每条边有一个端点在 V1 中，另一个端点在 V2 中，则称该图为二分图（或二部图）。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/1b70f42ead3e89de6c7516fd3db95d27.jpg)

  - 完全二分图：二分图 G =（V，E）的结点集 V 能划分为两个子集：V1 和 V2，若 V1 中的每个结点和 V2 中的每个结点均有边相连，则称 G 为完全二分图。若|V1|=m，|V2|=n, 则可记为 Km,n。下图所示的是 K2,3 和 K3,3：

    ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/1b7ad9b984c8c7c1c12aaea380bc397f.jpg)

- 带权图 / 网：每个结点或每条边都带有数值的图称为带权图 / 网。

  下图左边为边带权图，右边为结点带权图：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/d8cd0279d932acf739119fc8ba3ea308.jpg)

- 欧拉图

  设 G=(V, E) 是无向图或有向图，若 G 中有一条包含所有边（有向边）的简单回路，则称该回路为欧拉回路，称图 G 为欧拉图。

  若 G 中有一条包含 G 中所有边（有向边）的简单通路，则称为欧拉通路，称图 G 为半欧拉图。

- 哈密顿图

  设 G=(V, E) 是无向图或有向图，若 G 中有一条包含 G 中的每一个顶点一次且仅一次的回路，则称该回路为哈密顿回路，称图 G 为哈密顿图。

  若图 G 有一条包含 G 的所有结点的通路，则称该通路为哈密顿通路，称图 G 为半哈密顿图。

### 1.5. 子图和补图

- 子图

  设 G =（V，E）和 G1=(V1，E1) 是两个图。
  - 子图：若 V1 ⊆V，且 E1 ⊆ E，则称 G1 是 G 的子图，G 是 G1 的母图，记作 G1 ⊆ G。　
  - 真子图：若 G1 ⊆ G 且 G1 != G( 即 V1 != V, 或 E1 != E )，则称 G1 是 G 的真子图。　　
  - 生成子图：若 G1 ⊆ G 且 V1 = V，则称 G1 是 G 的生成子图。

  NOTE: 两个完全相同的图有子图关系，也有生成子图关系。

  例：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/37bca8a198dd7dc635105beff87d83c7.jpg)
  ```
  (1),(2),(3) 是 (1) 的子图，(2),(3) 是真子图，(1) 是母图。
  (1),(3) 是 (1) 的生成子图。
  (2) 是{d,e,f }的导出子图，也是{e5, e6, e7}导出子图。
  (3) 是{e1, e3, e5, e7}的导出子图
  ```

- 补图  

  设 G=(V，E) 是 n 阶无向简单图或有向简单图。以 V 为结点，以所有能使 G 成为完全图需添加的边组成的集合为边集的图，称为 G 相对于完全图的补图，简称 G 的补图，记作 ~G。

  补图的应用：发表在 1958 年美国《数学月刊》上的一个数学问题：在任意 6 个人的集会上，总会有 3 个人互相认识或有 3 个人互相不认识（假设认识是相互的）。

### 1.6. 图的同构

设两个图 G=（V，E）和 G'=（V '，E'），如果从 V 到 V '存在双射函数 f，使得对于任意的 u，v ∈ V，(u，v) ∈ E, 当且仅当 (f(u)，f(v)) ∈ E' ；如果在 u，v 间存在平行边，则关联于结点 u，v 的平行边数与关联于结点 f(u)，f(v) 的平行边数相同，则称 G 与 G'是同构的。
  

由此可见，判断两个图同构的必要条件（不是两个图同构的充分条件）：
- 必须具有相同的顶点数。
- 必须具有相同的边数。
- 度数相同的结点数相等（对应顶点的度数相同）。
- 相同长度的回路数相同。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/c9d1532e2f14d8eefc3616e349b3b669.jpg)

### 1.7. 通路与回路

- 通路：给定图 G=（V，E）中，以 v0 为起点，vn 为终点的由结点和边交替出现的序列 v0e1v1e2v2…vn-1envn 称为从结点 v0 到 vn 的长度为 n 的通路。

  - 简单通路 / 迹：若通路中的**所有边互不相同**，则称它为简单通路或迹。

  - 基本通路 / 初级通路 / 路径：若通路中的**所有结点互不相同，所有边互不相同**，则称它为基本通路或初级通路、路径。 

- 回路：若一条通路的起点和终点是同一点，称它是一条回路。 

  - 简单回路 / 闭迹：若回路中的**所有边互不相同**，则称它为简单回路或闭迹。

  - 基本回路 / 初级回路 / 圈：若回路中的**所有结点互不相同，所有边互不相同**，则称它为基本回路或初级回路、圈。

### 1.8. 连通与可达

- 连通（无向图）
  
  若**无向图** G 中**任意两结点间都有一条通路**（长度 >= 1），则称 G 是连通图；否则，称 G 是非连通图。

  **连通属于等价关系，可用于有向图和无向图。**

- 可达

  设**有向图** G=（V,E）, 对于 G 中任意两个结点 u 和 v，若从 u 到 v 存在通路，则称 u 到 v 是可达的。若 u 可达 v 且 v 可达 u，则称 u 和 v 是相互可达的。

  **可达属于非等价关系（不具有对称性），仅可用于有向图。**

- 有向连通图：具有以下三种连通性中的任何一种的有向图称为有向连通图。
  
  - 单向连通：若 G 的任意两个结点间至少从一个结点到另一个结点是可达的，则称 G 是单向连通的。G 是单向连通的当且仅当 G 中存在经过所有顶点的通路。

  - 强连通：若 G 的任意两个结点间是互相可达的，则称 G 是强连通的。G 是强连通的当且仅当 G 中存在经过所有顶点的回路。

    - 强分图：每个 Vi 导出的子图 Gi 是强连通的，称为 G 的一个强分图。

  - 弱连通：若 G 在略去有向边的方向后所得到的无向图是连通的，则称 G 是弱连通的。

- 极大连通子图
  
  - 无向连通图中：一个无向连通图的极大连通子图为其本身（又称为连通分量）。
  
  - 有向连通图中：一个有向连通图的极大连通子图为其本身（又称为强连通分量）。
  
  - 非连通图中：非连通图有多个极大连通子图（说傻话就是分拨，连着的分一拨，每拨都是极大连通子图）。

- 极小连通子图
  
  - 无向连通图中：一个无向连通图的极小连通子图为其生成树。就像一个四边形，四个节点四条边，其实三条边就能连通了，所以四个节点三条边，就 OK 了，就是在能连通的前提下，把多余的边去掉。
  
  - 有向连通图中：有向连通图中不存在极小连通子图的概念。
  
  - 非连通图：非连通图中不存在极小连通子图的概念。

### 1.9. 生成树

- 生成树

  生成树表示一个无向图中符合特定条件的子图：V 表示顶点，E 表示边，若图 G = (V(G),E(G)) 和树 T = (V(T),E(T))，有 E(T) ⊂ E(G) 和 V(G) = V(T)，那么 T 是 G 的生成树。

- 最小生成树 / 最小权重生成树

  一个连通图的生成树可能有多个。当连通图中的边具有权值时，权值之和最小的生成树称为最小生成树。广义上而言，对于非连通无向图来说，它的每一连通分量同样有最小生成树。

  **一个连通图的生成树为该连通图的一个极小连通子图**。

  以有线电视电缆的架设为例，若只能沿著街道布线，则以街道为边，而路口为顶点，其中必然有一最小生成树能使布线成本最低。

## 2. 存储结构

图的存储表示方法最常用的有 4 种，分别是邻接矩阵、邻接表、邻接多重表和十字链表表示法，在使用过程中要根据具体的应用特点和相关操作来进行选择。

### 2.1. 邻接矩阵

邻接矩阵（adjacency matrix）是一种**用边的集合表示图**的方法，其中边的集合用一个**二维数组**表示，数组的每个元素表示一条边，元素的两个下标值分别表示边的两个端点的编号，结点编号与数组的下标相对应。

图的邻接矩阵可定义为：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/0724111edac794ff3a3c7fb4579d9ac8.jpg)

通过邻接矩阵，很容易判断任意两个顶点之间是否有边（或弧）相连，同时，也可以很方便地求得各个顶点的度。对于无向图，顶点 i 的度是邻接矩阵中第 i 行（或第 i 列）的元素之和；对于有向图，第 i 行的元素之和为顶点 vi 的出度 OD(vi)，第 j 列的元素之和为顶点 vj 的入度 ID(vj)。

对于边数相对顶点较少的图，会造成极大的空间浪费。

邻接矩阵适用于有向图和无向图。

### 2.2. 邻接表

邻接表（adjacency list）是图的顺序存储和链式存储相结合的一种存储方法，它是一种**用顶点表示图**的方法。该方法对图 G 中的每个顶点 vi 建立一个单链表，将所有邻接于 vi 的顶点放到该链表中。每个结点包含三个域：
- 邻接点域（adjvex），指示与顶点 vi 邻接的点的连接关系；
- 链域（nextarc），指示下一条边或弧的结点；
- 数据域（info），存储与边或弧相关的信息，如权值等。
每个链表上附设一个头结点，该结点除了设有链域（firstarc）指向链表中第一个结点之外，还设有存储顶点 vi 的名称或其他有关信息的数据域（data）。头结点通常采用顺序结构进行存储，以便进行随机访问。

例：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/e10ecebe96841bf8048ffdf2d18ca161.jpg)

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/89fe259a03d8e1b8f975be7d41098152.jpg)

为了便于确定顶点的入度或以顶点 vi 为头的弧，可建立一个有向图的逆邻接表，即对每个顶点 vi 建立一个链接以 vi 为头的弧的表。例如，下图所示为有向图 Gl 的逆邻接表：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/ec6de105ec5506c013e755262684774c.jpg)

在邻接表上找任意一个顶点的第一个邻接点和下一个邻接点比较容易，但要判定任意两个顶点 vi 和 vj 之间是否有边或有弧相连，则需搜索第 i 个或第 j 个链表，此操作不如邻接矩阵方便。

邻接表适用于有向图和无向图。

### 2.3. 十字链表（有向图）

十字链表（orthogonal list）是一种**用边表示图**的方法，它实际上是邻接表与逆邻接表的结合，即把每条弧的两个结点分别放入以弧尾顶点为头结点的链表和以弧头顶点为头结点的链表中。

在十字链表中，有向图的每个弧和每个顶点都有一个结点，结点的结构如下所示：
- 弧结点

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/63d4f55ea2feacbaf32c80992817c8c4.jpg)

  在弧结点中有 5 个域：
  - 信息域（info）：指向该弧的相关信息。无相关信息时，可用“#”表示。
  - 尾域（tailvex）：指示弧尾（起点）顶点编号。
  - 头域（headvex）：指示弧头（终点）顶点编号。
  - 头链域（hlink）：指向弧头（终点）相同的下一条弧。
  - 尾链域（tlink）：指向弧尾（起点）相同的下一条弧。
- 头结点（顶点结点）

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/da7e3604846b7717abb1c8dbc14eded2.jpg)

  顶点结点有 3 个域：
  - 数据域（data）：存储与顶点相关的信息，如顶点的名称等。
  - 入链域（firstin）：指向以该顶点为弧头（终点）的第一个弧结点。
  - 出链域（firstout）：指向以该顶点为弧尾（起点）的第一个弧结点。

例：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/6111c9f7108e682435e7e29d829c2a4f.jpg)

在十字链表中，同时具备邻接表与逆邻接表的优点。既容易找到以 vi 为尾的弧，也容易找到以 vi 为头的弧，因此容易求得顶点的出度和入度，并且，建立十字链表的时间复杂度与建立邻接表的是相同的。但由于十字链表中每个链表结点（图中的边对应的结点）有两个链域，所以它的存储效率要比邻接表低。

如果将图的邻接矩阵用矩阵的十字链表表示，可发现，图的十字链表是图的邻接矩阵的十字链表的变形。二者的主要差别是：
- 前者的链表结点不需按起点与终点（相当于行号与列号）的大小顺序排列。
- 前者的“行”与“列”链表一般不需构成循环结构。

十字链表仅适用于有向图。

### 2.4. 邻接多重表（无向图）

邻接多重表（adjacency multilist）是存储无向图的一种链式结构。邻接多重表的存储结构和十字链表类似，也是由顶点表和边表组成的，每一条边用一个结点表示：
- 边表结点由以下 6 个域组成：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/83e89c597e94903807238ee531fbb1ba.jpg)

  - info 为与边相关的各种信息。无相关信息时，可用“#”表示。
  - mark 为标志域，可用于标记该条边是否被搜索过。
  - ivex 和 jvex 为该边依附的两个顶点在图中的位置。
  - ilink 指向下一条依附于顶点 ivex 的边。
  - jlink 指向下一条依附于顶点 jvex 的边。

- 顶点结点由以下 2 个域组成：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/3fbe54db92159ce6ccae814bfd500e01.jpg)

  - data 域存储和该顶点相关的信息；
  - firstedge 域指示第一条依附于该顶点的边。

例：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/06710c2ca10e7ba55a5a731cbb9f0fe6.jpg)

虽然用邻接表来存储无向图可以很容易求得图的顶点和边的各种信息，但邻接表将每条边（vi, vj）的两个结点放在不同的链表中，使得某些图的操作很不方便。例如，对图中已访问过的边作记号或删除一条边等，都需要找到同一条边的两个结点。因此，当进行这一类操作时，无向图多采用邻接多重表进行存储。

无向图的两种存储方法——邻接多重表和邻接表中，它们的差别仅仅在于同一条边用两个结点表示还是用一个结点表示，因此，邻接多重表除比邻接表在边结点中多增加一个标志域外，其他方面（如各种基本操作的实现等），二者都颇为相似。

邻接多重表仅适用于无向图。

## 3. 图的遍历

图的遍历（traversing graph）是指从某个顶点出发，对图中每个顶点各做一次且仅做一次访问，它是许多图算法的基础。

深度优先遍历和广度优先遍历是两种最重要的遍历图的方法，它们对无向图和有向图均适用。

### 3.1. 深度优先遍历 DFS

无向图的深度优先搜索（depth-first search，简称 DFS）遍历是从图中某个顶点 v 出发，访问此顶点，然后依次从 v 的未被访问的邻接点出发按深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问过，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止。

深度优先搜索遍历类似于树的前序遍历。

#### 3.1.1. 递归实现

伪代码：
```cpp
/* 从结点 v0 触发，深度优先遍历图 g，函数返回访问到的结点总数 */
long DFS( 图 g, 结点 v0 ) {
  long nNodes; // 寄存访问到的结点总数
  访问 v0;
  为 vo 设置已访问标志；
  nNodes = 1;

  求出 v0 的第 1 个可达邻接点 v;
  while( v 存在 ) {
    if ( v 未被访问过 ) {
      nNodes = nNodes + DFS(g, v);
    }
    求出 v0 的下一个可达邻接点 v;
  }
  return nNodes;
}
```

#### 3.1.2. 非递归实现

DFS 的非递归实现主要通过栈结构来实现。

伪代码：
```cpp
/* 从结点 v0 触发，深度优先遍历图 g，函数返回访问到的结点总数 */
long DFS( 图 g, 结点 v0 ) {
  long nNodes = 0; // 寄存访问到的结点总数
  访问 v0;
  为 vo 设置已访问标志；
  将 v0 进栈 S;
  nNodes = 1;

  求出 v0 的第 1 个可达邻接点 v;
  while( 栈 S 不为空 ) {
    v = 栈 S 顶部元素；
    求出 v 的下一个未访问的邻接点 i;
    访问 i;
    为 i 设置已访问标志；
    将 i 进栈 S;
    nNodes++;
    if ( v 已无未被访问过的邻接点 ) {
      将 v 出栈；
    }
  }
  return nNodes;
}
```

#### 3.1.3. 应用

TODO:

- 右手摸墙定律 / 迷宫遍历问题

- 马踏棋盘问题—哈密顿图（看离散课本）

### 3.2. 广度优先遍历 BFS

广度优先搜索（breadth first search，简称 BFS）遍历从图中某顶点 v 出发，在访问 v 之后依次访问 v 的各个未被访问过的邻接点，然后分别从这些邻接点出发再依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问，直至图中所有已被访问顶点的邻接点都被访问到为止。若此时图中尚有顶点未被访问过，则另选图中一个未曾被访问过的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止。

广度优先搜索遍历类似于树的层序遍历。

对于深度优先遍历，用递归方法描述很自然，而广度优先遍历则不然，使用递归描述反而会使问题复杂化，所以一般都使用非递归的方法来实现 BFS。

- 为什么使用 BFS 走迷宫的路程是最小值而使用 DFS 就不一定？

  - BFS 是每走一步，就把所有可能的下一步走法存入数组。然后数组指针向后移一位，也就是说 bfs 是把所有可能的走法全部同时走一遍，也就是说在同一时刻，走法的数组里还未判断的位置已经走过的步数是相同的（或者只差 1），这样一来，当抵达终点后，那一个算法一定是走的步数最少的。
  - 而 DFS 是把一条路走到底再换另一条，可以想象，一条很绕的路碰巧走到终点，DFS 就判断为计算出来了，当然不是最短。

#### 3.2.1. 非递归实现

BFS 的非递归实现通常使用队列结构来实现。

伪代码：
```cpp
/* 从结点 v0 触发，广度优先遍历图 g，函数返回访问到的结点总数 */
long DFS( 图 g, 结点 v0 ) {
  long nNodes = 0; // 寄存访问到的结点总数
  初始化队列 Q;
  if ( v0 存在 ) {
    v0 入队列 Q;
    将 v0 设置已访问标志；
  }

  while ( Q 不为空 ) {
    将队列 Q 的头部元素 v 出队列；
    访问 v;
    nNodes++;
    求出 v 的第 1 个可达邻接点 w;
    while ( w 存在 ) {
      if ( w 未被访问过 ) {
        w 入队列 Q;
        将 w 设置已访问标志；
      }
      求出 v 的下一个可达邻接点 w;
    }
  }
  
  return nNodes;
}
```

#### 3.2.2. 应用

TODO: 

最短路径

## 4. 图的连通性问题

### 4.1. 求非连通图的连通分量

图的连通性问题实质上是图的遍历的一种应用。

以无向图的遍历为例：
- 若是连通图，则从图中任一顶点出发进行深度优先搜索或广度优先搜索，便可访问到图中所有顶点；
- 若是非连通图，则**需要从多个顶点出发进行搜索，由此而得到图中各个连通分量中的顶点集**。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/5a12959ecca7fd06d15b8030abf2398b.jpg)

### 4.2. 求连通图的生成树

设 E(G) 为连通子图 G 中所有边的集合，则从图中任一顶点出发遍历图时，必定将 E(G) 分成两个集合 T(G) 和 B(G)，其中 T(G) 是遍历过程中经历的边的集合，B(G) 是剩余边的集合。显然，**T(G) 和图 G 中所有顶点一起构成连通图 G 的极小连通子图，是连通图的一棵生成树**。

由深度优先搜索得到的生成树为深度优先生成树，由广度优先搜索得到的生成树为广度优先生成树（生成树不唯一）。

例：下图所示分别为无向图 G4 的深度和广度优先生成树。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/67902c845ce8797cb01eaae344593a48.jpg)

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/bbee7c5e833a40c976348f7b118381d1.jpg)

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/75d39667f0976ed8b9d1a4c306f8ff8a.jpg)

### 4.3. 求非连通图的生成森林

对于非连通图，每个连通分量中的顶点集和遍历时走过的边一起构成若干棵生成树，这些连通分量的生成树组成非连通图的生成森林。

例：下图（c）所示为 G5 的深度优先生成森林，它由三棵深度优先生成树组成。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/701fe64116083cc821ab14383b570d5c.jpg)

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/b2cfe58ecaf6db4de25ebb278c2286dd.jpg)

## 5. AOV 和 AOE

### 5.1. DAG

有向无环图 (directed acyclic graph，简称 DAG) 是指一个无环的有向图，它是一种类似于有向树的特殊有向图。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/85101484af413f92682e9575ac989c32.jpg)

除了描述多项式以外，有向无环图也是描述一项工程或系统进行过程的有效工具。在一般情况下，工程由若干个称为“活动”（activity）的子工程组成，而这些子工程之间存在一定的约束条件（比如执行的先后次序）。**对整个工程而言，工程的顺利执行以及对整个工程完成所需要的最短时间的估算是人们最为关心的两个问题，而这两个问题的解决可通过对有向图进行拓扑排序和关键路径操作来实现**。

### 5.2. AOV 网与拓扑排序算法

- AOV

  在**有向图**中，**使用顶点表示活动，使用有向边表示活动之间的先后关系**，这样的图被称为顶点表示活动的网（activity on vertex network，AOV 网）。

  在网中，若从顶点 i 到顶点 j 有一条有向路径，则 i 是 j 的前驱，j 是 i 的后继。若<i, j>是网中一条弧，则 i 是 j 的直接前驱，j 是 i 的直接后继。AOV 网表示了活动之间的优先关系。

  例如，计算机专业的学生要拿到学位必须完成一系列规定的基本课程，这些课程中有的是独立于所有其他课程的基础课程，必须最先学习；有些课程作为某些课程的先修课程必须在那些课程之前进行学习；而有些课程可随时安排学习等。因此，课程的安排具有一定的先后次序。这个关系就适合用 AOV 网表示。

- 拓扑有序序列

  为保证 AOV 网所表示的工程活动能够全部顺利执行，**在 AOV 网中不应该出现回路，否则，就意味着某项活动要以自己为先决条件，显然，这是荒谬的，这样的工程无法完成**。测试 AOV 网是否存在回路的办法是，对该有向图构造其顶点的**拓扑有序序列**，若网中所有顶点都在它的拓扑有序序列中，则该 AOV 网中必定不存在环。

  拓扑排序，是将有向无环图 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v 有以下关系：若<u, v>∈E(G)，则 u 在线性序列中出现在 v 之前。通常，称这样的线性序列为满足拓扑次序（topological order）的序列，简称拓扑序列。

  拓扑序列具有以下 5 个特点：
  - **若将图中顶点按拓扑次序排成一行，则图中所有的有向边均是从左指向右的。**
  - 若图中存在有向环，则不可能使顶点满足拓扑次序。
  - 一个 DAG 的拓扑序列通常表示某种方案切实可行。
  - **一个 DAG 可能有多个拓扑序列**。
  - 当有向图中存在有向环时，拓扑序列不存在。

- 拓扑排序算法

  对 AOV 网进行拓扑排序的步骤是：
  1. 在 AOV 网中选一个入度为 0 即没有前驱的顶点并输出之。
  1. 从图中删除该顶点和所有以它为尾的弧。
  1. 重复上述两步，直到网中全部顶点都已输出，或者当前图中不存在入度为 0 的顶点为止（后一种情况则说明有向图中存在环）。
  
  对于上述操作步骤，可采用邻接表作有向图的存储结构，且在头结点中增加一个存放顶点入度的数组（indegree）。删除入度为零的顶点及以它为尾的弧的操作，可通过弧头顶点的入度减 1 来实现。为避免重复检测入度为零的顶点，可另设一**栈**暂存这些顶点，由此得到拓扑排序的算法。

  算法实现：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/ac62e80d69a373f4be5ced588e9bdb8d.jpg)

  分析以上程序，对有 n 个顶点和 e 条弧的有向图而言，建立求各顶点的入度的时间复杂度为 O(e)，建零入度顶点栈的时间复杂度为 O(n)。在拓扑排序过程中，若有向图无环，则每个顶点进一次栈，出一次栈，入度减 1 的操作在 while 语句中总共执行 e 次，所以总的**时间复杂度为 O(n+e)**。

### 5.3. AOE 网与关键路径算法

- AOE

  在**带权的有向图**中，**顶点表示事件（ 能被触发，拥有两个特征属性：最早发生时间 Ve(j); 最晚发生时间 Vl(j) ），边表示活动（ 能被开始，拥有两个特征属性：最早开始时间 e(i)；最晚开始时间 l(i) ）**，边上的权值表示活动的成本或时间等开销，此有向图称为 AOE 网（activity on edge network）。

  AOE 网中有两条原则：
  - 只有某顶点所代表的事件发生后，从该顶点出发的各活动才能开始。
  - 只有进入某顶点的各活动都结束，该顶点所代表的事件才能发生。
  
  **AOE 网与 AOV 网是既有联系又有区别的两种图，前者用于表示一项工程中各子工程之间的优先关系，而后者用来估算工程的完成时间。**通常，在 AOE 网中列出完成预定工程计划所需要进行的活动、每个活动计划完成的时间、与活动相关的事件以及事件和活动之间的关系等，由此来确定工程是否可行、总共需要的时间以及影响整个工程的关键活动。

  例：下图给出了一个有 15 项活动（a0, a1, a2, …, a14）的 AOE 网，包含 10 个事件（v0, v1, v2, v3, …, v9），其中，v0 为源点，表示工程的开始，v9 为汇点，表示整个工程结束。每个事件表示在它之前的活动已经完成，在它之后的活动可开始，与每个活动相联系的数是执行该活动所需的时间。在正常情况下，网中只有一个入度为零的点（源点）和一个出度为零的点（汇点）。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/76c0fdc66b394eafc377cf976c145db7.jpg)

- 关键路径 & 关键活动

  采用 AOE 网进行工程管理时，一般需要考虑两个问题：
  - 完成整项工程至少需要多长时间？
  - 哪些活动是影响工程进度的关键活动？

  由于 AOE 网中表示的活动**可并行进行**，所以完成整个工程所必须花费的最短时间是从源点到汇点的最长路径长度（即路径上各活动持续时间之和），具有最大路径长度的路径称为**关键路径**（critical path），关键路径上的活动称为**关键活动**，关键路径的长度是整个工程所需的最短时间。**只有提前完成关键活动才能加快工程的进度，缩短整个工期。**

  NOTE
  - AOE 中活动可并行，AOV 中不可并行。
  - 关键路径的长度是整个工程所需要的最短工期。
  - 关键路径并不一定只有一条，所以只改变一条，有时候不能改变全局。**当一个 AOE 图中同时有多条关键路径时，需要计算所有的关键路径才能进行完整的工程优化，此时应被优化的关键活动应是能影响到所有关键路径的活动，否则无法使整个工期缩短（“短板效应”）**。

- 关键路径算法

  关键路径算法是用于找到 AOE 网中的关键路径的算法。

  求关键路径的算法，只需理解顶点（事件）和边（活动）的各自的两个特征属性以及求法，然后取 e(i)=l(i) 的边即为关键路径上的边（关键路径可能不止一条）：
  1. 根据首结点的 Ve(j)=0，由前向后计算各顶点（事件）的最早发生时间。
  1. 根据终结点的 Vl(j)=Ve(j)，由后向前依次求解各顶点（事件）的最晚发生时间。
  1. 根据边的 e(i) 等于它的发出顶点的 Ve(j)，计算各边（活动）的最早开始时间（最早开始，对应最早发生）。
  1. 根据边的 l(i) 等于它的到达顶点的 Vl(j) 减去边的权值，计算各边（活动）的最晚开始时间（最晚开始，对应最晚发生）。

  - 例：求出以下 AOE 网所示工程的关键路径。

    ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/57a6e87422b87d63410be717d9def760.jpg)

    求出 AOE 网的 4 个特征属性：
    - Ve(j)：即从始点开始到顶点 Vk 的最大路径长度，表示事件发生的最早时间（etv: earliest time of vertex）。
      - 计算方法：
        - 从前向后，取大值：直接前驱结点的 Ve(j)＋到达边（指向顶点的边）的权值，有多个值的取较大者。
        - 首结点 Ve(j) 已知，为 0。
      - 计算过程：如上图各顶点（事件）的 Ve(j)： （从 V1 开始）

        ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/27af392475cf310f0500cbb9341f091e.jpg)

    - Vl(j)：在不推迟整个工期的前提下，事件 vk 允许的最晚发生时间 (ltv: lastest time of vertex)。
      - 计算方法：
        - 从后向前，取小值：直接后继结点的 Vl(j) –发出边（从顶点发出的边）的权值，有多个值的取较小者。
        - 终结点 Vl(j) 已知，等于它的 Ve(j)）。
      - 计算过程：如上图各顶点（事件）的 Vl(j)： （从 V7 开始，它的最早、最晚发生时间相同，都为 10）

        ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/99931dfa967623ad201546f3ae27d5b5.jpg)

    - e(i): 若活动 ai 由弧<vk,vj>表示，则活动 ai 的最早开始时间应该等于事件 vk 的最早发生时间。（ete: earliest time of edge）。

      有：e[i]=ve[k];（即：边（活动）的最早开始时间等于，它的发出顶点的最早发生时间）

      如上图各边（活动）的 e(i)：

      ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/cb1455050c13ca13baa6db60b5b027e9.jpg)  

    - l(i): 若活动 ai 由弧<vk,vj>表示，则 ai 的最晚开始时间要保证事件 vj 的最迟发生时间不拖后。（lte: lastest time of edge）。

      有：l[i]=vl[j]-len<vk,vj>1（为边（活动）的到达顶点的最晚发生时间减去边的权值）

      如上图各边（活动）的 l(i)：

      ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/3177649c4224e22de57a35d8a02c6e50.jpg)

      NOTE: 求 l(i) 时，不可认为与该边出发点的 Vl(i) 相等，因为边头事件最晚发生的时候边上的活动不一定马上开始，求得的不一定是最终事实的结果；同理，求 e(i) 时不可用边尾的 Ve(i) - 边的权值。

    最后，取出 e(i)=l(i) 的边为 a1、a2、a4、a8、a9，这些就是关键活动，即为关键路径上的边，所以关键路径有两条：a1 a4 a9 和 a2 a8 a9。

    为缩短整个工程的工期，若规定只能选两个活动进行优化（减少执行时间），可以达到优化整个工程的效果的是：
    ```
    a1 a4 ×（只影响到了两条关键路径的一条，“短板效应”，无法缩短整个工程工期）
    a1 a9 √
    a2 a8 ×（只影响到了两条关键路径的一条，“短板效应”，无法缩短整个工程工期）
    a2 a9 √
    a4 a9 √
    a8 a9 √
    ```

  代码实现：拓扑排序是求关键路径的基础，要求关键路径必须先求出拓扑序列。
  ```cpp
  // TODO:
  ```

## 6. 最小生成树算法

最小生成树是一副[连通加权无向图](https://zh.wikipedia.org/wiki/%E5%9B%BE) 中一棵权值最小的[生成树](https://zh.wikipedia.org/w/index.php?title=%E7%94%9F%E6%88%90%E6%A0%91&action=edit&redlink=1)。最小生成树其实是最小权重生成树的简称。

例：假设要在 n 个城市之间建立通信网络，而连通 n 个城市一般只需要 n-1 条线路。由于 n 个城市中的每两个城市之间都可建立一条线路，因此最多可有 n(n-1)/2 条线路可供选择，本问题的关键就是如何在这些可能的 n(n-1)/2 条线路中选择 n1 条线路，使得建立这个通信网的成本最低。

分析：n 个城市及其可能设置的通信线路可用连通网来表示，其中网的顶点表示城市，边表示两城市之间的线路，边的权值表示相应的代价。由于具有 n 个顶点的连通网包含多棵不同的生成树，每一棵生成树都可能是一个通信网且总代价不同，因此该问题的解决就要通过构造连通网的最小代价生成树来完成。

 最小生成树通常使用 [Kruskal（克鲁斯卡尔）](https://baike.baidu.com/item/kruskal) 算法或 [Prim（普里姆）](https://baike.baidu.com/item/prim) 算法求出。

### 6.1. Prim

Prim 算法实际上是**选择顶点**的过程。把已经确定的顶点和边看成一个整体，选取剩下的顶点中离这个整体最近的一个顶点（即其他点到这个整体的任一点的各个距离中，选择最近的那个点），来加入这个整体，直到所有顶点都被加入到这个整体之中。

例：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/8a14167a6a8ad65b8465f620244ada3b.jpg)

分析上面算法，普里姆算法的时间复杂度为 O(n2)，与网中的边数无关，因此**该算法适于求边稠密网的最小生成树**。

可以使用二叉堆、斐波那契堆进一步优化算法。

### 6.2. Kruskal

Kruskal 算法实际上是**选择边**的过程。先假设这个图只有顶点没有边，然后将所有边按照权值从小到大排序好，再每次把权值最小的边加入到图中，要求这条边的两个顶点在目前的图中在两颗不同的树中，即没有连通，若已经连通，则不选择这个边，跳过，选择下一条边（排在后边的下一条）。

例：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/875290ef4056287669f21e5fce6ada7b.jpg)

Kruskal 算法的时间复杂度为 O(elge)（e 为网中边的数目），因此**该算法适于求边稀疏的网的最小生成树**。

## 7. 最短路径算法

最短路径算法是图论中的基本算法之一。

根据路径出发点是否单一，可分为：
- 单源最短路径算法
- 多源最短路径算法

根据路径是否带权值，可分为：
- 网图最短路径算法
- 非网图最短路径算法

### 7.1. 单源最短路径算法：Dijkstra 算法

单源最短路径问题为：对于有向图 G 中的源顶点 a，求出它到图中其他任意顶点的最短路径。

利用 Dijkstra 发明的贪婪算法可求解单源最短路径问题，算法思想是：按路径长度递增的次序产生最短路径，采用的贪婪准则是：在未产生最短路径的顶点中，选择路径长度最短的目的顶点。它通过分步方法求出最短路径，每一步产生一个到达新的目的顶点的最短路径，即它是按照路径长度顺序产生最短路径的。

例：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/348e53b7dffff08a261014190e3fb394.jpg)

以下是求解过程：
- 阶段 Ⅰ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | ∞    | ∞    | ∞    | ∞    | ∞    |
  | P    | 0    | -1   | -1   | -1   | -1   | -1   |
  | F    | 1    | 0    | 0    | 0    | 0    | 0    |

  初始化表，此时确认了从 0 到 0 的最短路。

  表中：
  - d 表示从出发点 0 到该店的 distance。
  - P(Path) 记录从出发点 0 走到该点的路径上的上一个点。
  - F(Final) 记录是否已确认为最短路径。

- 阶段 Ⅱ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 60   | ∞    | 10   | 65   |
  | P    | 0    | 0    | 0    | -1   | 0    | 0    |
  | F    | 1    | 0    | 0    | 0    | 1    | 0    |

  从 0 出发可到达 1、2、5、4，到 1 的 d=20<∞，故更新表中的 d 值，并将 P 值改为 0（从 0 来的）；2、5、4 同理。

  在 F=0 的所有点中，选择 d 最小的点，并将该点设为下一阶段的出发点。被选到的点即可将 F 值改为 1，此处选择 4。

- 阶段 Ⅲ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 60   | ∞    | 10   | 30   |
  | P    | 0    | 0    | 0    | -1   | 0    | 4    |
  | F    | 1    | 1    | 0    | 0    | 1    | 0    |

  从 4 出发，可到 5，d=d4+20=30<65，故更新 d5，并将 P5 改为 4.

  在 F=0 的所有点中选择了 d 最小的为 d1=20，作为下一阶段出发点，并将 F1 改为 1。

- 阶段 Ⅳ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 50   | 90   | 10   | 30   |
  | P    | 0    | 0    | 1    | 1    | 0    | 4    |
  | F    | 1    | 1    | 0    | 0    | 1    | 1    |

- 阶段 Ⅴ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 45   | 90   | 10   | 30   |
  | P    | 0    | 0    | 5    | 1    | 0    | 4    |
  | F    | 1    | 1    | 1    | 0    | 1    | 1    |

- 阶段 Ⅵ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 45   | 85   | 10   | 30   |
  | P    | 0    | 0    | 5    | 2    | 0    | 4    |
  | F    | 1    | 1    | 1    | 1    | 1    | 1    |

  直至所有点的 F 值为 1，算法流程结束。

- 最后结果

  |           | 最短距离 | 路径           |
  | ----      | ---- | ----------------- |
  | 从 0 到 0 | 0    | 0                 |
  | 从 0 到 1 | 29   | 0 → 1             |
  | 从 0 到 2 | 45   | 0 → 4 → 5 → 2     |
  | 从 0 到 3 | 85   | 0 → 4 → 5 → 2 → 3 |
  | 从 0 到 4 | 10   | 0 → 4             |
  | 从 0 到 5 | 30   | 0 → 4 → 5         |

算法的时间复杂度为 O(n^2)。

### 7.2. BFS、双向 BFS

### 7.3. 多源最短路径算法：floyd-warshall

时间复杂度为 O(n^3)。

### 7.4. bellman-ford

### 7.5. SPFA

### 7.6. A*

### 7.7. D*

## 8. Refer Links

http://c.biancheng.net/cpp/u/shuju8/  

http://blog.csdn.net/qq_38262266/article/details/77010230

http://blog.csdn.net/matrix_laboratory/article/details/11879127

http://blog.csdn.net/wang379275614/article/details/13990163

http://blog.csdn.net/u011240016/article/details/53171808

- 最短路径算法

  https://www.cnblogs.com/hxsyl/p/3270401.html

  http://m.blog.csdn.net/article/details?id=6181485

  http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html

  http://www.tudou.com/programs/view/4JBYJVeD6t0

  http://v.youku.com/v_show/id_XOTM1OTcxODU2.html

  http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html
