- [数据结构：树结构 - 堆](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E7%BB%93%E6%9E%84---%E5%A0%86)
  - [1. 基本概念](#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
  - [2. 二叉堆](#2-%E4%BA%8C%E5%8F%89%E5%A0%86)
    - [2.1. 存储结构](#21-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
    - [2.2. 效率](#22-%E6%95%88%E7%8E%87)
    - [2.3. 基本操作](#23-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)
      - [2.3.1. 插入结点](#231-%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9)
      - [2.3.2. 堆调整](#232-%E5%A0%86%E8%B0%83%E6%95%B4)
      - [2.3.3. 删除根结点](#233-%E5%88%A0%E9%99%A4%E6%A0%B9%E7%BB%93%E7%82%B9)
      - [2.3.4. 建立堆](#234-%E5%BB%BA%E7%AB%8B%E5%A0%86)
    - [2.4. 应用](#24-%E5%BA%94%E7%94%A8)
      - [2.4.1. 堆排序](#241-%E5%A0%86%E6%8E%92%E5%BA%8F)
      - [2.4.2. 事件模拟](#242-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E6%8B%9F)
      - [2.4.3. 大数据的 top-K 问题](#243-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84-top-k-%E9%97%AE%E9%A2%98)
  - [3. 斐波那契堆](#3-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86)
  - [4. Refer Links](#4-refer-links)

# 数据结构：树结构 - 堆

## 1. 基本概念

堆是一种树形结构，具有 n 个元素的序列（k1,k2,...,kn）被称为堆，当且仅当满足以下关系之一：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/1/508a29c0ab27f880bd172bfcb30fcdc1.jpg)

其中：
- 满足第一个关系的堆，其根节点为最小项，称为最小堆或小根堆。
- 满足第二个关系的堆，其根节点为最大项，称为最大堆或大根堆。

性质：
- 任意节点总是小于（或大于）它的所有后裔。
- 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。

常见的堆有二叉堆、斐波那契堆等。

## 2. 二叉堆

堆的一个经典的实现是完全二叉树 (complete binary tree)，这样实现的堆称为二叉堆 (binary heap)。

### 2.1. 存储结构

**二叉堆一般用一维数组来表示。如果根节点在数组中的位置是 1，第 n 个位置的子节点分别在 2n 和 2n+1**。因此，第 1 个位置的子节点在 2 和 3，第 2 个位置的子节点在 4 和 5，以此类推。**这种基于 1 的数组存储方式便于寻找父节点和子节点，数组索引为 0 的位置用于记录二叉堆中元素的总数**。如果存储数组的下标基于 0，那么下标为 i 的节点的子节点是 2i + 1 与 2i + 2；其父节点的下标是⌊(i − 1) ∕ 2⌋。

例如下图的两个堆：
```
        1                        11
      /   \                      /  \
     2     3                   9     10
    /  \  /  \                / \   /  \
   4   5  6  7               5  6  7   8
  / \  / \                  /\  /\
 8  9 10 11               1  2 3  4 
```
用基于 1 的数组进行保存：
```
位置：1  2  3  4  5  6  7  8  9 10 11
左图：1  2  3  4  5  6  7  8  9 10 11
右图：11  9 10  5  6  7  8  1  2  3  4
```

但对于一个数据量很大的堆，这种存储是低效的，因为节点的子节点很可能在另外一个内存页中。B-heap 是一种效率更高的存储方式，它把每个子树放到同一内存页。

如果用指针链表存储堆，那么需要能访问叶节点的方法。可以对二叉树“穿线”(threading) 方式，来依序遍历这些节点。

### 2.2. 效率

n 个结点的堆，高度 d = log n，插入结点、删除普通元素和删除最小元素的平均时间代价和时间复杂度都是Ο（log n）。

### 2.3. 基本操作

#### 2.3.1. 插入结点

如何在原有的堆上直接插入一个新的结点呢？一般**直接将新元素插入到堆的末尾，再根据情况判断新元素是否需要上移，从下往上将新元素沿着树上移到合适的位置即可**。

例：在以下的最小二叉堆上增加结点 3。

1. 直接将新节点 3 添加在堆的最末尾。

    ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/1/0388cfaf8d24305e5bed260cf11f4e1b.jpg)

1. 先将 3 与它的父结点 25 比较，发现比父结点小，为了维护最小堆的特性，需要与父结点的值进行交换。交换之后发现还是要比它此时的父结点 5 小，因此需要再次与父结点交换。至此又重新满足了最小堆的特性。向上调整完毕后如下。

    ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/1/4d68c3b4cf452528df18dfac959a6a4d.jpg)

- 时间复杂度

  如果堆的大小为 N（即有 N 个元素），那么插入一个新元素所需要的时间是 O(log N)。

- 代码实现（最大堆）
  ```cpp
  void HeapInsert(int a[], int x)
  {
      if (a[0] == MAXSIZE) return; // a[0] 存储堆的元素个数
      int i = ++ a[0]; // 新节点的初始位置，在堆的末尾
      while (i > 1 &&  x > a[i/2])
          Swap(a[i], a[i/2]);
  }
  ```

#### 2.3.2. 堆调整

堆的调整操作基于这样的情况：将一个堆的堆顶元素替换成一个新的元素（值不确定大小），于是堆被破坏。此时需要通过调整操作，使得这个堆重新满足堆的性质要求。

**调整操作需要从根结点开始，沿着树向下调整**。假设要调整一个最小堆，先将根结点与左、右子树共三个元素的值进行比较，若两个子元素都比根结点小，则选择最小的子元素与根结点进行交换。若交换后被交换元素的子树堆被破坏，则对该子树的堆重复以上过程，直到叶子结点或没有子树堆被破坏为止。

例：调整以下最小堆。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/1/7a504fb1ee25c16dd8ccc07407be555f.jpg)

1. 沿着树向下调整。我们需要将这个数与它的两个儿子 2 和 5 比较，并选择较小一个与它交换，交换之后如下。

    ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/1/8ba97b13f877ab9f9bda678e4c1ac71e.jpg)

1. 我们发现此时还是不符合最小堆的特性，因此还需要继续向下调整。于是继续将 23 与它的两个儿子 12 和 7 比较，并选择较小一个交换，交换之后如下。

    ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/1/5f7a93dd4f39356af1ab95814c31f74c.jpg)

1. 到此，还是不符合最小堆的特性，仍需要继续向下调整直到符合最小堆的特性为止。

    ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/1/a4f845aaac5b0788c6f6ee6a23c909f4.jpg)

- 时间复杂度为 O(logN)。

- 代码实现
  ```cpp
  void HeapAdjusting(int a[], int root, int n)
  {
      int temp = a[root];
      int child = 2*root+1; // 左孩子的位置
      while(child<n)
      {
          // 找到孩子节点中较小的那个
          if(child+1<n && a[child+1]<a[child])
              child++;
          // 如果较大的孩子节点小于父节点，用较小的子节点替换父节点，并重新设置下一个需要调整的父节点和子节点。
          if(a[root]>a[child])
          {
              a[root] = a[child];
              root = child;
              child = 2*root+1;
          }
          else
              break;
          // 将调整前父节点的值赋给调整后的位置。
          a[root] = temp;
      }
  }
  ```

#### 2.3.3. 删除根结点

根节点删除后，我们会有两个子树，我们需要基于它们重构堆：让堆的最后一个节点成为新的根节点，从而构成一个新的二叉堆（选择堆的最后一个元素，才能符合完全二叉树的性质），再进行堆的调整即可。

例：删除根结点 1。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/1/c75d1828d1e4188c6a01e59ff465758c.jpg)

- 代码实现
  ```cpp
  void HeapDeleteMax(int a[])
  {
      if (a[0] == 0) return;
      a[1] = a[a[0]--]; // 将堆的最后一个元素成为新的根结点，然后将堆的元素个数减一
      HeapAdjusting(a, 1, a[0]); // 对新的堆进行调整
  }
  ```

#### 2.3.4. 建立堆

建立堆的过程，即将一个无序的完全二叉树，转换成一个二叉堆的过程，实际上就是一个**自下而上的反复的调整的过程**。

n 个结点的完全二叉树，则最后一个非叶子结点为第 n/2 个结点。因此，调整从第 n/2 个结点为根的子树开始，该子树成为堆。之后向前依次对各结点为根的子树进行调整，使之成为堆，直到根结点。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/1/55ef6d57dfd6ce8c99b7a5450ca48e91.jpg)

- 代码实现
  ```cpp
  void HeapBuilding(int a[], int n)
  {
      // 从最后一个有孩子节点的位置开始调整，最后一个有孩子节点的位置为 (n-1)/2
      for(int i=(n-1)/2; i>=0; i--)
          HeapAdjusting(a, i, n);
  }
  ```

### 2.4. 应用

#### 2.4.1. 堆排序

堆排序是一种树形选择排序，是对直接选择排序的有效改进。堆排序（Heap Sort）是指若在输出堆顶的最大（小）值之后，使得剩余 n–1 个元素的序列又重建成一个堆，则得到 n 个元素中的次大（小）值。如此反复执行，便能得到一个有序序列。

**堆排序的实质就是对无序序列不断进行建堆和调整堆的过程。**为使排序后的记录序列按关键码非递减排列，在堆排序的实现过程中可先建一个最大堆，将堆顶记录与序列中最后一个记录进行交换，然后对序列中前 n–1 记录进行筛选，重新将它调整为一个最大堆，如此反复，直至排序结束。

排序过程中将数组分成了二叉堆区域（主要操作区，待排序）和有序区域（已排好序）：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/1/d944e8d4a4d3816c5fb67aa0211fb58f.jpg)

- 时间复杂度
  
  当记录数比较少时，堆排序的效率并不理想，但当记录数很大时，堆排序是非常有效的。在最坏的情况下，堆排序的时间复杂度也为 O(n log n)，同时堆排序的时间效率与待排序记录的初始次序无关，这是堆排序优于简单选择排序的地方。
  
  但堆排序也是不稳定排序，同时它需要一个 O(1) 的辅助空间。

- 代码实现
  ```cpp
  // 堆排序
  void HeapSort(int a[], int n)
  {
      // 初始化堆
      HeapBuilding(a, n);
      // 从最后一个节点开始进行调整
      for(int i=n; i>0; i--)
      {
          // 交换堆顶元素和最后一个元素
          Swap(a[1], a[i]);
          // 每次交换后都要进行调整
          HeapAdjusting(a, 1, i);
      }
  }
  ```

#### 2.4.2. 事件模拟
  
主要运用堆的排序以选择优先。队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。

Linux 内核中的调度器 (scheduler) 会按照各个进程的优先级来安排 CPU 执行哪一个进程。计算机中通常有多个进程，每个进程有不同的优先级（该优先级的计算会综合多个因素，比如进程所需要耗费的时间，进程已经等待的时间，用户的优先级，用户设定的进程优先程度等等)。内核会找到优先级最高的进程，并执行。如果有优先级更高的进程被提交，那么调度器会转而安排该进程运行。优先级比较低的进程则会等待。“堆”是实现调度器的理想数据结构。

#### 2.4.3. 大数据的 top-K 问题

例子：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为 1-255 字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是 1 千万，但如果除去重复后，不超过 3 百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的 10 个查询串，要求使用的内存不能超过 1G。

这是一个典型的大数据 top-K 问题。

针对大数据问题进行统计首先应该想到的就是 Hash_map。所以第一步就是先遍历全部的 1 千万 Query，构建出一个大小为 3 百万的 Hash_map，其中的 key 值为某条 Query，对应的 value 值为该条 Query 的查询次数。

建好 Hash_map 以后，我们接下来的问题就是如何在 3 百万的 Query 中找出 10 个最热门的 Query，也就是要用到排序算法。

- 解法一

  排序算法中效率最高的时间复杂度为 O(n*log(n))，这是最简单粗暴的方法，也是最直接的方法。

- 解法二
  
  进一步优化，该题目是要求寻找 top-K 问题，那么我们可以直接去前 K 个 Query 构建一个数组，然后对其进行排序。遍历剩余的全部 Query，如果某条 Query 的查询次数大于数组中最小的一个，将数组中最小的 Query 剔除，加入这条新的 Query。接着调整数组顺序，依次进行遍历，这样的最坏情况下的复杂度为 O(n*K)。

- 解法三
  
  但是还可以继续优化寻找 top-K 的操作，那就是借助既能快速查找，又能快速移动元素的数据结构，小根堆来实现。

  具体过程是，堆顶存放的是整个堆中最小的数，现在遍历 N 个数，把最先遍历到的 k 个数存放到最小堆中，并假设它们就是我们要找的最大的 k 个数，X1>X2...Xmin（堆顶)，而后遍历后续的 (n-K) 个数，一一与堆顶元素进行比较，如果遍历到的 Xi 大于堆顶元素 Xmin，则把 Xi 放入堆中，而后更新整个堆，更新的时间复杂度为 logK，如果 Xi<Xmin，则不更新堆，整个过程的复杂度为 O(K)+O((N-K)*logK)=O（N*logK）。动画示意看[这里](http://www.benfrederickson.com/heap-visualization/)。

  思想与上述解法二一致，只是算法在解法三，我们采用了最小堆这种数据结构代替数组，把查找目标元素的时间复杂度有 O(K) 降到了 O(logK)。那么这样，采用堆数据结构，解法三，最终的时间复杂度就降到了 O(n*logK)，和解法二相比，又有了比较大的改进。

## 3. 斐波那契堆

TODO:

## 4. Refer Links

http://wiki.jikexueyuan.com/project/easy-learn-algorithm/amazing-priority-array.html

https://www.cnblogs.com/maybe2030/p/4715042.html