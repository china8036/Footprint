- [数据结构：线性结构 - 栈与队列](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84---%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97)
  - [1. 栈](#1-%E6%A0%88)
    - [1.1. 基本概念](#11-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [1.2. 存储结构](#12-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
      - [1.2.1. 顺序存储结构](#121-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
      - [1.2.2. 链式存储结构](#122-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
    - [1.3. 应用](#13-%E5%BA%94%E7%94%A8)
      - [1.3.1. 简单算术表达式求值](#131-%E7%AE%80%E5%8D%95%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC)
      - [1.3.2. 背包问题](#132-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98)
      - [1.3.3. 地图四染色问题](#133-%E5%9C%B0%E5%9B%BE%E5%9B%9B%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98)
  - [2. 队列](#2-%E9%98%9F%E5%88%97)
    - [2.1. 基本概念](#21-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [2.2. 存储结构](#22-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
      - [2.2.1. 顺序存储结构](#221-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
      - [2.2.2. 链式存储结构](#222-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
    - [2.3. 应用](#23-%E5%BA%94%E7%94%A8)
      - [2.3.1. 舞伴配对问题](#231-%E8%88%9E%E4%BC%B4%E9%85%8D%E5%AF%B9%E9%97%AE%E9%A2%98)
      - [2.3.2. 铁路站问题](#232-%E9%93%81%E8%B7%AF%E7%AB%99%E9%97%AE%E9%A2%98)
        - [2.3.2.1. 问题一](#2321-%E9%97%AE%E9%A2%98%E4%B8%80)
        - [2.3.2.2. 问题二](#2322-%E9%97%AE%E9%A2%98%E4%BA%8C)
    - [优先队列](#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97)

# 数据结构：线性结构 - 栈与队列

栈与队列是两种特殊的线性表，它们的逻辑结构与线性表的逻辑结构相同，但在运算操作方面较一般的线性表有更多的限制，因此也被称为运算受限的线性表。

## 1. 栈

### 1.1. 基本概念

栈（stack）是限制在表的一端进行插入和删除的线性表，又称为后进先出（last in first out）的线性表（简称 LIFO 结构）。进行插入和删除的一端是浮动端，称为栈顶（top），并用一个“栈顶指针”指示；另一端是固定端，称为栈底（bottom）。在栈顶插入元素的操作通常称为入栈，删除栈顶元素的操作称为出栈。

### 1.2. 存储结构

#### 1.2.1. 顺序存储结构

栈的顺序存储结构称为顺序栈，它**利用一组地址连续的存储单元依次存放从栈底到栈顶的数据元素，并用一个变量记录栈顶元素的位置**。**通常采用数组来存放，习惯上将栈底放在数组下标小的那端**。由于栈在使用过程中所需的最大空间很难估计。因此，一般来说，在初始化设空栈时不应限定栈的最大容量。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/75790df884d64fbb106a3ea171abdde5.jpg)

#### 1.2.2. 链式存储结构

栈的链式表示，即链栈。由于栈的操作是线性表操作的特例，因此链栈可看成运算受限的单链表，其操作易于实现。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/a7859f5c6ca98de49b6485a8dd4b19dd.jpg)

其特点如下：
- 链栈无栈满问题，空间可扩充。
- 插入与删除仅在栈顶处执行。
- 链式栈的栈顶在链头。
- 适合于多栈操作。

### 1.3. 应用

#### 1.3.1. 简单算术表达式求值

表达式求值是程序设计语言编译过程中的一个最基本问题。下面介绍一种简单直观、广为使用的“算符优先法”。

**任何一个表达式都是由操作数（operand）、运算符（operator）和界限符（delimiter）组成的式子**。操作数既可以是常数也可以是变量或常量。运算符从运算类型上可分为算术运算符、关系运算符和逻辑运算符三类。基本界限符包括左、右括号和表达式结束符等。运算符和界限符常被统称为算符。

在运算规则中，表达式的算符之间有一定优先关系（表中的`#`是为算法实现便捷而在表达式上虚设的的整个表达式的一对括号）：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/5acd5f9c5be267d7a0e0e49d15ff06c7.jpg)

在算法的实现过程中用到两个工作栈来分别存储算符和操作数或运算结果，其基本思想是：**初始化操作数栈和算符栈，表达式起始符“#”为算符栈的栈底元素；自左向右扫描表达式，若是操作数则进操作数栈，若是算符则和算符栈的栈顶运算符比较优先权后进行相应的操作，直至整个表达式求值完毕（即 OPTR 栈的栈顶元素和当前读入的字符均为“#”）。**

例：利用上述算法对表达式 9/(1+2) 求值的操作过程如下

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/2d8aa911dcbf05a4c80560ed05656b96.jpg)

#### 1.3.2. 背包问题

给定一组正整数权值 w1, w2, w3, …, wn，以及一个目标值 t（整数）。试问：能否从这组权中选出若干个数，使它们的和等于 t。这就是所谓的“背包问题”。例如，当目标值 t=10，权值为 7, 5, 4, 4, 1 时，可选中第 2, 3, 5 这 3 个数作为解，这 3 个数之和为 10。如果设想权值分别是物品的重量，假设要用一个载重限度为 t 千克的背包携运物品，希望知道能否从这些物品中选出几件，使其总重量恰为目标值 t。

以下给出背包问题的一种基于栈的递归解法（O(2^n)）：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/ba268d32b619632f16dd14d4041e183a.jpg)

其中，函数 knapsack 的操作对象是由权值构成的数组 weights[n]；**knapsack(t,i) 将回答是否能从权值 weights[i]～weights[n] 之间选出一些数，使其总和为 t，并在可能的情况下打印输出所选定的这些权值**。在 3 种特殊情况下，knapsack 可立刻做出判断：
- 当 t=0 时，有解，权的空集合就是一个解；
- 当 t<0 时，无解，因为权值都是正整数；
- 当 t>0 且 i>n 时，无解，此时所考虑的范围内无权值可选，因此不可能使其总和为 t。
当不是上述 3 种情况时，调用 knapsack(t-wi,i+1) 可验证是否存在包含 wi 的解。如果调用的结果为 true，则说明问题有解，且 wi 是解中选定的一个权值。因此，应将 wi 打印输出；如果调用的结果为 false，则说明不存在包含 wi 的解，那么解只可能选自 wi+1～wn 之间，因此调用 knapsack(t,i+1) 即可。

#### 1.3.3. 地图四染色问题

根据计算机科学中著名定理“四染色”定理，可用不多于 4 种颜色对地图进行染色（着色），使相邻的行政区域不重色。利用这个定理的结论，使用回溯算法对一张给定的地图染色。

如图所示，对每个行政区进行编号，1 色、2 色、3 色、4 色表示各个行政区域的颜色，称为色数。从编号为 01 的区域开始逐一进行染色。对每个区域用色数 1、2、3、4 依次进行试探，并尽可能取小色数。若当前所取色数与周围已染色的区域不重色，则进栈记下该区域的色数；否则，依次用下一色数进行试探。若从 1 色到 4 色均与相邻某区域发生重色，则需退栈回溯，修改栈顶区域的色数。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/b9a5e6ea004939ce987976c2e86f7c43.jpg)

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/6a4ec514441287f91a5bbf5068067a2f.jpg)

## 2. 队列

### 2.1. 基本概念

队列（Queue）是只允许在一端进行插入、在另一端进行删除的运算受限的线性表。被允许删除的一端称为队头（front），被允许插入的一端称为队尾（rear）。队列亦称作先进先出（First In First Out）的线性表，简称为 FIFO 表。当队列中没有元素时，称为空队列。

### 2.2. 存储结构

#### 2.2.1. 顺序存储结构

队列的顺序存储结构称为顺序队列，顺序队列实际上是运算受限的顺序表。与顺序栈类似，在队列的顺序存储结构中，用一组地址连续的存储单元依次存放从队列头到队列尾的元素。指针 front 和 rear 被分别用来指示队列头元素和尾元素的位置。

初始化建空队列时，front=rear=0；有新元素插入队尾时，rear=rear+1；从队列中删除头元素时，front=front+1；当队列非空时，头指针始终指向头元素，而尾指针始终指向队尾元素的下一个位置。

这种表示方法存在数组越界的问题，而此时队列的实际可用空间并未占满（假溢出）：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/126ecfbaa05f642ff6f87fcb42991a20.jpg)

对于这个问题，一个较好的解决办法是将顺序队列转换为一个循环空间，称为循环队列：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/3e88ba90500f1780e2350123601ec0b0.jpg)

但循环队列存在另一个问题：队满和队空时都有 Q.front = Q.rear，因此无法判断队列是“空”还是“满”。解决的办法之一就是：规定队列的最大长度始终小于存储空间大小，即留一个存储空间来区分队列空还是满。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/1c65341f43a6c5a8911a6ec6d9f10c82.jpg)

（进队列时移动 rear（排到队尾），出队列移动 front（从队头出队列））

#### 2.2.2. 链式存储结构

链队列，即用链表表示的队列，它是限制仅在表头删除和表尾插入的单链表。如下图所示，有两个分别指向队头和队尾的头指针和尾指针。另外，在链表前还添加了一个头结点以使操作更加简便。空的链队列的判决条件为：头指针和尾指针均指向头结点。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/5bcdfffa77f22a6e0747fa8cea29bfca.jpg)

需要注意的是，一般情况下，删除队列头元素时，仅需要修改头结点中的指针。但当队列中最后一个元素被删后，队列尾指针也丢失了，因此需要对队尾指针重新赋值，即指向头结点。

### 2.3. 应用

#### 2.3.1. 舞伴配对问题

假设在舞会上，男士和女士进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲，现要求通过算法来模拟上述舞伴配对问题。

**由于先入队的男士或女士亦先出队配成舞伴，因此该问题具有典型的先进先出特性，可用队列作为算法的数据结构。**在算法中，假设男士和女士的记录存放在一个数组中作为输入，然后依次扫描该数组的各元素，并根据性别来决定是进入男队还是女队。当这两个队列构造完成之后，依次将两队当前的队头元素出队来配成舞伴，直至某队列变空为止。此时，若某队中仍有等待配对者，算法输出此队列中等待者的人数及排在队头的等待者的名字，他（或她）将是下一轮舞曲开始时第一个可获得舞伴的人。

#### 2.3.2. 铁路站问题

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/91e7565f953d78cfcb6e6f287213c67a.jpg)

铁路进行列车调度时，常把站台设计成如上图的栈式结构的站台，列车从右边进站，从左边出站。有以下两种问题：
- 设有编号为 1,2,3,4,5,6 的六辆列车，顺序依次开入栈式结构的站台，则可能的出栈序列有多少种？若有编号为 1,2,3……n 的 n 辆列车，可能的出栈序列有多少种？分别具体列出各个序列。
- 设有编号为 1,2,3,4,5,6 的六辆列车，顺序依次开入栈式结构的站台，那么是否能够得到 435612, 325641, 154623 和 135426 的出站序列，如果不能，说明为什么不能；如果能，说明如何得到（即写出"进栈"或"出栈"的序列）。

##### 2.3.2.1. 问题一

http://www.voidcn.com/blog/xl19900502/article/p-844824.html

http://blog.chinaunix.net/uid-26874207-id-4135146.html

Q: 设有编号为 1,2,3,4,5,6 的六辆列车，顺序依次开入栈式结构的站台，则可能的出栈序列有多少种？若有编号为 1,2,3……n 的 n 辆列车，可能的出栈序列有多少种？分别具体列出各个序列。

- 解法一：递归分治 && 卡特兰数

  要求 n 辆列车可能的出栈序列总量，我们可以采用递归分治的思想。我们把过程分成两步，根据组合数学计数原理中的乘法原理，总的可能性数量等于第一步的可能性数量和第二步的可能性数量之乘积。 

  我们以序号为 n 的列车为界，将列车分为两部分，一部分是在第 n 辆列车之前出栈的列车，另一部分是在第 n 辆列车之后出栈的列车。设在 n 号列车之前出栈的列车数量为 i(0 <= i < n)，则在 n 号列车之后出栈的列车数量为 (n – 1 – i)。前 i 辆列车出栈的可能性数量有 F(i)，后 (n – 1 – i) 辆列车出栈的可能性数量有 F(n – 1 – i)，所以总的数量为 F(i)* F(n – 1 – i)。 
  因此我们可以得到一个递归公式：F(n) = F(0)*F(n-1) + F(1)*F(n-2) + F(2)*F(n-3) + ... + F(n-1)*F(n-n);（其中 n>=1，F(0) = 1）。 

  我们把数据代人进行检验： 
  ```
  F(1) = F(0)*F(1-1) = 1； 
  F(2) = F(0)*F(2-1) + F(1)*F(2-2) = 1 + 1 = 2； 
  F(3) = F(0)*F(3-1) + F(1)*F(3-2) + F(2)*F(3-3) = 2 + 1 + 2 = 5； 
  F(4) = F(0)*F(4-1) + F(1)*F(4-2) + F(2)*F(4-3) + F(3)*F(4-4)= 5 + 4 + 4 + 5 = 14； 
  ```
  完全正确！ 

  其实这与史上非常经典的数列——Catalan（卡特兰）数极其相似——就是 n 的初值少 1。 Catalan 数的递归公式是 h(n) = h(1)*h(n-1) + h(2)*h(n-2) + …… + h(n-1)*h(1) （其中 n>=2，h(1) = 1）。 后来又有人得到一个另类的递归公式：h(n) = ((4*n – 2) / (n + 1)) * h(n-1)（其中 n>=2，h(1) = 1）。 

  根据递归公式我们可以得到数列的通项公式： 
  ```
  h(n) = C(2*n, n) / (n + 1) = (2*n)! / (n! * n! *(n + 1)) （其中 n>=1）。
  ```

  TODO: 代码实现

- 解法二：模拟进出栈的过程，遍历所有可能的情况

  - 递归实现

    利用递归，隐式的使用了栈（即使用了“函数调用栈”），每次调用函数并执行代码时入栈，每次返回函数返回值或调用地址（void）时出栈，每次出栈时通过 pop 操作又还原了序列，从而遍历了所有可能的情况。
    - 输入任意序列
      ```cpp
      #include <iostream>
      #include <stack>
      #include <vector>
      using namespace std;

      int sum=0;
      void func(vector<int>seq,int num[],int n,int A[]) {
          if(num[0]>=1) {
              seq.push_back(1);
              num[0]--;
              func(seq,num,n,A);
              num[0]++;
              seq.pop_back();
          }
          if((num[1]>=1) && (num[1]>num[0])) {
              seq.push_back(0);
              num[1]--;
              func(seq,num,n,A);
              num[1]++;
              seq.pop_back();
          }
          if(seq.size()==2*n) {
              stack<int> stk;
              int j=0;
              for(vector<int>::iterator iter=seq.begin();iter!=seq.end();iter++) {
                  if(1==(*iter)) {
                      stk.push(A[j]);
                      j++;
                  } else {
                      cout<<stk.top()<<" ";
                      stk.pop();
                  }
              }
              cout<<endl;
          sum++;
          }
      }

      int main() {
          int n,i;
          cout << "please input the sum:" << endl;
          cin>>n;
          int * A = new int[n];
          cout << "please input the push sequence:" << endl;
          for(i=0;i<n;i++) {
              cin>>A[i];
          }
          int num[2]={n-1,n};
          vector<int>seq;
          seq.push_back(1);

          cout<<"the result is:"<<endl;
          func(seq,num,n,A);
          cout<<"total:"<<sum<<endl;
          return 0;
      }
      ```
      ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/1a0fe053a117799c93fe94dd11609a5f.jpg)

    - 只输入 n（默认入栈序列为 1……n）
      ```cpp
      #include <iostream>
      #include <vector>
      using namespace std;

      int sum = 0;
      void func(vector<char>sequence, int num[], int n) {
          if(num[0] >= 1) {
              sequence.push_back('0');
              num[0]--;
              func(sequence, num, n);
              num[0]++;
              sequence.pop_back();
          }
          if((num[1] >= 1) && (num[1] > num[0])) {
              sequence.push_back('1');
              num[1]--;
              func(sequence, num, n);
              num[1]++;
              sequence.pop_back();
          }
          if(sequence.size() == 2 * n) {
          int tmp[10], index = 0, i = 1;
          for(vector<char>::iterator it = sequence.begin(); it != sequence.end(); it++) {
            if(*it == '0') tmp[index++] = i++;
            if(*it == '1') cout<<tmp[--index]<<' ';
          }
          cout<<endl;
          sum++;
          }
      }

      int main() {
          int n;
          cout << "please input the 'n' (1, 2, 3...n):" << endl;
          cin >> n;
          int num[2] = {n-1, n};
          vector<char>sequence;
          sequence.push_back('0');
        cout<<"Out:\n";
          func(sequence, num, n);
        cout<<"Total: "<<sum<<endl;
          return 0;
      }
      ```
      ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/2ab8b7b0c504ea1d04cc13791bafd3f7.jpg)

  - 非递归实现 TODO:

##### 2.3.2.2. 问题二

http://codingisfunny.blog.163.com/blog/static/2164890902013141564990/

Q: 

> 若进站的六辆列车顺序如上所述，那么是否能够得到 435612, 325641, 154623 和 135426 的出站序列，如果不能，说明为什么不能；如果能，说明如何得到（即写出"进栈"或"出栈"的序列）。

> 输入：第一行是一个整数 k，表示有 k 个序列要求你进行判断，接下来 2 到 k+1 里每行有一个整数 n 和一个数字序列 a1...an.

> 输出：只有 k 行，对于第 i 个序列如果它是一个合法的出站序列，输出"yes", 否则输出"no" （不包括括号）。

- 解法一：对可能序列的规律进行分析

  例如：对于入栈序列为 1，2，3，4，有：
  - 可能的出栈序列：1234，1243，1324，1342，1432，2134，2143，2314，2341，2431， 3214，3241，3421，4321。 
  - 不可能的出栈序列：1423，2413，3124，3142，3412，4123，4132，4213，4231，4312。

  规律：
  
  对于所有可能的出栈序列中的任何一个数字（不妨设为 x），它之后只要有数字比它小（不妨设为 y1, y2, ….yn），那么将这些数字（即 y1, y2, ….yn）抽出并排成新的序列，那么这个新的序列必须是倒序排列的（即从大到小排列的），否则（正序排列的）就是不可能的出栈序列。
  
  如：3124 中 1 比 3 小，而 2 比 3 小且 12 呈正序，故不可能；又如 2143 中 1 比 2 小，但 1 后边的 4 比 2 大故略过，看再后边的 3，3 还是比 2 大故仍旧略过，因此序列中没出现应该排除的情况，故为可能的出栈序列。

  ```cpp
  #include<stdio.h>
  int main() {
    int i,j,N,n,tag,k,c,d,a[10],b[10];
    scanf("%d",&N);
    for(k=0;k<N;k++) {
      tag=1;
      scanf("%d",&n);   
      getchar();
      for(j=0;j<n;j++) {
        a[j]=getchar()-'0';
      }
      for(j=0;j<n-1&&tag==1;j++) {
        c=0;
        for(i=j+1;i<n&&tag==1;i++) {
          if(a[i]<a[j]) b[c++]=a[i];
          for(d=0;d<c-1;d++) {
            if(b[d]<b[d+1]) {
              printf("no\n");
              tag=0;
            }
          }
        }
      }
      if(tag==1)
      printf("yes\n");
    }
  }
  ```

- 解法二：根据所给序列模拟进出栈的过程

  - 利用数组
    ```cpp
    #include <stdio.h>
    int main()
    {
      int k,i,j,m=0,t=0,length,a[10],b[10],c[10];
      scanf("%d",&k);// 第一行，输入要执行几次判断，记为 k 
      for(i=1;i<=k;i++)
      {
        m=0;t=0;
        scanf("%d",&length);// 输入序列长度
        getchar();
        for(j=0;j<length;j++)//b[] 作为待进站火车 
        b[j]=j+1;
        for(j=0;j<length;j++)//a[] 记所给序列 
        a[j]=getchar()-'0';
        for(j=0;j<length;j++)// 开始判断是否为栈 
        {
          c[t++]=b[j];// 进栈	
          while(a[m]==c[t-1]&&t>=1)// 判断	
          {
            m++;t--;
          }
        }
        if(t==0)printf("yes\n");
        else printf("no\n");
      }
    }
    ```

  - 利用 STL 中的 Stack
    ```cpp
    #include <stdlib.h>
    #include <string.h>
    #include <stdio.h>
    #include <iostream>
    #include <stack>
    #include <queue>
    using namespace std;

    /*
    输入参数：int maxNum：进站的火车最大编号
        char* pOutSeq：使用字符串表示火车出站序列
    返回值：
      Int: 根据输入的进站序列判断，如果输入的出战序列是可能的，返回 1，否则返回 0；
    */

    int JudgeTrainSequence (int maxNum, char *pOutSeq) {
      stack<int> trainStack;     // 用栈 trainStack 存储当前停在站内的列车
      queue<int> inSeq;		   // 用队列 inSeq 存储进栈列车
      int flag = 1;          // 判断输入的出战序列
      for (int i = 1; i <= maxNum; ++i) inSeq.push(i + '0');
      int outIndex = 0;

    /*队列 inSeq.front() 表示入栈序列中最前方列车的编号（如果列车已经全部入栈，则 inSeq 为空）用 outIndex 表示当前出栈序列中出栈列车的编号（如果 outIndex = maxNum，则表示所有列车都能出栈，出栈序列正确)*/
      
      while(outIndex < maxNum) {
        if(!trainStack.empty() && pOutSeq[outIndex] == trainStack.top()) {
          trainStack.pop();    
    // 入栈序列中最前方列车的编号和当前栈首位相等，则出栈
          ++outIndex;
          continue;
        } else if (!inSeq.empty()) {           // 进栈还未结束
          if(pOutSeq[outIndex] == inSeq.front()) {
            ++outIndex;  // 入栈序列中最前方列车的编号和入栈序列中最前方列车的编号，则进栈后马上出栈
            inSeq.pop();
            continue;
          }
          else {        // 不等则入栈序列中最前方列车的编号进入 trainStack	
            trainStack.push(inSeq.front());
            inSeq.pop();
            continue;
          }
        } else {
          flag = 0;break;
        }
      }

      return flag;
    }

    int main() {
      cout<<JudgeTrainSequence(4, "3241");
    }
    ```

### 优先队列

优先级队列和普通的队列一样，只不过里面的每一个元素都有一个”优先级”，在处理的时候，首先处理优先级最高的。如果两个元素具有相同的优先级，则按照他们插入到队列中的先后顺序处理。

优先级队列可以通过链表，数组，堆或者其他数据结构实现。
- 如果使用无序数组，那么每一次插入的时候，直接在数组末尾插入即可，时间复杂度为 O(1)，但是如果要获取最大值，或者最小值返回的话，则需要进行查找，这时时间复杂度为 O(n)。
- 如果使用有序数组，那么每一次插入的时候，通过插入排序将元素放到正确的位置，时间复杂度为 O(n)，但是如果要获取最大值的话，由于元素已经有序，直接返回数组末尾的元素即可，所以时间复杂度为 O(1)。
- 如果使用二叉堆，那么所有操作的时间复杂度都可以达到Ο（log n）。

因此，二叉堆是优先队列的最好实现方式。