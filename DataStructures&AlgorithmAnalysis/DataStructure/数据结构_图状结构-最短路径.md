- [数据结构：图结构 - 最短路径](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9B%BE%E7%BB%93%E6%9E%84---%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84)
  - [1. 单源最短路径算法](#1-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95)
    - [1.1. Dijkstra 算法](#11-dijkstra-%E7%AE%97%E6%B3%95)
      - [1.1.1. 基本思路](#111-%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF)
      - [1.1.2. 代码实现](#112-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
    - [1.2. Bellman-Ford](#12-bellman-ford)
  - [2. BFS、双向 BFS](#2-bfs%E3%80%81%E5%8F%8C%E5%90%91-bfs)
  - [3. 多源最短路径算法：Floyded-warshall](#3-%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%EF%BC%9Afloyded-warshall)
  - [4. SPFA](#4-spfa)
  - [5. A*](#5-a)
  - [6. D*](#6-d)
  - [7. Refer Links](#7-refer-links)

# 数据结构：图结构 - 最短路径

最短路径算法是图论中的基本算法之一。

根据路径出发点是否单一，可分为：
- 单源最短路径算法
- 多源最短路径算法

根据路径是否带权值，可分为：
- 网图最短路径算法
- 非网图最短路径算法

## 1. 单源最短路径算法

单源最短路径问题为：对于有向图 G 中的源顶点 a，求出它到图中其他任意顶点的最短路径。

### 1.1. Dijkstra 算法

#### 1.1.1. 基本思路

利用 Dijkstra 发明的贪婪算法可求解单源最短路径问题，算法思想是：按路径长度递增的次序产生最短路径，采用的贪婪准则是：在未产生最短路径的顶点中，选择路径长度最短的目的顶点。它通过分步方法求出最短路径，每一步产生一个到达新的目的顶点的最短路径，即它是按照路径长度顺序产生最短路径的。

Dijkstra 算法使用的前提是：图中不能有负权边。

例：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/348e53b7dffff08a261014190e3fb394.jpg)

以下是求解过程：
- 阶段 Ⅰ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | ∞    | ∞    | ∞    | ∞    | ∞    |
  | P    | 0    | -1   | -1   | -1   | -1   | -1   |
  | F    | 1    | 0    | 0    | 0    | 0    | 0    |

  初始化表，此时确认了从 0 到 0 的最短路。

  表中：
  - d 表示从出发点 0 到该店的 distance。
  - P(Path) 记录从出发点 0 走到该点的路径上的上一个点。
  - F(Final) 记录是否已确认为最短路径。

- 阶段 Ⅱ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 60   | ∞    | 10   | 65   |
  | P    | 0    | 0    | 0    | -1   | 0    | 0    |
  | F    | 1    | 0    | 0    | 0    | 1    | 0    |

  从 0 出发可到达 1、2、5、4，到 1 的 d=20<∞，故更新表中的 d 值，并将 P 值改为 0（从 0 来的）；2、5、4 同理。

  在 F=0 的所有点中，选择 d 最小的点，并将该点设为下一阶段的出发点。被选到的点即可将 F 值改为 1，此处选择 4。

- 阶段 Ⅲ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 60   | ∞    | 10   | 30   |
  | P    | 0    | 0    | 0    | -1   | 0    | 4    |
  | F    | 1    | 1    | 0    | 0    | 1    | 0    |

  从 4 出发，可到 5，d=d4+20=30<65，故更新 d5，并将 P5 改为 4.

  在 F=0 的所有点中选择了 d 最小的为 d1=20，作为下一阶段出发点，并将 F1 改为 1。

- 阶段 Ⅳ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 50   | 90   | 10   | 30   |
  | P    | 0    | 0    | 1    | 1    | 0    | 4    |
  | F    | 1    | 1    | 0    | 0    | 1    | 1    |

- 阶段 Ⅴ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 45   | 90   | 10   | 30   |
  | P    | 0    | 0    | 5    | 1    | 0    | 4    |
  | F    | 1    | 1    | 1    | 0    | 1    | 1    |

- 阶段 Ⅵ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 45   | 85   | 10   | 30   |
  | P    | 0    | 0    | 5    | 2    | 0    | 4    |
  | F    | 1    | 1    | 1    | 1    | 1    | 1    |

  直至所有点的 F 值为 1，算法流程结束。

- 最后结果

  |           | 最短距离 | 路径              |
  | ----      | ------- | ----------------- |
  | 从 0 到 0 | 0       | 0                 |
  | 从 0 到 1 | 29      | 0 → 1             |
  | 从 0 到 2 | 45      | 0 → 4 → 5 → 2     |
  | 从 0 到 3 | 85      | 0 → 4 → 5 → 2 → 3 |
  | 从 0 到 4 | 10      | 0 → 4             |
  | 从 0 到 5 | 30      | 0 → 4 → 5         |

#### 1.1.2. 代码实现

使用最小索引堆进行优化后，算法的时间复杂度为 O(ElogV)。
```cpp
// Dijkstra 算法求最短路径
template<typename Graph, typename Weight>
class Dijkstra{

private:
    Graph &G;                   // 图的引用
    int s;                      // 起始点
    Weight *distTo;             // distTo[i] 存储从起始点 s 到 i 的最短路径长度
    bool *marked;               // 标记数组，在算法运行过程中标记节点 i 是否被访问
    vector<Edge<Weight>*> from; // from[i] 记录最短路径中，到达 i 点的边是哪一条
                                // 可以用来恢复整个最短路径

public:
    // 构造函数，使用 Dijkstra 算法求最短路径
    Dijkstra(Graph &graph, int s):G(graph){

        // 算法初始化
        assert( s >= 0 && s < G.V() );
        this->s = s;
        distTo = new Weight[G.V()];
        marked = new bool[G.V()];
        for( int i = 0 ; i < G.V() ; i ++ ){
            distTo[i] = Weight();
            marked[i] = false;
            from.push_back(NULL);
        }

        // 使用索引堆记录当前找到的到达每个顶点的最短距离
        IndexMinHeap<Weight> ipq(G.V());

        // 对于其实点 s 进行初始化
        distTo[s] = Weight();
        from[s] = new Edge<Weight>(s, s, 0);
        ipq.insert(s, distTo[s] );
        marked[s] = true;
        while( !ipq.isEmpty() ){
            int v = ipq.extractMinIndex();

            // distTo[v] 就是 s 到 v 的最短距离
            marked[v] = true;

            // 对 v 的所有相邻节点进行更新
            typename Graph::adjIterator adj(G, v);
            for( Edge<Weight>* e = adj.begin() ; !adj.end() ; e = adj.next() ){
                int w = e->other(v);
                // 如果从 s 点到 w 点的最短路径还没有找到
                if( !marked[w] ){
                    // 如果 w 点以前没有访问过，
                    // 或者访问过，但是通过当前的 v 点到 w 点距离更短，则进行更新
                    if( from[w] == NULL || distTo[v] + e->wt() < distTo[w] ){
                        distTo[w] = distTo[v] + e->wt();
                        from[w] = e;
                        if( ipq.contain(w) )
                            ipq.change(w, distTo[w] );
                        else
                            ipq.insert(w, distTo[w] );
                    }
                }
            }
        }
    }

    // 析构函数
    ~Dijkstra(){
        delete[] distTo;
        delete[] marked;
        delete from[0];
    }

    // 返回从 s 点到 w 点的最短路径长度
    Weight shortestPathTo( int w ){
        assert( w >= 0 && w < G.V() );
        assert( hasPathTo(w) );
        return distTo[w];
    }

    // 判断从 s 点到 w 点是否联通
    bool hasPathTo( int w ){
        assert( w >= 0 && w < G.V() );
        return marked[w];
    }

    // 寻找从 s 到 w 的最短路径，将整个路径经过的边存放在 vec 中
    void shortestPath( int w, vector<Edge<Weight>> &vec ){

        assert( w >= 0 && w < G.V() );
        assert( hasPathTo(w) );

        // 通过 from 数组逆向查找到从 s 到 w 的路径，存放到栈中
        stack<Edge<Weight>*> s;
        Edge<Weight> *e = from[w];
        while( e->v() != this->s ){
            s.push(e);
            e = from[e->v()];
        }
        s.push(e);

        // 从栈中依次取出元素，获得顺序的从 s 到 w 的路径
        while( !s.empty() ){
            e = s.top();
            vec.push_back( *e );
            s.pop();
        }
    }

    // 打印出从 s 点到 w 点的路径
    void showPath(int w){

        assert( w >= 0 && w < G.V() );
        assert( hasPathTo(w) );

        vector<Edge<Weight>> vec;
        shortestPath(w, vec);
        for( int i = 0 ; i < vec.size() ; i ++ ){
            cout<<vec[i].v()<<" -> ";
            if( i == vec.size()-1 )
                cout<<vec[i].w()<<endl;
        }
    }
};
```

### 1.2. Bellman-Ford

当图中含有负权边时，可使用 Bellman-Ford 算法来求解单源最短路径问题。

Bellman-Ford 算法使用的前提是：图中不能有负权环。因为对于拥有负权环的图，没有最短路径。当图中含有负权环时，Bellman-Ford 算法无法找出最短路径，但却能检测出图中是否含有负权环。

Bellman-Ford 算法的时间复杂度为 0(EV)。

## 2. BFS、双向 BFS

## 3. 多源最短路径算法：Floyded-warshall

Floyded-warshall 算法可用于处理无负权环的图，其时间复杂度为 O(V^3)。

## 4. SPFA

## 5. A*

## 6. D*

## 7. Refer Links

https://www.cnblogs.com/hxsyl/p/3270401.html

http://m.blog.csdn.net/article/details?id=6181485

http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html

http://www.tudou.com/programs/view/4JBYJVeD6t0

http://v.youku.com/v_show/id_XOTM1OTcxODU2.html

http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html
