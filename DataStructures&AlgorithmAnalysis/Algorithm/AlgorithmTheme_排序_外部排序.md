- [外部排序 (External sorting)](#external-sorting)
  - [1. 基本概念](#1)
  - [2. 性能优化](#2)
  - [3. 基本原理](#3)
  - [4. 外部归并排序](#4)
    - [4.1. 二路归并排序](#41)
    - [4.2. 多路归并排序](#42)
    - [4.3. 排序效率](#43)
  - [5. 多路平衡归并排序](#5)
    - [5.1. 胜者树 & 败者树](#51)
    - [5.2. 使用败者树加快归并排序](#52)
  - [6. 置换 - 选择排序](#6)
  - [7. 最佳归并树 - 赫夫曼树](#7)
  - [8. Refer Links](#8-refer-links)

# 外部排序 (External sorting)

## 1. 基本概念

内部排序算法所有的操作都是在内存中完成的，算法过程中不需要 I/O，因此算法总体上速度比较快，但当需要对海量数据进行排序时，无法将所有数据读入内存，内部排序算法就显得力不从心了，此时就需要使用外部排序算法。

> 外排序（External sorting）是指能够处理极大量数据的排序算法。通常来说，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。
> 
> 外排序通常采用“排序 - 归并”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。尔后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。

容易看出，外排序事实上采用的是分而治之（Divide and conquer algorithm）的算法设计思想，将一个大问题划分成相对独立的若干个小问题，解决小问题，得到小问题的答案，然后合并小问题的答案，最终得到原始大问题的答案。

## 2. 性能优化

计算机科学家吉姆·格雷的 [Sort Benchmark](http://sortbenchmark.org/) 网站用不同的硬件、软件环境测试了实现方法不同的多种外排序算法的效率。外排序算法的性能优化可以从以下方向进行：
- 并行计算
  - 用多个磁盘驱动器并行处理数据，可以加速顺序磁盘读写。
  - 在计算机上使用多线程，可在多核心的计算机上得到优化。
  - 使用异步输入输出，可以同时排序和归并，同时读写。
  - 使用多台计算机用高速网络连接，分担计算任务。
- 提高硬件速度
  - 增大内存，减小磁盘读写次数，减小归并次数。
  - 使用快速的外存设备，比如 15000 RPM 的硬盘或固态硬盘。
  - 使用性能更优良个各种设备，比如使用多核心 CPU 和延迟时间更短的内存。
- 提高软件速度
  - 对于某些特殊数据，在第一阶段的排序中使用基数排序。
  - 压缩输入输出文件和临时文件。

## 3. 基本原理

外部排序算法通常由两个阶段构成：
- 按照内存大小，将大文件分成若干长度为 l 的子文件（l 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对其进行排序（排好序的子文件统称为“归并段”或者“顺段”），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间。
- 对得到的顺段进行合并，直至得到整个有序的文件为止。

## 4. 外部归并排序

外部排序最常用的算法是外部归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行归并排序。

### 4.1. 二路归并排序

假设我们有一个大文件，里面是待排序的数据，一共 N 个，这些数据在内存中放不下。则排序过程如下：
1. 将该大文件分割成大小为 m 的文件（m 小于可用内存大小）
1. 将这些小文件依次读入内存，在内存中采用任一种排序算法排序并输出文件 F1，F2….Fn。（其实可以和第一步合并，可以省一次 IO）
1. 分块快读取两个已经排完序的文件 Fi 和 Fi+1，由于两个文件已经排完序，这里可以用归并排序，将两个文件排序完毕，并写入文件。（这个过程就好比有两队人马将其合并为一对一样）
1. 重复过程 3，直到剩余文件数为 1。

以上就是二路外部归并排序的基本思路，毫无疑问，这种排序算法需要读取外存（IO）次数为 log(2,N/m)，这时候算法的性能瓶颈已经不在内存中排序的时间复杂度上，而是内外存交换数据 IO 的次数了。

例：

有一个含有 10000 个记录的文件，但是内存的可使用容量仅为 1000 个记录，使用外部归并排序步骤如下：
- 将整个文件其等分为 10 个临时文件（每个文件中含有 1000 个记录），然后将这 10 个文件依次进入内存，采取适当的内存排序算法对其中的记录进行排序，将得到的有序文件（初始归并段）移至外存。
- 对得到的 10 个初始归并段进行如图 1 的两两归并，直至得到一个完整的有序文件。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/3/cb3e1fdf86b7646e6f59c7b2ba0921a2.jpg)

### 4.2. 多路归并排序

对于外部排序算法来说，影响整体排序效率的因素主要取决于读写外存的次数，即访问外存的次数越多，算法花费的时间就越多，效率就越低。

二路归并排序的性能时比较低的，因此就有了多路归并排序算法，其 I/O 的次数为 log(b, N/m)，其中 b 为几路归并。

### 4.3. 排序效率

一般情况下对于具有 m 个初始归并段进行 k- 路平衡归并时，归并的次数为：s = ⌊log(k) ⁡m⌋（其中 s 表示归并次数）。因此，想要达到减少归并次数从而提高算法效率的目的，可以从两个角度实现：
- 增加 k- 路平衡归并中的 k 值，从该角度引申出了多路平衡归并算法。
- 尽量减少初始归并段的个数 m，即增加每个归并段的容量，从该角度引申出了置换 - 选择排序算法。

## 5. 多路平衡归并排序

根据 `s = ⌊log(k) ⁡m⌋` 可知，可以通过增加 k- 路平衡归并中的 k 值来减少归并次数以提高归并排序的效率。但经过计算得知，如果毫无限度地增加 k 值，虽然会减少读写外存数据的次数，但会增加内部归并的时间，得不偿失。

为了避免在增加 k 值的过程中影响内部归并的效率，在进行 k- 路归并时可以使用“败者树”来实现，该方法在增加 k 值时不会影响其内部归并的效率。

### 5.1. 胜者树 & 败者树

胜者树和败者树都是完全二叉树（可以采用一维数组来表示），是树形选择排序的一种变型。每个叶子结点相当于一个选手，每个中间结点相当于一场比赛，每一层相当于一轮比赛。胜者树和败者树的区别在于：胜者树中的非终端结点中存储的是胜利的一方；而败者树中的非终端结点存储的是失败的一方，而在比较过程中，都是拿胜者去比较。

胜者树与败者树可以在 log(n) 的时间内找到最值。而且当任何一个叶子结点的值改变后，利用中间结点的信息，还是能够快速地找到最值。

例：
- 胜者树

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/3/65e502e32f0032aa704e6b3f9cd8aca8.jpg)

  上图所示的树中每个非终端结点（除叶子结点之外的其它结点）中的值都表示的是左右孩子相比较后的较小值（谁最小即为胜者）。例如叶子结点 49 和 使用败者树加快合并排序 38 相对比，由于 38 更小，所以其双亲结点中的值保留的是胜者 38。然后用 38 去继续同上层去比较，一直比较到树的根结点。

  胜者树的一个优点是，如果一个选手的值改变了，可以很容易地修改这棵胜者树。只需要沿着从该结点到根结点的路径修改这棵二叉树，而不必改变其他比赛的结果。

- 败者树

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/3/5c4bd1e3e8606d0ba0b83d54a613e2fc.jpg)

  上图所示为一棵 5- 路归并的败者树，其中 b0—b4 为树的叶子结点，分别为 5 个归并段中存储的记录的关键字。 ls 为一维数组，表示的是非终端结点，其中存储的数值表示第几归并段（例如 b0 为第 0 个归并段）。ls[0] 中存储的为最终的胜者，表示当前第 3 归并段中的关键字最小。

  败者树的重构需要将新进入选择树的结点与其父结点进行比赛并将败者存放在父结点中，而胜者再与上一级的父结点比较。比赛沿着到根结点的路径不断进行，直到根结点处。把败者存放在根结点中，胜者存放在根结点的附加节点中。

  可见，败者树简化了重构。败者树的重构只是与该结点的父结点的记录有关，而胜者树的重构还与该结点的兄弟结点有关。

### 5.2. 使用败者树加快归并排序

把 n 个整数分成 k 组，每组整数都已排序好，要把 k 组数据合并成 1 组排好序的整数时，需要每次从 k 个组中的首元素中选一个最小的数，加入到新组，这样每次都要比较 k-1 次，故算法复杂度为 O((n-1)*(k-1))。而如果使用败者树，可以在 O(logk) 的复杂度下得到最小的数，算法复杂度将为 O((n-1)*logk)，对于外部排序这种数据量超大的排序来说，这是一个不小的提高。

## 6. 置换 - 选择排序

为了增加每一个有序的临时文件的长度以使得临时文件数量减少，可以采用置换选择排序（Replacement selection sorting）。

具体方法是在内存中使用一个最小堆进行排序，设该最小堆的大小为 M。算法描述如下：
1. 初始时将输入文件读入内存，建立最小堆。
1. 将堆顶元素输出至输出缓冲区。然后读入下一个记录：
    - 若该元素的关键码值不小于刚输出的关键码值，将其作为堆顶元素并调整堆，使之满足堆的性质；
    - 否则将新元素放入堆底位置，将堆的大小减 1。
1. 重复第 2 步，直至堆大小变为 0。
1. 此时一个顺串已经产生。将堆中的所有元素建堆，开始生成下一个顺串。

此方法能生成平均长度为 2M 的顺串，可以进一步减少访问外部存储器的次数，节约时间，提高算法效率。

- 例：已知初始文件中总共有 24 个记录，假设内存工作区最多可容纳 6 个记录，按照之前的选择排序算法最少也只能分为 4 个初始归并段。而如果使用置换—选择排序，可以实现将 24 个记录分为 3 个初始归并段：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/4/85aaff465665fce195ae75d6a3eec974.jpg)

  具体操作过程为：
  1. 首先从初始文件中输入 6 个记录到内存工作区中。
  1. 从内存工作区中选出关键字最小的记录，将其记为 MINIMAX 记录。
  1. 然后将 MINIMAX 记录输出到归并段文件中。
  1. 此时内存工作区中还剩余 5 个记录，若初始文件不为空，则从初始文件中输入下一个记录到内存工作区中。
  1. 从内存工作区中的所有比 MINIMAX 值大的记录中选出值最小的关键字的记录，作为新的 MINIMAX 记录。
  1. 重复过程 3—5，直至在内存工作区中选不出新的 MINIMAX 记录为止，由此就得到了一个初始归并段。
  1. 重复 2—6，直至内存工作为空，由此就可以得到全部的初始归并段。

  在上述创建初始段文件的过程中，需要不断地在内存工作区中选择新的 MINIMAX 记录，即选择不小于旧的 MINIMAX 记录的最小值，此过程需要利用“败者树”来实现。

  同上一节所用到的败者树不同的是，在不断选择新的 MINIMAX 记录时，为了防止新加入的关键字值小的的影响，每个叶子结点附加一个序号位，当进行关键字的比较时，先比较序号，序号小的为胜者；序号相同的关键字值小的为胜者。

  通过不断地向败者树中读入记录，会产生多个 MINIMAX，直到最终所有叶子结点中的序号都为 2，此时产生的新的 MINIMAX 值的序号 2，表明此归并段生成完成，而此新的 MINIMAX 值就是下一个归并段中的第一个记录。

## 7. 最佳归并树 - 赫夫曼树

无论是通过等分还是置换 - 选择排序得到的归并段，如何设置它们的归并顺序，可以使得对外存的访问次数降到最低？

我们知道带权路径长度最短的二叉树为赫夫曼树，其实扩展到一般情况，对于 k 叉树，只要其带权路径长度最短，亦可以称为赫夫曼树。通过以构建赫夫曼树的方式构建归并树，使其对读写外存的次数降至最低（k- 路平衡归并，需要选取合适的 k 值，构建赫夫曼树作为归并树）。所以称此归并树为最佳归并树。

- 例：现有通过置换选择排序算法所得到的 9 个初始归并段，其长度分别为：9，30，12，18，3，17，2，6，24。在对其采用 3- 路平衡归并的方式时可能出现如下图所示的情况：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/4/63e1946c7babfdfeab0bd4da479d6af6.jpg)

  在进行平衡归并时，操作每个记录都需要单独进行一次对外存的读写，那么上图中的归并过程需要对外存进行读或者写的次数为：
  > （9+30+12+18+3+17+2+6+24）*2*2=484（涉及到了两次归并，对外存的读和写各进行 2 次）

  从计算结果上看，对于图中 3 叉树来讲，其操作外存的次数恰好是树的带权路径长度的 2 倍。所以，**对于如何减少访问外存的次数的问题，就等同于考虑如何使 k- 路归并所构成的 k 叉树的带权路径长度最短**。因此，若想使树的带权路径长度最短，就是构造赫夫曼树：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/4/4b1ea07bbc743ce77072bd635e0e5363.jpg)

  其对外存的读写次数为：、
  > (2*3+3*3+6*3+9*2+12*2+17*2+18*2+24*2+30)*2=446

## 8. Refer Links

[外排序算法 - 北京大学 | Coursera](https://www.coursera.org/learn/gaoji-shuju-jiegou/lecture/wygDn/wen-jian-zu-zhi)

[维基百科：外排序](https://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F)

[外部排序算法](http://data.biancheng.net/out_sort/)

[外部排序 & 多路归并排序](https://www.cnblogs.com/LUO77/p/5838206.html)