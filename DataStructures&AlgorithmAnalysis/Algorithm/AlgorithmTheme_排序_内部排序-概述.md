- [内部排序 - 概述](#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F---%E6%A6%82%E8%BF%B0)
	- [1. 排序算法的稳定性](#1-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7)
	- [2. 排序算法的基本操作](#2-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)
	- [3. 排序算法的效率](#3-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87)
	- [4. 排序算法的分类](#4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB)
		- [4.1. 比较排序](#41-%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F)
		- [4.2. 非比较排序](#42-%E9%9D%9E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F)

# 内部排序 - 概述

## 1. 排序算法的稳定性

在待排序文件中，若存在**多个关键码相同的记录**，经过排序后，这些**具有相同关键码的记录之间的相对次序保持不变**，则称该排序方法是稳定的；否则，称这种排序方法是不稳定的。

稳定性的好处：排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，**如果排序算法稳定，可以避免多余的比较**。

事实上，**若对排序的稳定性有要求，可以自定义实现一个元素值的比较器，在相等的情况下自定义其它比较策略，从而可以在不稳定的排序算法上实现“稳定”地排序**。

## 2. 排序算法的基本操作

- 比较两个关键码的大小。
- 将记录从一个位置移动到另一个位置。

## 3. 排序算法的效率

评价排序算法的效率主要有两点：
- 在数据规模一定的条件下，算法执行所消耗的**平均时间**

	对于排序操作，时间主要消耗在关键码之间的**比较**和数据元素的**移动**上，因此可认为**高效率的排序算法应该有尽可能少的比较次数和尽可能少的数据元素移动次数**。

- 在数据规模一定的条件下，执行算法所需要的**辅助存储空间**

	辅助存储空间是除了存放待排序数据元素占用的存储空间之外，执行算法所需要的其他存储空间。**理想的空间效率是，算法执行期间所需要的辅助空间与待排序的数据量无关**。

## 4. 排序算法的分类

排序算法可分为基于比较的排序，和非比较的排序。

### 4.1. 比较排序

**基于比较的排序需要对序列中的数据进行比较，其时间效率无法突破 O(NlogN)**。

> N 个数有 N! 个可能的排列情况，也就是说基于比较的排序算法的判定树有 N! 个叶子结点，因此比较次数至少为 log(N!)=O(NlogN)（斯特林公式)。

### 4.2. 非比较排序

**非基于比较的排序则可以突破 O(NlogN) 时间下限**。

但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制（在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。
