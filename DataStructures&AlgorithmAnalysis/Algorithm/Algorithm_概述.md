- [算法：概述](#%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A6%82%E8%BF%B0)
  - [1. 算法描述](#1-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0)
  - [2. 算法设计要求](#2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%A6%81%E6%B1%82)
  - [3. 算法分析](#3-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90)
    - [3.1. 时间复杂度](#31-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
      - [3.1.1. （渐进）时间复杂度](#311-%EF%BC%88%E6%B8%90%E8%BF%9B%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
      - [3.1.2. O(f(n)) 简化规则](#312-ofn-%E7%AE%80%E5%8C%96%E8%A7%84%E5%88%99)
      - [3.1.3. 时间复杂度分析](#313-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)
        - [3.1.3.1. 非递归程序](#3131-%E9%9D%9E%E9%80%92%E5%BD%92%E7%A8%8B%E5%BA%8F)
        - [3.1.3.2. 递归程序](#3132-%E9%80%92%E5%BD%92%E7%A8%8B%E5%BA%8F)
        - [3.1.3.3. 均摊分析 (Amortized Time)](#3133-%E5%9D%87%E6%91%8A%E5%88%86%E6%9E%90-amortized-time)
      - [3.1.4. 常见数据规模](#314-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1)
    - [3.2. 空间复杂度](#32-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)

# 算法：概述

## 1. 算法描述

算法 (Algorithm) 定义：为解决某一类问题而设计的一个有限长的操作序列。一个算法必须满足以下 5 个重要特性：

- 有穷性。算法对于任意合法的输入值，在执行有限步之后一定能结束。

- 确定性。算法中的每一个操作必须有确切的含义，无二义性，并在任何条件下，算法都只有一条执行路径。

- 可行性。算法中的所有操作都可通过已经实现的基本运算有限次地实现。

- 输入。算法具有零个或多个输入，这些输入为一组特定的数据对象集合。

- 输出。算法具有一个或多个输出，它是一组与“输入”有确定关系的量值。

## 2. 算法设计要求

- 正确性（correctness）。
  
  算法的执行结果应当满足预先规定的 4 个要求：
  - 程序不含语法错误。
  - 程序对于几组输入数据能够得出满足规格说明要求的结果。
  - 程序对于精心选择的典型、苛刻且带有刁难性的几组输入数据能得出满足规格说明要求的结果。
  - 程序对于一切合法的输入数据都能产生满足规格说明要求的结果。

- 可读性（readability）。

  算法应有助于人们阅读、理解和调试，晦涩难懂的算法易于隐藏较多错误，难以调试和修改。

- 健壮性（robustness）。

  当输入不合法的数据时，算法能够做出适当的反应或处理，不至于产生莫名其妙的结果。同时，处理出错的方法应该是返回一个表示错误或错误性质的值，并终止程序的执行，以便在更高的抽象层次上进行处理。

- 时空效率（efficiency）。

  要求算法执行的时间应该尽可能短、算法执行过程中占用的存储空间应该尽可能少。
  
  时空要求与求解问题的规模有关，两者通常相互矛盾，因此，应在它们之间有所平衡。

## 3. 算法分析

算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度，主要考察算法的时间效率和空间效率，以便比较和改进算法。

通常，在算法的运算空间较为充裕的情况下，更多地关注算法的时间复杂度。

### 3.1. 时间复杂度

算法执行的时间可通过依据该算法编制的程序在计算机上从开始运行到结束运行所消耗的时间来度量，也就是算法中每条语句的执行时间之和。但由于每条语句的实际执行时间与机器性能、编译程序等诸多因素有关，难以统一和确定，因此，通常假设每条语句的执行时间为一个单位时间，则算法的执行时间为算法中所有语句的频度之和。

#### 3.1.1. （渐进）时间复杂度

一般而言，算法中基本操作的频度是问题规模 n（如算法所处理的矩阵的阶数，线性表的长度）的某个函数 f(n)，算法的时间量度记作 T(n)=O(f(n))，它表示随问题规模 n 的增大，算法的执行时间增长率与 f(n) 的增长率相同，称为算法的**渐进时间复杂度**（asymptotic time complexity），简称为**时间复杂度**。**时间复杂度并不是表示一个程序解决一个问题要花多少时间，而是当问题规模扩大后，程序解决问题所需要时间的增长有多快**。

要全面地分析算法，需要分别考虑算法在最坏情况、最好情况以及平均情况下的时间代价。对于最坏情况下的时间复杂度，主要采用大写数学符号 O 表示法来描述。一般定义为：当且仅当存在正整数 c 和 n0，使得 T(n) ≤ c f(n) 对所有的 n ≥ n0 成立（T(n) 为不超过 f(n) 常数倍的值，表示所有语句的频度之和），则称该算法的渐进时间复杂度为 T(n)=O(f(n))，其中 n 为问题的规模，f(n) 为算法中执行次数最多的语句的频度的数量级。

由于算法的时间复杂度考虑的只是对于问题规模 n 的增长率，因此在难以精确地计算基本操作执行次数（语句频度）的情况下，只需求出它关于 n 的增长率或阶即可。

#### 3.1.2. O(f(n)) 简化规则

设 T1(n) 和 T2(n) 分别是程序段 P1 和 P2 的运行时间，且 T1(n)=O(f(n))，T2(n)=O(g(n))，即 T1(n) 是 f(n) 的函数，T2(n) 是 g(n) 的函数，则执行 P1 之后紧接着执行 P2 的运行时间为：
- 加法规则：`T1(n) + T2(n) = O(max{f(n)，g(n)})`
- 乘法规则：`T1(n) × T2(n) = O[f(n) × g(n)]`

由加法规则和乘法规则可得到 O(f(n)) 中 f(n) 的简化规则，即只保留最大的一项。例：O(2^(n+7) + 10n^50 + 98logn) 化简结果为 O(2^n)。

常见的时间复杂度比较：
```
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < ... < O(2^n)
```

根据算法的时间复杂度，可将算法分为：
- 多项式时间算法（有效算法）（P 问题）：f(n) 为多项式（如：n、nlogn、n^t）。
- 指数时间算法（NPC 问题）：f(n) 为指数式、阶乘式（如：2^n、n!）。

#### 3.1.3. 时间复杂度分析

一般来说，分析程序的时间复杂度是，先求出各模块（各语句）的运行时间，再求整个程序的运行时间，它可表示成唯一参数——输入数据的规模 n 的函数。

##### 3.1.3.1. 非递归程序

若程序中只包含非递归过程，则从没有调用语句（对函数也认为是调用）的过程开始，计算所有这种过程的运行时间。然后考虑有调用语句的任一过程 P，在 P 调用的全部过程的运行时间都算完之后，即可开始计算 P 的运行时间。

- 赋值语句

  每个赋值或读 / 写语句的运行时间通常是 O(1)。如果赋值语句的右部为函数调用，则要考虑计算函数值所消耗的时间。

- 序列语句

  序列语句的运行时间由加法规则确定。

- 条件语句

  语句 if B then S1 else S2 的运行时间为条件 B 的测试时间（通常取 O(1)）加上两个分支语句 S1、S2 运行时间的较大者。若无 else S2，则只需加上 S1 的运行时间。

- 循环语句

  循环语句的运行时间是循环体本身的运行时间和计算循环参数、测试循环终止条件及跳回循环开头所花的时间，后一部分通常取 O(1)。遇到多层循环时，要由内层向外层逐层分析。在分析外层循环时间时，内层循环的运行时间应该是已知的，可把内循环看成是外循环体的一部分。

  例 1：下面是一个 n×n 阶矩阵 A 自乘得到 B=A×A 的算法，分析其时间复杂度。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/20/d06ba3b6ade519ca699f91928879bdd1.jpg)

  分析：`T(n) = n + 1 + n(n + 1) + n × n + n^2 x (n + 1) + n × n × n = 2n^3 + 3n^2 + 2n + 1`。当 n → ∞ 时，T(n) ∝ n3，故算法时间复杂度的数量级为 O(n^3)。

  例 2：
  ```cpp
  int i = 0;
  while (i < n && x != A[i]) i ++;
  if (A[i] == x) return i;
  ```
  分析：在此程序段中，语句的频度不仅是 n 的函数，而且与 x 及数组 A 中各分量的值有关。在这种情况下，通常考虑最坏的情况。由于 while 循环执行的最大数为 n-1，因此`i ++`频度为 n-1，程序的时间复杂度为 O(n)。

  NOTE: 对于有 k 层循环的程序，不可直接判断程序的时间复杂度为 O(n^k)。因为可能不是每层循环需要执行的次数都与 n 相关，也可能循环的增量步长不是 1，需要进行具体分析。例：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/18/8c45c10504f652cc669eea23a35ef567.jpg)

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/18/a0cd3191a654227006eaee27049d8cd7.jpg)

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/18/25ce0b2ef2b4d07893a4f96cac681ff8.jpg)

##### 3.1.3.2. 递归程序

若在程序中有递归过程，则需要根据每次递归中递归调用的次数、每次递归的时间复杂度以及递归的深度进行具体分析。

- 递归中进行一次递归调用

  如果递归函数中只进行一次递归调用，递归深度与递归次数相同，每次递归调用的时间复杂度为 T，递归深度为 d，则总体的时间复杂度为 O(T*d)。

  例 1：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/18/7ab01af4a7719f9b9eb52d9896717021.jpg)

  每次递归中最多再进行一次递归调用，且每次递归执行的时间效率为 O(1)，总共的递归深度为 logn，因此整个程序的时间复杂度为 O(logn)。

  例 2：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/18/87c4db24593c1e1dfb4d4c444284f57e.jpg)

  例 3：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/18/c7332d3bb62cc06121df4abc96921a1f.jpg)

- 递归中进行多次递归调用

  如果递归函数中只进行多次递归调用，递归深度与递归次数是不同的，因此需要计算递归调用的次数。

  在这种情况下，通常需要根据“递归树”来进行分析。若在每次递归中进行 2 次递归调用，递归树有 n 层（从 0 开始计算），则递归树的节点个数为`2^0 + 2^1 + 2^2 + ... + 2^n = 2^(n+1)-1`，也就是说递归调用的次数为 `2^(n+1)-1`。

  例 1：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/18/ff3b72649822c16ec3234643e2c33744.jpg)

  当调用 f(3) 时，递归树如上图所示，递归树的节点个数为 15。因此可知，若传入参数为 n，则递归树的深度为 n，递归调用的次数是 2^(n+1)-1，每次递归的时间复杂度为 O(1)，故整个程序的时间复杂度为指数级的 O(2^n)。

  例 2：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/18/a2c1384afe8a84d593e789ddee8ad0b9.jpg)

  若传入序列的长度 n，则递归树的深度为 logn，那么递归树的节点数也就是递归调用的总次数是 2^(logn+1)-1，但是由于递归树每个节点上的运算时间是不等的，因此还需要分析递归树每一层需要处理的节点数：
  - 归并排序第 0 层只有一个递归调用，这个递归调用的 merge 操作要处理 n 个节点；
  - 归并排序第 1 层有两个调用，每个调用需要 merge 处理 n/2 个节点，总共是 n/2*2=n 个节点；
  - 归并排序第 2 层有四个调用，每个调用需要 merge 处理 n/4 个节点，总工共是 n/4*4=n 个节点；
  - ....
  - 归并排序第 k 层有 2^k 个调用，每个调用需要 merge 处理 n/(2^k) 个节点，总工室 n/(2^k)*(2^k)=n 个节点；
  因此可见，在每一层的递归，总共处理的节点个数均为 n 个节点，故整个程序的时间复杂度为 O(nlogn)。

- 更加复杂的递归分析：主定理（包含了所有递归情况的分析）

##### 3.1.3.3. 均摊分析 (Amortized Time)

有时候某些算法的时间复杂度较高，但这个算法设计的目的是为了便于其它的算法操作，因此此时可以将该算法的复杂度均摊到其它算法上，这种情况下的复杂度分析称为均摊复杂度分析 (Amortized Time)。

例：动态数组 Vector 中的添加元素操作
```cpp
// 复杂度为 O(n)
void resize(int newCapacity){

    assert(newCapacity >= _size);
    T *newData = new T[newCapacity];
    for(int i = 0 ; i < _size ; i ++)
        newData[i] = _data[i];
    delete[] _data;

    _data = newData;
    _capacity = newCapacity;
}

// 平均复杂度为 O(1)
void push_back(T e){
    if( _size == _capacity )
        resize( 2 * _capacity );

    _data[_size++] = e;
}
```
在 push_back 方法中，当数组长度达到容量上限时，会执行 O(n) 的 resize 操作，但由于每执行 n 次的 push_back 才需要进行一次 resize，因此均摊之后，push_back 操作的时间复杂度还是 O(1)。

- 复杂度振荡问题

  在设计均摊复杂度的算法时，需要避免发生复杂度振荡问题。

  例：动态数组 Vector 中的删除元素操作
  ```cpp
  // 平均复杂度为 O(n)
  T pop_back(){
      assert(_size > 0);
      T ret = _data[_size-1];
      _size --;

      if(_size == _capacity / 2)
          resize(_capacity / 2);

      return ret;
  }
  ```
  若将 pop_back 操作设计为以上逻辑，即每当数组长度缩小到 n/2 时，就将数组 resize 为 n/2，则存在极端情况：如果数组长度总在 n/2 附近振荡，会导致 Vector 频繁的执行 resize 操作，导致 O(n) 无法均摊到每一次 push 或 pop 中，进而导致 push/pop 的复杂度退化为 O(n)。

  为避免这种复杂度振荡问题，可以将缩小容量的边界设置为 1/4，且 resize 的容量是当前最大容量的 1/2，为 size 的振荡留出空间：
  ```cpp
  // 平均复杂度为 O(1)
  T pop_back(){
      assert(_size > 0);
      T ret = _data[_size-1];
      _size --;

      // 在 size 达到静态数组最大容量的 1/4 时才进行 resize
      // resize 的容量是当前最大容量的 1/2
      // 防止复杂度的震荡
      if(_size == _capacity / 4)
          resize(_capacity / 2);

      return ret;
  }
  ```

#### 3.1.4. 常见数据规模

若需要在 1s 之内解决问题：
- 使用 O(n^3) 的算法可以处理大约 10^2 级别（百）的数据。
- 使用 O(n^2) 的算法可以处理大约 10^4 级别（千）的数据。
- 使用 O(nlogn) 的算法可以处理大约 10^7 级别（百万）的数据。
- 使用 O(n) 的算法可以处理大约 10^8 级别（千万）的数据。

### 3.2. 空间复杂度

算法在执行时需要占用一定的存储空间，这些空间除了包括程序、输入数据、常数、变量所占的空间外，还包括算法对输入数据进行运算以及为实现运算所需信息的额外空间。额外空间与算法的质量密切相关，好的算法既节省时间又节省额外空间。

类似于算法的时间复杂度，一般以**空间复杂度**（space complexity）作为算法所需存储空间的量度，记作 `S(n)=O(f(n))`，其中 n 为问题的规模（或大小）。

对算法占用存储空间的分析类似于时间复杂度。估计渐近空间复杂度，称为空间复杂度。由于问题中原始数据所占用的空间与算法无关，故一般考虑空间复杂度时只估算算法中所需增添的辅助空间。

在大多数的算法设计中，时间效率和空间效率两者相互矛盾、很难兼得，设计者往往需要根据具体的问题进行权衡，有时会用更多的存储空间来换取更少的执行时间（如：通过预处理），有的时候又会用增加算法执行时间来减少所需的存储空间（如：通过重复运算）。

例：
- 多开了常数空间（临时变量）：O(1)。
- 多开了一个辅助的数组：O(n)。
- 多开了一个辅助的二维数组：O(n^2)。
- 递归算法中递归调用是需要空间代价的，若在递归调用中递归的深度为 n，则空间复杂度为 O(n)。