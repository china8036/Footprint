- [算法：概述](#%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A6%82%E8%BF%B0)
  - [1. 算法描述](#1-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0)
  - [2. 算法设计要求](#2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%A6%81%E6%B1%82)
  - [3. 算法分析](#3-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90)
    - [3.1. 时间复杂度](#31-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
      - [3.1.1. （渐进）时间复杂度](#311-%EF%BC%88%E6%B8%90%E8%BF%9B%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
      - [3.1.2. O(f(n)) 简化规则](#312-ofn-%E7%AE%80%E5%8C%96%E8%A7%84%E5%88%99)
      - [3.1.3. 时间复杂度分析](#313-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)
    - [3.2. 空间复杂度](#32-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)

# 算法：概述

## 1. 算法描述

算法 (Algorithm) 定义：为解决某一类问题而设计的一个有限长的操作序列。一个算法必须满足以下 5 个重要特性：

- 有穷性。算法对于任意合法的输入值，在执行有限步之后一定能结束。

- 确定性。算法中的每一个操作必须有确切的含义，无二义性，并在任何条件下，算法都只有一条执行路径。

- 可行性。算法中的所有操作都可通过已经实现的基本运算有限次地实现。

- 输入。算法具有零个或多个输入，这些输入为一组特定的数据对象集合。

- 输出。算法具有一个或多个输出，它是一组与“输入”有确定关系的量值。

## 2. 算法设计要求

- 正确性（correctness）。
  
  算法的执行结果应当满足预先规定的 4 个要求：
  - 程序不含语法错误。
  - 程序对于几组输入数据能够得出满足规格说明要求的结果。
  - 程序对于精心选择的典型、苛刻且带有刁难性的几组输入数据能得出满足规格说明要求的结果。
  - 程序对于一切合法的输入数据都能产生满足规格说明要求的结果。

- 可读性（readability）。

  算法应有助于人们阅读、理解和调试，晦涩难懂的算法易于隐藏较多错误，难以调试和修改。

- 健壮性（robustness）。

  当输入不合法的数据时，算法能够做出适当的反应或处理，不至于产生莫名其妙的结果。同时，处理出错的方法应该是返回一个表示错误或错误性质的值，并终止程序的执行，以便在更高的抽象层次上进行处理。

- 时空效率（efficiency）。

  要求算法执行的时间应该尽可能短、算法执行过程中占用的存储空间应该尽可能少。
  
  时空要求与求解问题的规模有关，两者通常相互矛盾，因此，应在它们之间有所平衡。

## 3. 算法分析

算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度，主要考察算法的时间效率和空间效率，以便比较和改进算法。

通常，在算法的运算空间较为充裕的情况下，更多地关注算法的时间复杂度。

### 3.1. 时间复杂度

算法执行的时间可通过依据该算法编制的程序在计算机上从开始运行到结束运行所消耗的时间来度量，也就是算法中每条语句的执行时间之和。但由于每条语句的实际执行时间与机器性能、编译程序等诸多因素有关，难以统一和确定，因此，通常假设每条语句的执行时间为一个单位时间，则算法的执行时间为算法中所有语句的频度之和。

#### 3.1.1. （渐进）时间复杂度

一般而言，算法中基本操作的频度是问题规模 n（如算法所处理的矩阵的阶数，线性表的长度）的某个函数 f(n)，算法的时间量度记作 T(n)=O(f(n))，它表示随问题规模 n 的增大，算法的执行时间增长率与 f(n) 的增长率相同，称为算法的**渐进时间复杂度**（asymptotic time complexity），简称为**时间复杂度**。**时间复杂度并不是表示一个程序解决一个问题要花多少时间，而是当问题规模扩大后，程序解决问题所需要时间的增长有多快**。

要全面地分析算法，需要分别考虑算法在最坏情况、最好情况以及平均情况下的时间代价。对于最坏情况下的时间复杂度，主要采用大写数学符号 O 表示法来描述。一般定义为：当且仅当存在正整数 c 和 n0，使得 T(n) ≤ c f(n) 对所有的 n ≥ n0 成立（T(n) 为不超过 f(n) 常数倍的值，表示所有语句的频度之和），则称该算法的渐进时间复杂度为 T(n)=O(f(n))，其中 n 为问题的规模，f(n) 为算法中执行次数最多的语句的频度的数量级。

由于算法的时间复杂度考虑的只是对于问题规模 n 的增长率，因此在难以精确地计算基本操作执行次数（语句频度）的情况下，只需求出它关于 n 的增长率或阶即可。

#### 3.1.2. O(f(n)) 简化规则

设 T1(n) 和 T2(n) 分别是程序段 P1 和 P2 的运行时间，且 T1(n)=O(f(n))，T2(n)=O(g(n))，即 T1(n) 是 f(n) 的函数，T2(n) 是 g(n) 的函数，则执行 P1 之后紧接着执行 P2 的运行时间为：
- 加法规则：`T1(n) + T2(n) = O(max{f(n)，g(n)})`
- 乘法规则：`T1(n) × T2(n) = O[f(n) × g(n)]`

由加法规则和乘法规则可得到 O(f(n)) 中 f(n) 的简化规则，即只保留最大的一项。例：O(2^(n+7) + 10n^50 + 98logn) 化简结果为 O(2^n)。

常见的时间复杂度比较：
```
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < ... < O(2^n)
```

根据算法的时间复杂度，可将算法分为：
- 多项式时间算法（有效算法）（P 问题）：f(n) 为多项式（如：n、nlogn、n^t）。
- 指数时间算法（NPC 问题）：f(n) 为指数式、阶乘式（如：2^n、n!）。

#### 3.1.3. 时间复杂度分析

一般来说，分析程序的时间复杂度是，先求出各模块（各语句）的运行时间，再求整个程序的运行时间，它可表示成唯一参数——输入数据的规模 n 的函数。具体可遵循以下规则：

- 赋值语句

  每个赋值或读 / 写语句的运行时间通常是 O(1)。如果赋值语句的右部为函数调用，则要考虑计算函数值所消耗的时间。

- 序列语句
  
  序列语句的运行时间由加法规则确定。

- 条件语句

  语句 if B then S1 else S2 的运行时间为条件 B 的测试时间（通常取 O(1)）加上两个分支语句 S1、S2 运行时间的较大者。若无 else S2，则只需加上 S1 的运行时间。

- 循环语句

  循环语句的运行时间是循环体本身的运行时间和计算循环参数、测试循环终止条件及跳回循环开头所花的时间，后一部分通常取 O(1)。遇到多层循环时，要由内层向外层逐层分析。在分析外层循环时间时，内层循环的运行时间应该是已知的，可把内循环看成是外循环体的一部分。

  例 1：下面是一个 n×n 阶矩阵 A 自乘得到 B=A×A 的算法，分析其时间复杂度。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/20/d06ba3b6ade519ca699f91928879bdd1.jpg)

  分析：`T(n) = n + 1 + n(n + 1) + n × n + n^2 x (n + 1) + n × n × n = 2n^3 + 3n^2 + 2n + 1`。当 n → ∞ 时，T(n) ∝ n3，故算法时间复杂度的数量级为 O(n^3)。

  例 2：
  ```cpp
  int i = 0;
  while (i < n && x != A[i]) i ++;
  if (A[i] == x) return i;
  ```
  分析：在此程序段中，语句的频度不仅是 n 的函数，而且与 x 及数组 A 中各分量的值有关。在这种情况下，通常考虑最坏的情况。由于 while 循环执行的最大数为 n-1，因此`i ++`频度为 n-1，程序的时间复杂度为 O(n)。

- 递归程序

  若程序中只包含非递归过程，则从没有调用语句（对函数也认为是调用）的过程开始，计算所有这种过程的运行时间。然后考虑有调用语句的任一过程 P，在 P 调用的全部过程的运行时间都算完之后，即可开始计算 P 的运行时间。若在程序中有递归过程，则可令每个递归过程对应于一个未知的时间开销函数 T(n)，其中 n 是过程参数的长度。之后列出一个关于 T 的递归方程并求解之。

  例：
  
  分析计算 n！的递归函数 fact(n) 的时间复杂度。
  ```cpp
  long fact(int n) {
    if (n == 1)
      return 1;
    return fact(n-1) * n;
  }
  ```
  分析：递归函数 fact(n) 的输入规模是 n，设 T(n) 是 fact(n) 的时间开销函数。在上述算法中，if 语句条件测试及语句 return 的运行时间是 O(1)，递归调用 fact(n–1) 的运行时间是 T(n–1)。假设两个整数相乘和赋值操作的运算时间是 O(1)，故 `return fact(n-1)*n` 的运行时间是 O(1)+T(n-1)。

  因此，可得以下递归方程：
  ```
  T(n) = D，n ≤ 1，D 为常数；
  T(n) = C + T(n - 1)，n > 1，C 为常数。
  ```
  设 n>2，对上式中 T(n-1) 进行展开有 T(n-1)=C+T(n-2)，代入 T(n) 中，有 T(n)=2C+T(n-2)，再展开 T(n–2) 得 T(n)=3C+T(n-3)。因此对于一般情况有：T(n)=iC+T(n-i)，n>i。
  
  最后，当 i=n-1 时，得 T(n)=C(n-1)+T(1)=C(n–1)+D。当 n → ∞时，T(n) ∝ n，即程序的时间复杂度为 O(n)。

### 3.2. 空间复杂度

算法在执行时需要占用一定的存储空间，这些空间除了包括程序、输入数据、常数、变量所占的空间外，还包括算法对输入数据进行运算以及为实现运算所需信息的额外空间。额外空间与算法的质量密切相关，好的算法既节省时间又节省额外空间。

类似于算法的时间复杂度，一般以**空间复杂度**（space complexity）作为算法所需存储空间的量度，记作 `S(n)=O(f(n))`，其中 n 为问题的规模（或大小）。

对算法占用存储空间的分析类似于时间复杂度。估计渐近空间复杂度，称为空间复杂度。由于问题中原始数据所占用的空间与算法无关，故一般考虑空间复杂度时只估算算法中所需增添的辅助空间。

在大多数的算法设计中，时间效率和空间效率两者相互矛盾、很难兼得，设计者往往需要根据具体的问题进行权衡，有时会用更多的存储空间来换取更少的执行时间（如：通过预处理），有的时候又会用增加算法执行时间来减少所需的存储空间（如：通过重复运算）。
