- [Algorithm：Bitmap](#algorithm%EF%BC%9Abitmap)
  - [1. 基本概念](#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
  - [2. 应用](#2-%E5%BA%94%E7%94%A8)
    - [2.1. 排序](#21-%E6%8E%92%E5%BA%8F)
    - [2.2. 大量数据的去重](#22-%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%BB%E9%87%8D)
    - [2.3. 大量数据的查询](#23-%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9F%A5%E8%AF%A2)
    - [2.4. Bloom Filter](#24-bloom-filter)
  - [3. Refer Links](#3-refer-links)
  
# Algorithm：Bitmap

## 1. 基本概念

所谓的 Bit-map 就是用一个 bit 位来标记某个元素对应的 Value，而 Key 即是该元素。由于采用了 Bit 为单位来存储数据，可以大大节省存储空间。

32 位机器上，对于一个整型数，比如 int a=1 在内存中占 32bit 位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费，因为我们可以用对应的 32bit 位对应存储十进制的 0-31 个数，而这就是 Bit-map 的基本思想。

## 2. 应用

Bit-map 算法利用这种思想可以将存储空间进行压缩，以处理大量数据的排序、查询以及去重。

NOTE: 使用 Bit-map 前要获取这个序列的最大值来作为空间分配的依据，时间复杂度为 O(n)。

### 2.1. 排序

- 要求：对 5 个元素 (4,7,2,5,3) 排序（这些元素没有重复）。

- 解析：

  可以看到元素的取值范围是 0-7，那么我们就可以采用 Bit-map 的方法来达到排序的目的。
  
  要表示 8 个数，我们就只需要 8 个 Bit（1Bytes），首先我们开辟 1Byte 的空间，将这些空间的所有 Bit 位都置为 0：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/526c4ad96b074b1cee644a5fe00b4a59.jpg)

  然后遍历这 5 个元素：
  - 首先第一个元素是 4，那么就把 4 对应的位置为 1（可以这样操作 p+(i/8)|(0x01<<(i%8)) ，因为是从零开始的，所以要把第五位置为一；
  - 然后再处理第二个元素 7，将第八位置为 1；
  - 一直到最后处理完所有的元素，将相应的位置为 1。
  这时候的内存的 Bit 位的状态如下： 

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/b18722cbdd02b869a689a97a2316f1a7.jpg)

  然后我们现在遍历一遍 Bit 区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度 O(n)。实际上，这也就是桶排序的基本思想。

- 优点：
  - 运算效率高，不需要进行比较和移位。
  - 占用内存少。比如 N=10000000，只需占用内存为 N/8=1250000Byte=1.25M。

- 缺点：
  - 所有的数据不能重复，即无法对重复的数据进行排序和查找。    

### 2.2. 大量数据的去重

- 要求：在 2.5 亿个整数中找出**不重复的整数的个数**，已知内存空间不足以容纳这 2.5 亿个整数。 

- 解析：

  首先，根据“内存空间不足以容纳这 2.5 亿个整数”我们可以快速的联想到 Bit-map，下边关键的问题就是怎么设计我们的 Bit-map 来表示这 2.5 亿个数字的状态了。

  一个数字的状态只有三种，分别为不存在 / 只有一个 / 有重复。因此，我们只需要 2bits 就可以对一个数字的状态进行存储了，假设我们设定一个数字不存在为 00，存在一次 01，存在两次及其以上为 11。那我们大概需要存储空间：
  ```
  2.5 * 10^8 * 2 bits = 5 * 10^8 bits = 62.5 * 10^6 bytes = 62.5 M
  ```
  接下来的任务就是遍历一次这 2.5 亿个数字，如果对应的状态位为 00，则将其变为 01；如果对应的状态位为 01，则将其变为 11；如果为 11, 对应的状态位保持不变。

  最后，我们将状态位为 01 的进行统计，就得到了不重复的数字个数，时间复杂度为 O(n)。

### 2.3. 大量数据的查询

- 要求：现有 2.5 亿个整数，如何快速判断一个数字是够存在于上述的 2.5 亿个数字集合中，已知内存空间不足以容纳这 2.5 亿个整数。 

- 解析：

  这种情况下对于一个数字只需要一个 bit 位就可以了，0 表示不存在，1 表示存在。

  首先我们先对所有的数字进行一次遍历，然后将相应的转态位改为 1。
  
  遍历完以后就是查询，由于我们的 Bit-map 采取的是连续存储（整型数组形式，一个数组元素对应 32bits），我们实际上是采用了一种分桶的思想。一个 int 类型的数组元素可以存储 32 个状态位，那将待查询的数字除以 32，定位到对应的数组元素（桶），然后再求余（%32），就可以定位到相应的状态位。如果为 1，则代表该数字存在；否则，该数字不存在。

### 2.4. Bloom Filter

Bloom Filter 是一种空间效率很高的随机数据结构，它利用**位数组**很简洁地表示一个集合，并能判断一个元素是否属于这个集合。

- Bloom Filter 是如何用位数组表示集合的？

  初始状态时，Bloom Filter 是一个包含 m 位的位数组，每一位都置为 0。

  为了表达 S={x1, x2,…,xn}这样一个 n 个元素的集合，Bloom Filter 使用 k 个相互独立的哈希函数（Hash Function），它们分别将集合中的每个元素映射到{1,…,m}的范围中。对任意一个元素 x，第 i 个哈希函数映射的位置 hi(x) 就会被置为 1（1≤i≤k）。注：如果一个位置多次被置为 1，那么只有第一次会起作用，后面几次将没有任何效果。

  在判断 y 是否属于这个集合时，对 y 应用 k 次哈希函数，若所有 hi(y) 的位置都是 1（1≤i≤k），就认为 y 是集合中的元素，否则就认为 y 不是集合中的元素。

- 可以看到，Bloom Filter 的这种高效是有一定代价的。在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive），因此 Bloom Filter 不适合那些“零错误”的应用场合，而**在能容忍低错误率的应用场合下，Bloom Filter 通过极少的错误换取了存储空间的极大节省**。

  Bloom Fliter 是 Bit-map 思想的一种扩展，它可以在允许低错误率的场景下，大大地进行空间压缩，是一种**拿错误率换取空间**的数据结构。

## 3. Refer Links

https://www.cnblogs.com/maybe2030/p/4734873.html