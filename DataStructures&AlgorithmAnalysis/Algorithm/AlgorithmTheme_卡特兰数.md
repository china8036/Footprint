- [算法：明安图 - 卡特兰数问题](#%E7%AE%97%E6%B3%95%EF%BC%9A%E6%98%8E%E5%AE%89%E5%9B%BE---%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E9%97%AE%E9%A2%98)
  - [1. 基本定义](#1-%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89)
  - [2. C++ 实现](#2-c-%E5%AE%9E%E7%8E%B0)
  - [3. 应用](#3-%E5%BA%94%E7%94%A8)
    - [3.1. 出栈次序问题](#31-%E5%87%BA%E6%A0%88%E6%AC%A1%E5%BA%8F%E9%97%AE%E9%A2%98)
      - [3.1.1. 铁路站问题](#311-%E9%93%81%E8%B7%AF%E7%AB%99%E9%97%AE%E9%A2%98)
      - [3.1.2. 排队问题](#312-%E6%8E%92%E9%98%9F%E9%97%AE%E9%A2%98)
      - [3.1.3. 括号化问题](#313-%E6%8B%AC%E5%8F%B7%E5%8C%96%E9%97%AE%E9%A2%98)
      - [3.1.4. 买票找零问题](#314-%E4%B9%B0%E7%A5%A8%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98)
    - [3.2. 凸多边形三角划分问题](#32-%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98)
    - [3.3. 画二叉树问题](#33-%E7%94%BB%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98)
  - [4. Refer Links](#4-refer-links)

# 算法：明安图 - 卡特兰数问题

## 1. 基本定义

卡塔兰数的一般项公式为：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/4ef9577e015d1e57f3fb9c51804f40ff.jpg)

另一个通项式为（由此式易知卡特兰数都是自然数）：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/ee08febc6bc88a8604d6e6369bb80d5f.jpg)

- 前 20 项
  ```  
  1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190。
  ```

- 递推公式

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/4e8d5eceaaaf8108198eff11076deb3d.jpg)

- 递归公式
  ```
  h(n) = h(1)*h(n-1) + h(2)*h(n-2) + …… + h(n-1)*h(1)（其中 n>=2，h(1) = 1）
  ```
  另类递归式：  h(n)=((4*n-2)/(n+1))*h(n-1);

  即：
  ```
  F(1) = F(0)*F(1-1) = 1； 
  F(2) = F(0)*F(2-1) + F(1)*F(2-2) = 1 + 1 = 2； 
  F(3) = F(0)*F(3-1) + F(1)*F(3-2) + F(2)*F(3-3) = 2 + 1 + 2 = 5； 
  F(4) = F(0)*F(4-1) + F(1)*F(4-2) + F(2)*F(4-3) + F(3)*F(4-4)= 5 + 4 + 4 + 5 = 14； 
  ```
  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/22/cedb78c00729da3a80b02c55576c7fa7.jpg)

- 性质
  - 所有的奇卡塔兰数 Cn 都满足 n=2^k-1。
  - 所有其他的卡塔兰数都是偶数。

## 2. C++ 实现

TODO: 用 c++ 求出第 n 个卡特兰数

## 3. 应用

卡特兰数的应用实质上却都一样，无非是递归等式的应用，就看你能不能分解问题写出递归式了。

### 3.1. 出栈次序问题

描述：
- 一个栈（无穷大）的进栈序列为 1,2,3,..n, 有多少个不同的出栈序列？
- 给定一个入栈序列，求所有可能的出栈序列。

解析：那么对于一个给定入栈序列，怎么求它的出栈序列呢？

我们可以把入栈记为 1，出栈记为 0。那么前缀子序列中 1 的个数必须大于等于 0 的个数，即入栈次数要大于等于出栈次数，如 1 1 0 1 0 0，它的任意前缀序列中 1 的个数是大于等于 0 的个数的。

我们来看个例子：对于 1 2 3 这个入栈序列，1 1 0 1 0 0 就是一个入栈出栈序列，第一个 1 代表元素 1 入栈，然后第二个 1 代表元素 2 入栈，然后第三个是 0，代表出栈，即元素 2 出栈，然后第四个是 1，代表元素 3 入栈，然后第五个是 0，代表出栈，即元素 3 出栈，然后第六个是 0，代表元素 1 出栈。最后 1 1 0 1 0 0 就代表了出栈序列 2 3 1。

将出栈次序问题具体化又有了以下几种实际问题。

#### 3.1.1. 铁路站问题

铁路进行列车调度时，常把站台设计成栈式结构的站台，列车从右边进站，从左边出站。问：设有编号为 1,2,3,4,5,6 的六辆列车，顺序依次开入栈式结构的站台，则可能的出栈序列有多少种？若有编号为 1,2,3……n 的 n 辆列车，可能的出栈序列有多少种？分别具体列出各个序列。

#### 3.1.2. 排队问题

在图书馆一共 6 个人在排队，3 个还《面试宝典》一书，3 个在借《面试宝典》一书，图书馆此时没有了面试宝典了，求他们排队的总数？

解析：C3=5；所以总数为 5*3！*3！=180

#### 3.1.3. 括号化问题

P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？并具体输出各种方案。

解析：

问题可转换为：给定括号对数，输出所有符合要求的序列。如，2 对括号，输出有 ()() 或者 (()) 两种。
```cpp
#include <iostream>
#include <vector>
using namespace std;

int sum = 0;
void func(vector<char>kind, int count[], int n) {
    if(count[0] >= 1) {
        kind.push_back('(');
        count[0]--;
        func(kind, count, n);
        count[0]++;
        kind.pop_back();
    }
    if((count[1] >= 1) && (count[1] > count[0])) {
        kind.push_back(')');
        count[1]--;
        func(kind, count, n);
        count[1]++;
        kind.pop_back();
    }
    if(kind.size() == 2 * n) {
        for(vector<char>::iterator iter = kind.begin(); iter != kind.end(); iter++) cout<<(*iter)<<" ";
        cout<<endl;
		sum++;
    }
}

int main() {
    int n;
    cout << "please input the number of ():" << endl;
    cin >> n;
    int count[2]={n-1, n};
    vector<char>kind;
    kind.push_back('(');
    func(kind, count, n);
    cout<<”Total: ”<<sum<<endl;
    return 0;
}
```
count[0] 存着左括号数目，count[1] 存着右括号数目。一开始 kind 中压入左括号，因为第一个肯定是左括号。然后 count 数组初始化为 n-1 个左括号，n 个右括号。然后我们递归的处理。

如果剩余左括号数 count[0] 大于 0，就可以把左括号压栈。而对于右括号，栈中左括号个数必须多于右括号个数，也就是剩余右括号个数大于左括号个数，count[1]>count[0] 时，才能将右括号压栈。如果栈中元素个数达到 2n 时，就把栈中元素输出。

利用递归，隐式的使用栈（即使用了“函数调用栈”），每次调用函数并执行代码时入栈，每次返回函数返回值或调用地址（void）时出栈，每次出栈时通过 pop 又还原了序列，从而遍历了所有可能的情况。

#### 3.1.4. 买票找零问题

有 2n 个人排成一行进入剧场。入场费 5 元。其中只有 n 个人有一张 5 元钞票，另外 n 人只有 10 元钞票，剧院无其它钞票，问有多少中方法使得只要有 10 元的人买票，售票处就有 5 元的钞票找零？（将持 5 元者到达视作将 5 元入栈，持 10 元者到达视作使栈中某 5 元出栈。）

解析：

对于这个例子，剧院要想总有零钱可找，那么目前进入剧院的人数中，揣着 10 元钞票的人数必须少于等于揣着 5 元钞票的，不然肯定在某个人那出现没零钱找的情况。

- 类似问题：

  16 个人按顺序去买烧饼，其中 8 个人每人身上只有一张 5 块钱，另外 8 个人每人身上只有一张 10 块钱。烧饼 5 块一个，开始时烧饼店老板身上没有钱。16 个顾客互相不通气，每人只买一个。问这 16 个人共有多少种排列方法能避免找不开钱的情况出现。

  解析：C8=1430，所以`总数 = 1430 * 8! * 8!`。

### 3.2. 凸多边形三角划分问题

将一个凸 N+2 多边形区域分成三角形区域的方法数？

- 类似问题：

  一位大城市的律师在她住所以北 n 个街区和以东 n 个街区处工作。每天她走 2n 个街区去上班。如果她从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？

- 类似问题：

  在圆上选择 2n 个点，将这些点成对连接起来使得所得到的 n 条线段不相交的方法数？

### 3.3. 画二叉树问题

给定 N 个节点，能构成多少种形状不同的二叉树？

解析：一定是二叉树！先去一个点作为顶点，然后左边依次可以取 0 至 N-1 个相对应的，右边是 N-1 到 0 个，两两配对相乘，就是 h(0)*h(n-1) + h(2)*h(n-2) +  + h(n-1)h(0)=h(n) ，能构成 h（N）个。

## 4. Refer Links

https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0

http://baike.baidu.com/view/2499752.htm

http://blog.csdn.net/jtlyuan/article/details/7440591

http://blog.csdn.net/zz198808/article/details/7585385