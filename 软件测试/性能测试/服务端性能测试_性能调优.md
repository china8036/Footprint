- [服务端性能测试：性能调优](#服务端性能测试性能调优)
	- [1. 算法调优](#1-算法调优)
	- [2. 代码调优](#2-代码调优)
	- [3. 网络调优](#3-网络调优)
		- [3.1. TCP 调优](#31-tcp-调优)
		- [3.2. UDP 调优](#32-udp-调优)
		- [3.3. 网卡调优](#33-网卡调优)
		- [3.4. 其它网络性能](#34-其它网络性能)
	- [4. 系统调优](#4-系统调优)
		- [4.1. I/O 模型](#41-io-模型)
		- [4.2. 多核 CPU 调优](#42-多核-cpu-调优)
		- [4.3. 文件系统调优](#43-文件系统调优)
		- [4.4. 数据库调优](#44-数据库调优)
	- [5. Refer Links](#5-refer-links)

# 服务端性能测试：性能调优

一般来说，性能优化也就是下面的几个策略：
- **用空间换时间。**各种 cache 如 CPU L1/L2/RAM 到硬盘，都是用空间来换时间的策略。这样策略基本上是把计算的过程一步一步的保存或缓存下来，这样就不用每次用的时候都要再计算一遍，比如数据缓冲，CDN，等。这样的策略还表现为冗余数据，比如数据镜象，负载均衡什么的。

- **用时间换空间。**有时候，少量的空间可能性能会更好，比如网络传输，如果有一些压缩数据的算法（如前些天说的“Huffman 编码压缩算法” 和 “rsync 的核心算法”），这样的算法其实很耗时，但是因为瓶颈在网络传输，所以用时间来换空间反而能省时间。

- **简化代码。**最高效的程序就是不执行任何代码的程序，所以，代码越少性能就越高。关于代码级优化的技术大学里的教科书有很多示例了。如：减少循环的层数，减少递归，在循环中少声明变量，少做分配和释放内存的操作，尽量把循环体内的表达式抽到循环外，条件表达的中的多个条件判断的次序，尽量在程序启动时把一些东西准备好，注意函数调用的开销（栈上开销），注意面向对象语言中临时对象的开销，小心使用异常（不要用异常来检查一些可接受可忽略并经常发生的错误），…… 等等，等等，这连东西需要我们非常了解编程语言和常用的库。

- **并行处理。**如果 CPU 只有一个核，你要玩多进程，多线程，对于计算密集型的软件会反而更慢（因为操作系统调度和切换开销很大），CPU 的核多了才能真正体现出多进程多线程的优势。并行处理需要我们的程序有 Scalability，不能水平或垂直扩展的程序无法进行并行处理。从架构上来说，这表再为——是否可以做到不改代码只是加加机器就可以完成性能提升？

总之，根据 2：8 原则来说，20% 的代码耗了你 80% 的性能，找到那 20% 的代码，你就可以优化那 80% 的性能。 

## 1. 算法调优

一个是过滤算法，系统需要对收到的请求做过滤，我们把可以被 filter in/out 的东西配置在了一个文件中，原有的过滤算法是遍历过滤配置，后来，我们找到了一种方法可以对这个过滤配置进行排序，这样就可以用二分折半的方法来过滤，系统性能增加了 50%。

一个是哈希算法。计算哈希算法的函数并不高效，一方面是计算太费时，另一方面是碰撞太高，碰撞高了就跟单向链表一个性能（可参看 Hash Collision DoS 问题）。我们知道，算法都是和需要处理的数据很有关系的，就算是被大家所嘲笑的“冒泡排序”在某些情况下（大多数数据是排好序的）其效率会高于所有的排序算法。哈希算法也一样，广为人知的哈希算法都是用英文字典做测试，但是我们的业务在数据有其特殊性，所以，对于还需要根据自己的数据来挑选适合的哈希算法。对于我以前的一个项目，公司内某牛人给我发来了一个哈希算法，结果让我们的系统性能上升了 150%。（关于各种哈希算法，你一定要看看 StackExchange 上的这篇关于各种 hash 算法的文章 ）

分而治之和预处理。以前有一个程序为了生成月报表，每次都需要计算很长的时间，有时候需要花将近一整天的时间。于是我们把我们找到了一种方法可以把这个算法发成增量式的，也就是说我每天都把当天的数据计算好了后和前一天的报表合并，这样可以大大的节省计算时间，每天的数据计算量只需要 20 分钟，但是如果我要算整个月的，系统则需要 10 个小时以上（SQL 语句在大数据量面前性能成级数性下降）。这种分而治之的思路在大数据面前对性能有很帮助，就像 merge 排序一样。SQL 语句和数据库的性能优化也是这一策略，如：使用嵌套式的 Select 而不是笛卡尔积的 Select，使用视图，等等。

## 2. 代码调优

- **字符串操作。**这是最费系统性能的事了，无论是 strcpy, strcat 还是 strlen，最需要注意的是字符串子串匹配。所以，能用整型最好用整型。举几个例子，第一个例子是 N 年前做银行的时候，我的同事喜欢把日期存成字符串（如：2012-05-29 08:30:02），我勒个去，一个 select  where between 语句相当耗时。另一个例子是，我以前有个同事把一些状态码用字符串来处理，他的理由是，这样可以在界面上直接显示，后来性能调优的时候，我把这些状态码全改成整型，然后用位操作查状态，因为有一个每秒钟被调用了 150K 次的函数里面有三处需要检查状态，经过改善以后，整个系统的性能上升了 30% 左右。还有一个例子是，我以前从事的某个产品编程规范中有一条是要在每个函数中把函数名定义出来，如：const char fname[]=”functionName()”, 这是为了好打日志，但是为什么不声明成 static 类型的呢？

- **多线程调优。**有人说，thread is evil，这个对于系统性能在某些时候是个问题。因为多线程瓶颈就在于互斥和同步的锁上，以及线程上下文切换的成本，怎么样的少用锁或不用锁是根本（比如：多版本并发控制 (MVCC) 在分布式系统中的应用 中说的乐观锁可以解决性能问题），此外，还有读写锁也可以解决大多数是读操作的并发的性能问题。这里多说一点在 C++ 中，我们可能会使用线程安全的智能指针 AutoPtr 或是别的一些容器，只要是线程安全的，其不管三七二十一都要上锁，上锁是个成本很高的操作，使用 AutoPtr 会让我们的系统性能下降得很快，如果你可以保证不会有线程并发问题，那么你应该不要用 AutoPtr。我记得我上次我们同事去掉智能指针的引用计数，让系统性能提升了 50% 以上。对于 Java 对象的引用计数，如果我猜的没错的话，到处都是锁，所以，Java 的性能问题一直是个问题。另外，线程不是越多越好，线程间的调度和上下文切换也是很夸张的事，尽可能的在一个线程里干，尽可能的不要同步线程。这会让你有很多的性能。

- **内存分配。**不要小看程序的内存分配。malloc/realloc/calloc 这样的系统调非常耗时，尤其是当内存出现碎片的时候。我以前的公司出过这样一个问题——在用户的站点上，我们的程序有一天不响应了，用 GDB 跟进去一看，系统 hang 在了 malloc 操作上，20 秒都没有返回，重启一些系统就好了。这就是内存碎片的问题。这就是为什么很多人抱怨 STL 有严重的内存碎片的问题，因为太多的小内存的分配释放了。有很多人会以为用内存池可以解决这个问题，但是实际上他们只是重新发明了 Runtime-C 或操作系统的内存管理机制，完全于事无补。当然解决内存碎片的问题还是通过内存池，具体来说是一系列不同尺寸的内存池（这个留给大家自己去思考）。当然，少进行动态内存分配是最好的。说到内存池就需要说一下池化技术。比如线程池，连接池等。池化技术对于一些短作业来说（如 http 服务） 相当相当的有效。这项技术可以减少链接建立，线程创建的开销，从而提高性能。

- **异步操作。**我们知道 Unix 下的文件操作是有 block 和 non-block 的方式的，像有些系统调用也是 block 式的，如：Socket 下的 select，Windows 下的 WaitforObject 之类的，如果我们的程序是同步操作，那么会非常影响性能，我们可以改成异步的，但是改成异步的方式会让你的程序变复杂。异步方式一般要通过队列，要注间队列的性能问题，另外，异步下的状态通知通常是个问题，比如消息事件通知方式，有 callback 方式，等，这些方式同样可能会影响你的性能。但是通常来说，异步操作会让性能的吞吐率有很大提升（Throughput），但是会牺牲系统的响应时间（latency）。这需要业务上支持。

- **语言和代码库。**我们要熟悉语言以及所使用的函数库或类库的性能。比如：STL 中的很多容器分配了内存后，那怕你删除元素，内存也不会回收，其会造成内存泄露的假像，并可能造成内存碎片问题。再如，STL 某些容器的 size()==0  和 empty() 是不一样的，因为，size() 是 O(n) 复杂度，empty() 是 O(1) 的复杂度，这个要小心。Java 中的 JVM 调优需要使用的这些参数：-Xms -Xmx -Xmn -XX:SurvivorRatio -XX:MaxTenuringThreshold，还需要注意 JVM 的 GC，GC 的霸气大家都知道，尤其是 full GC（还整理内存碎片），他就像“恐龙特级克赛号”一样，他运行的时候，整个世界的时间都停止了。

## 3. 网络调优

关于网络调优，尤其是 TCP Tuning（你可以以这两个关键词在网上找到很多文章），这里面有很多很多东西可以说。看看 Linux 下 TCP/IP 的那么多参数就知道了。

### 3.1. TCP 调优

### 3.2. UDP 调优

### 3.3. 网卡调优

### 3.4. 其它网络性能

## 4. 系统调优

### 4.1. I/O 模型

### 4.2. 多核 CPU 调优

### 4.3. 文件系统调优

### 4.4. 数据库调优

## 5. Refer Links

TODO:

[coolshell 代码优化概要](https://coolshell.cn/articles/2967.html)

[coolshell 性能测试应该怎么做？](https://coolshell.cn/articles/17381.html)

[coolshell 性能调优攻略](https://coolshell.cn/articles/7490.html)