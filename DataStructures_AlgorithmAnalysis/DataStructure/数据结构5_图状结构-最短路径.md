- [数据结构：图结构 - 最短路径](#数据结构图结构---最短路径)
	- [1. 单源最短路径算法](#1-单源最短路径算法)
		- [1.1. Dijkstra 算法](#11-dijkstra-算法)
			- [1.1.1. 基本思路](#111-基本思路)
			- [1.1.2. 代码实现](#112-代码实现)
		- [1.2. Bellman-Ford](#12-bellman-ford)
		- [1.3. BFS](#13-bfs)
			- [1.3.1. 单向 BFS](#131-单向-bfs)
			- [1.3.2. 双向 BFS](#132-双向-bfs)
			- [1.3.3. 多源 BFS](#133-多源-bfs)
	- [2. 多源最短路径算法：Floyded-warshall](#2-多源最短路径算法floyded-warshall)
	- [3. SPFA](#3-spfa)
	- [4. A*](#4-a)
	- [5. D*](#5-d)
	- [6. KD-Tree](#6-kd-tree)
	- [7. Refer Links](#7-refer-links)

# 数据结构：图结构 - 最短路径

最短路径算法是图论中的基本算法之一。

根据路径出发点是否单一，可分为：
- 单源最短路径算法
- 多源最短路径算法

根据路径是否带权值，可分为：
- 网图最短路径算法
- 非网图最短路径算法

## 1. 单源最短路径算法

单源最短路径问题为：对于有向图 G 中的源顶点 a，求出它到图中其他任意顶点的最短路径。

### 1.1. Dijkstra 算法

#### 1.1.1. 基本思路

利用 Dijkstra 发明的贪婪算法可求解单源最短路径问题，算法思想是：按路径长度递增的次序产生最短路径，**采用的贪婪准则是：在未产生最短路径的顶点中，选择路径长度最短的目的顶点**。它通过分步方法求出最短路径，每一步产生一个到达新的目的顶点的最短路径，即它是按照路径长度顺序产生最短路径的。

**Dijkstra 算法使用的前提是：图中不能有负权边。**

例：

![image](http://img.cdn.firejq.com/jpg/2018/2/25/348e53b7dffff08a261014190e3fb394.jpg)

以下是求解过程：
- 阶段 Ⅰ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | ∞    | ∞    | ∞    | ∞    | ∞    |
  | P    | 0    | -1   | -1   | -1   | -1   | -1   |
  | F    | 1    | 0    | 0    | 0    | 0    | 0    |

  初始化表，此时确认了从 0 到 0 的最短路。

  表中：
  - d(distance) 表示从出发点 0 到该点的距离。
  - P(Path) 记录从出发点 0 走到该点的路径上的上一个点。
  - F(Final) 记录是否已确认为最短路径（0 或 1）。

- 阶段 Ⅱ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 60   | ∞    | 10   | 65   |
  | P    | 0    | 0    | 0    | -1   | 0    | 0    |
  | F    | 1    | 0    | 0    | 0    | 1    | 0    |

  从 0 出发可到达 1、2、5、4，到 1 的 d=20<∞，故更新表中的 d 值，并将 P 值改为 0（从 0 来的）；2、5、4 同理。

  在 F=0 的所有点中，选择 d 最小的点，并将该点设为下一阶段的出发点。被选到的点即可将 F 值改为 1，此处选择 4。

- 阶段 Ⅲ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 60   | ∞    | 10   | 30   |
  | P    | 0    | 0    | 0    | -1   | 0    | 4    |
  | F    | 1    | 1    | 0    | 0    | 1    | 0    |

  从 4 出发，可到 5，d=d4+20=30<65，故更新 d5，并将 P5 改为 4。

  在 F=0 的所有点中选择了 d 最小的为 d1=20，作为下一阶段出发点，并将 F1 改为 1。

- 阶段 Ⅳ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 50   | 90   | 10   | 30   |
  | P    | 0    | 0    | 1    | 1    | 0    | 4    |
  | F    | 1    | 1    | 0    | 0    | 1    | 1    |

- 阶段 Ⅴ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 45   | 90   | 10   | 30   |
  | P    | 0    | 0    | 5    | 1    | 0    | 4    |
  | F    | 1    | 1    | 1    | 0    | 1    | 1    |

- 阶段 Ⅵ

  |      | 0    | 1    | 2    | 3    | 4    | 5    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | d    | 0    | 20   | 45   | 85   | 10   | 30   |
  | P    | 0    | 0    | 5    | 2    | 0    | 4    |
  | F    | 1    | 1    | 1    | 1    | 1    | 1    |

  直至所有点的 F 值为 1，算法流程结束。

- 最后结果

  |           | 最短距离 | 路径              |
  | ----      | ------- | ----------------- |
  | 从 0 到 0 | 0       | 0                 |
  | 从 0 到 1 | 29      | 0 → 1             |
  | 从 0 到 2 | 45      | 0 → 4 → 5 → 2     |
  | 从 0 到 3 | 85      | 0 → 4 → 5 → 2 → 3 |
  | 从 0 到 4 | 10      | 0 → 4             |
  | 从 0 到 5 | 30      | 0 → 4 → 5         |

#### 1.1.2. 代码实现

**使用最小索引堆进行优化**后，**算法的时间复杂度为 O(ElogV)**。
```cpp
// Dijkstra 算法求最短路径
template<typename Graph, typename Weight>
class Dijkstra{

private:
    Graph &G;                   // 图的引用
    int s;                      // 起始点
    Weight *distTo;             // distTo[i] 存储从起始点 s 到 i 的最短路径长度
    bool *marked;               // 标记数组，在算法运行过程中标记节点 i 是否被访问
    vector<Edge<Weight>*> from; // from[i] 记录最短路径中，到达 i 点的边是哪一条，可以用来恢复整个最短路径

public:
    // 构造函数，使用 Dijkstra 算法求最短路径
    Dijkstra(Graph &graph, int s):G(graph){

        // 算法初始化
        assert( s >= 0 && s < G.V() );
        this->s = s;
        distTo = new Weight[G.V()];
        marked = new bool[G.V()];
        for( int i = 0 ; i < G.V() ; i ++ ){
            distTo[i] = Weight();
            marked[i] = false;
            from.push_back(NULL);
        }

        // 使用索引堆记录当前找到的到达每个顶点的最短距离
        IndexMinHeap<Weight> ipq(G.V());

        // 对于其实点 s 进行初始化
        distTo[s] = Weight();
        from[s] = new Edge<Weight>(s, s, 0);
        ipq.insert(s, distTo[s] );
        marked[s] = true;
        while( !ipq.isEmpty() ){
            int v = ipq.extractMinIndex();

            // distTo[v] 就是 s 到 v 的最短距离
            marked[v] = true;

            // 对 v 的所有相邻节点进行更新
            typename Graph::adjIterator adj(G, v);
            for( Edge<Weight>* e = adj.begin() ; !adj.end() ; e = adj.next() ){
                int w = e->other(v);
                // 如果从 s 点到 w 点的最短路径还没有找到
                if( !marked[w] ){
                    // 如果 w 点以前没有访问过，
                    // 或者访问过，但是通过当前的 v 点到 w 点距离更短，则进行更新
                    if( from[w] == NULL || distTo[v] + e->wt() < distTo[w] ){
                        distTo[w] = distTo[v] + e->wt();
                        from[w] = e;
                        if( ipq.contain(w) )
                            ipq.change(w, distTo[w] );
                        else
                            ipq.insert(w, distTo[w] );
                    }
                }
            }
        }
    }

    // 析构函数
    ~Dijkstra(){
        delete[] distTo;
        delete[] marked;
        delete from[0];
    }

    // 返回从 s 点到 w 点的最短路径长度
    Weight shortestPathTo( int w ){
        assert( w >= 0 && w < G.V() );
        assert( hasPathTo(w) );
        return distTo[w];
    }

    // 判断从 s 点到 w 点是否联通
    bool hasPathTo( int w ){
        assert( w >= 0 && w < G.V() );
        return marked[w];
    }

    // 寻找从 s 到 w 的最短路径，将整个路径经过的边存放在 vec 中
    void shortestPath( int w, vector<Edge<Weight>> &vec ){

        assert( w >= 0 && w < G.V() );
        assert( hasPathTo(w) );

        // 通过 from 数组逆向查找到从 s 到 w 的路径，存放到栈中
        stack<Edge<Weight>*> s;
        Edge<Weight> *e = from[w];
        while( e->v() != this->s ){
            s.push(e);
            e = from[e->v()];
        }
        s.push(e);

        // 从栈中依次取出元素，获得顺序的从 s 到 w 的路径
        while( !s.empty() ){
            e = s.top();
            vec.push_back( *e );
            s.pop();
        }
    }

    // 打印出从 s 点到 w 点的路径
    void showPath(int w){

        assert( w >= 0 && w < G.V() );
        assert( hasPathTo(w) );

        vector<Edge<Weight>> vec;
        shortestPath(w, vec);
        for( int i = 0 ; i < vec.size() ; i ++ ){
            cout<<vec[i].v()<<" -> ";
            if( i == vec.size()-1 )
                cout<<vec[i].w()<<endl;
        }
    }
};
```

### 1.2. Bellman-Ford

当图中含有负权边时，可使用 Bellman-Ford 算法来求解单源最短路径问题。

Bellman-Ford 算法使用的前提是：图中不能有负权环。因为对于拥有负权环的图，没有最短路径。当图中含有负权环时，Bellman-Ford 算法无法找出最短路径，但却能检测出图中是否含有负权环。

Bellman-Ford 算法的时间复杂度为 0(EV)。

### 1.3. BFS

#### 1.3.1. 单向 BFS

当要求得一个图中**从某个顶点出发到所有其它顶点**的最短路径，可直接使用普通的 BFS（单向 BFS）进行求解。

#### 1.3.2. 双向 BFS

当要求得一个图中**从某个顶点出发到另一个顶点**的最短路径，则可使用双向 BFS 进行求解。从两个目标点同时开始 BFS，因此我们会有两个不同的队列。**每次更新较小的那个队列，直到两个队列中有元素重合，说明最短路径找到**。

#### 1.3.3. 多源 BFS

多源 BFS，就是将多个 source 同时推入 queue 中，然后开始 BFS。

## 2. 多源最短路径算法：Floyded-warshall

Floyded-warshall 算法可用于处理无负权环的图，其时间复杂度为 O(V^3)。

## 3. SPFA

## 4. A*

## 5. D*

## 6. KD-Tree

## 7. Refer Links

https://www.cnblogs.com/hxsyl/p/3270401.html

http://m.blog.csdn.net/article/details?id=6181485

http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html

http://www.tudou.com/programs/view/4JBYJVeD6t0

http://v.youku.com/v_show/id_XOTM1OTcxODU2.html

http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html

https://blog.csdn.net/chengonghao/article/details/52347050

[刷题笔记 7（不一样的 BFS）](https://zhuanlan.zhihu.com/p/26487841)