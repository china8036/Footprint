- [数据结构：Bitmap](#bitmap)
  - [1. 基本概念](#1)
  - [2. 应用](#2)
    - [2.1. 排序](#21)
    - [2.2. 大量数据的去重](#22)
    - [2.3. 大量数据的查询](#23)
  - [3. Bloom Filter](#3-bloom-filter)
    - [3.1. 基本原理](#31)
    - [3.2. 缺点](#32)
    - [3.3. 扩展](#33)
    - [3.4. 适用场景](#34)
  - [4. Refer Links](#4-refer-links)
  
# 数据结构：Bitmap & Bloom Filter

## 1. 基本概念

所谓的 Bit-map 就是用一个 bit 位来标记某个元素对应的 Value，而 Key 即是该元素。由于采用了 Bit 为单位来存储数据，可以大大节省存储空间。

32 位机器上，对于一个整型数，比如 int a=1 在内存中占 32bit 位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费，因为我们可以用对应的 32bit 位对应存储十进制的 0-31 个数，而这就是 Bit-map 的基本思想。

## 2. 应用

Bit-map 算法利用这种思想可以将存储空间进行压缩，以处理大量数据的排序、查询以及去重。

NOTE: 使用 Bit-map 前要获取这个序列的最大值来作为空间分配的依据，时间复杂度为 O(n)。

### 2.1. 排序

- 要求：

  对 5 个元素 (4,7,2,5,3) 排序（这些元素没有重复）。

- 解析：

  可以看到元素的取值范围是 0-7，那么我们就可以采用 Bit-map 的方法来达到排序的目的。

  要表示 8 个数，我们就只需要 8 个 Bit（1Bytes），首先我们开辟 1Byte 的空间，将这些空间的所有 Bit 位都置为 0：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/526c4ad96b074b1cee644a5fe00b4a59.jpg)

  然后遍历这 5 个元素：
  - 首先第一个元素是 4，那么就把 4 对应的位置为 1（可以这样操作 p+(i/8)|(0x01<<(i%8)) ，因为是从零开始的，所以要把第五位置为一；
  - 然后再处理第二个元素 7，将第八位置为 1；
  - 一直到最后处理完所有的元素，将相应的位置为 1。
  这时候的内存的 Bit 位的状态如下： 

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/b18722cbdd02b869a689a97a2316f1a7.jpg)

  然后我们现在遍历一遍 Bit 区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度 O(n)。实际上，这也就是桶排序的基本思想。

- 优点：
  - 运算效率高，不需要进行比较和移位。
  - 占用内存少。比如 N=10000000（一千万），只需占用内存为 N/8=1250000Byte=1.25M。

- 缺点：
  - 所有的数据不能重复，即无法对重复的数据进行排序和查找。    

### 2.2. 大量数据的去重

- 要求：

  在 2.5 亿个整数中找出**不重复的整数的个数**，已知内存空间不足以容纳这 2.5 亿个整数。 

- 解析：

  首先，根据“内存空间不足以容纳这 2.5 亿个整数”我们可以快速的联想到 Bit-map，下边关键的问题就是怎么设计我们的 Bit-map 来表示这 2.5 亿个数字的状态了。

  **一个数字的状态只有三种，分别为不存在 / 只有一个 / 有重复。因此，我们只需要 2bits 就可以对一个数字的状态进行存储了，假设我们设定一个数字不存在为 00，存在一次 01，存在两次及其以上为 11**。那我们大概需要存储空间：
  ```
  2.5 * 10^8 * 2 bits = 5 * 10^8 bits = 62.5 * 10^6 bytes = 62.5 M
  ```
  接下来的任务就是遍历一次这 2.5 亿个数字，如果对应的状态位为 00，则将其变为 01；如果对应的状态位为 01，则将其变为 11；如果为 11, 对应的状态位保持不变。

  最后，我们对状态位为 01 的数字进行统计，就得到了不重复的数字个数，**时间复杂度为 O(n)**。

### 2.3. 大量数据的查询

- 要求：

  现有 2.5 亿个整数，如何快速判断一个数字是够存在于上述的 2.5 亿个数字集合中，已知内存空间不足以容纳这 2.5 亿个整数。 

- 解析：

  **这种情况下对于一个数字只需要一个 bit 位就可以了，0 表示不存在，1 表示存在。**

  首先我们先对所有的数字进行一次遍历，然后将相应的转态位改为 1。

  遍历完以后就是查询，由于我们的 Bit-map 采取的是连续存储（整型数组形式，一个数组元素对应 32bits），我们实际上是采用了一种分桶的思想。**一个 int 类型的数组元素可以存储 32 个状态位，那将待查询的数字除以 32，定位到对应的数组元素（桶），然后再求余（%32），就可以定位到相应的状态位**。如果为 1，则代表该数字存在；否则，该数字不存在。

## 3. Bloom Filter

Bloom Fliter 是 Bit-map 思想的一种扩展，它利用**位数组**很简洁地表示一个集合，并能判断一个元素是否属于这个集合。

但 Bloom Filter 的这种高效是有一定代价的，它是一种**拿错误率换取空间**的数据结构。在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。

### 3.1. 基本原理

**Bloom filter 提供两种基本的操作，将元素加入集合和判断某一元素是否属于该集合**。

- 初始状态时，Bloom Filter 包含 m 位的位数组（其中每一位都置为 0）和 k 个相互独立的哈希函数。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/29/a6361d552c0a05960dfeea714f0e9e60.jpg)

- 将元素加入集合。

  将一个元素加入集合时，首先将要加入集合的元素用 k 个 hash 函数进行 hash，得到 k 个 hash index，然后在集合的位数组中将这 k 个 hash index 的位置置 1。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/29/e7a773b893102f88c139e64dfb02c69d.jpg)

  NOTE：**如果一个位置多次被置为 1，那么只有第一次会起作用，后面几次将没有任何效果**。

- 判断某一元素是否属于该集合。

  首先同样用定义的 hash 函数对该元素进行 hash 得到 hash index，然后查位数组中对应的 hash index 是否都是 1，如果是，则表明该元素属于该集合，反之不属于。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/29/9cf0f5b3ad1bad503e1aa2b912c969cc.jpg)  

  如上图，由于 y1 的三个 hash index 有一个不为 1，因此不属于该集合，而 y2 所有的 hash index 的位置上都为 1，因此属于该集合。

- 如何根据输入元素个数 n，确定位数组 m 的大小及 hash 函数个数 k？
  <!-- todo: -->
  当 hash 函数个数`k=(ln2)*(m/n)`时错误率最小。在错误率不大于 E 的情况 下，m 至少要等于`n*lg(1/E)`才能表示任意 n 个元素的集合。

  但 m 还应该更大些，因为还要保证 bit 数组里至少一半为 0，则 m 应 该`>=nlg(1/E)*lge` 大概就是 nlg(1/E)1.44 倍 (lg 表示以 2 为底的对数)。

  例：假设要求错误率为 0.01，则此时 m 应大概是 n 的 13 倍，k 大概是 8 个。

  注意这里 m 与 n 的单位不同，m 是 bit 为单位，而 n 则是以元素个数为单位（准确的说是不同元素的个数)。通常单个元素的长度都是有很多 bit 的，所以使用 bloom filter 内存上通常都是节省的。

### 3.2. 缺点

- 存在错误。

  很明显可以看出，Bloom Filter 的查找过程并不保证查找的结果是 100% 正确的。

- 不支持删除。

  Bloom Filter 不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个 counter 数组代替位数组，就可以支持删除了。

### 3.3. 扩展

Bloom filter 将集合中的元素映射到位数组中，用 k（k 为哈希函数个数）个映射位是否全 1 表示元素在不在这个集合中。

- Counting bloom filter（CBF）将位数组中的每一位扩展为一个 counter，从而支持了元素的删除操作。
- Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF 采用 counter 中的最小值来近似表示元素的出现频率。

### 3.4. 适用场景

Bloom Filter 不适合那些“零错误”的应用场合，而**在能容忍低错误率的应用场合下，Bloom Filter 通过极少的错误换取了存储空间的极大节省**。

Bloom Filter 一般可以用来实现数据字典，进行数据的判重，或者集合求交集。

- 给你 A,B 两个文件，各存放 50 亿条 URL，每条 URL 占用 64 字节，内存限制是 4G，让你找出 A,B 文件共同的 URL。如果是三个乃至 n 个文件呢？

  根据这个问题我们来计算下内存的占用，4G=2^32 大概是 40 亿*8 大概是 340 亿，n=50 亿，如果按出错率 0.01 算需要的大概是 650 亿个 bit。 现在可用的是 340 亿，相差并不多，这样可能会使出错率上升些。另外如果这些 url 与 ip 是一一对应的，就可以转换成 ip，则大大简单了。

## 4. Refer Links

https://www.cnblogs.com/maybe2030/p/4734873.html

http://diducoder.com/mass-data-topic-2-bloom-filter.html