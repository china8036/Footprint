- [数据结构：树结构 - 二叉树](#数据结构树结构---二叉树)
  - [1. 基本概念](#1-基本概念)
    - [1.1. 基本术语](#11-基本术语)
    - [1.2. 基本性质](#12-基本性质)
  - [2. 存储结构](#2-存储结构)
    - [2.1. 顺序存储结构](#21-顺序存储结构)
    - [2.2. 链式存储结构](#22-链式存储结构)
      - [2.2.1. 一指针式](#221-一指针式)
      - [2.2.2. 二指针式（二叉链表）](#222-二指针式二叉链表)
      - [2.2.3. 三指针式（三叉链表）](#223-三指针式三叉链表)
  - [3. 基本操作](#3-基本操作)
    - [3.1. 根据序列重建二叉树](#31-根据序列重建二叉树)
      - [3.1.1. 概念说明](#311-概念说明)
      - [3.1.2. 根据先序拓展序列创建二叉树（递归实现）](#312-根据先序拓展序列创建二叉树递归实现)
      - [3.1.3. 根据先序 + 中序 || 后序 + 中序 || 层序 + 中序 序列创建二叉树（递归实现）](#313-根据先序--中序--后序--中序--层序--中序-序列创建二叉树递归实现)
      - [3.1.4. 根据层序遍历序列创建二叉树（非递归实现）](#314-根据层序遍历序列创建二叉树非递归实现)
    - [3.2. 二叉树的遍历](#32-二叉树的遍历)
      - [3.2.1. DFS（利用栈）](#321-dfs利用栈)
        - [3.2.1.1. 先序遍历（DLR）](#3211-先序遍历dlr)
        - [3.2.1.2. 中序遍历（LDR）](#3212-中序遍历ldr)
        - [3.2.1.3. 后序遍历（LRD）](#3213-后序遍历lrd)
      - [3.2.2. BFS：层序遍历（利用队列）](#322-bfs层序遍历利用队列)
    - [3.3. 二叉树与森林的转换](#33-二叉树与森林的转换)
      - [3.3.1. 森林转换为二叉树](#331-森林转换为二叉树)
      - [3.3.2. 二叉树转换成森林](#332-二叉树转换成森林)
    - [3.4. 求二叉树的深度](#34-求二叉树的深度)
    - [3.5. 判断二叉树是否为完全二叉树](#35-判断二叉树是否为完全二叉树)
    - [3.6. 求二叉树的叶子总数](#36-求二叉树的叶子总数)
    - [3.7. 遍历所有叶子结点](#37-遍历所有叶子结点)
    - [3.8. 为二叉树复制一份副本](#38-为二叉树复制一份副本)
    - [3.9. 判断两棵树是否相等](#39-判断两棵树是否相等)
  - [4. 其它操作](#4-其它操作)
    - [4.1. 求每层的节点数，保存在数组中](#41-求每层的节点数保存在数组中)
    - [4.2. 求二叉树第 K 层的节点数和二叉树第 K 层的叶子节点数，递归方式和非递归方式](#42-求二叉树第-k-层的节点数和二叉树第-k-层的叶子节点数递归方式和非递归方式)
    - [4.3. 打印二叉树中第 K 层的第 M 个节点，非递归算法](#43-打印二叉树中第-k-层的第-m-个节点非递归算法)
    - [4.4. 比较两个二叉树是否相同（结构和数据），递归和非递归](#44-比较两个二叉树是否相同结构和数据递归和非递归)
    - [4.5. 求二叉树的镜像，递归和非递归方式](#45-求二叉树的镜像递归和非递归方式)
    - [4.6. 查找两个节点的最近公共祖先（LCA 问题）](#46-查找两个节点的最近公共祖先lca-问题)
    - [4.7. 求二叉树中任意两个节点之间的距离，递归和非递归](#47-求二叉树中任意两个节点之间的距离递归和非递归)
  - [5. Refer Links](#5-refer-links)

# 数据结构：树结构 - 二叉树

## 1. 基本概念

### 1.1. 基本术语

- 二叉树

  二叉树是树结构的一种重要类型，许多实际问题都可抽象出二叉树的数据结构，一般的树也可通过简单变换转换成二叉树。

  **一棵二叉树（binary tree）是结点的一个有限集合，该集合或者为空，或者由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成**。

  由于在定义中，我们使用二叉树来定义二叉树，因此说**二叉树具有天然的递归结构**。

- 内部结点

  > An internal vertex (or inner vertex or branch vertex) is a vertex of degree at least 2. 

  即一棵树的内部结点是除了叶子之外的节点。

- 外部结点

  > An external vertex (or outer vertex, terminal vertex or leaf) is a vertex of degree 1.

  即外部结点等同于叶子结点。

- 满二叉树

  **满二叉树（full binary tree）是指深度为 k 且有 2k–1 个结点的二叉树**。

  ![image](http://img.cdn.firejq.com/jpg/2018/2/23/31fc7a42464e9dcce328af84dc9a5443.jpg)

  如图（a）所示是深度为 4 的满二叉树，这种树的特点是，每一层上结点数都是最大结点数，即不存在度为 1 的结点。

- 完全二叉树

  **完全二叉树（completed binary tree）是指深度为 k，有 n 个结点的二叉树，除最后一层外，其余层均是满的，且最下面一层的结点都集中在最左边的位置上**。

  如图（b）所示为一棵深度为 4 的完全二叉树，而图（c）和图（d）所示都不是完全二叉树。

  **完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra 算法、Prim 算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树**。

- 完美二叉树 (Perfect Binary Tree)

  所有的非叶子结点都有两个孩子，所有的叶子结点都在同一层。即每层结点都完全填满。

- 平衡二叉树 (Balanced Binary Tree)

  最简单的平衡二叉树是 AVL 树，它是一棵空树或者：

  - 它的左右两个子树的高度差的绝对值不超过 1。
  - 左右两个子树都是一棵平衡二叉树。

**NOTE**：

- 关于满二叉树和完全二叉树的定义，国内外教材存在差异。以上的定义是国内数据结构教材的定义，但在国外经典教材 CLRS 中，full binary tree 和 completed binary tree 的定义如下：

  ![image](http://img.cdn.firejq.com/jpg/2018/2/23/d6d9f4ce427f01a3deb69552637d3c84.jpg)

  即：
  - full m-ary tree 是指所有结点的度数只有 0 或 m 的树。
  - completed m-ary tree 是指所有叶子结点的高度相同的树，即 completed m-ary tree 等同于 perfect m-ary tree。

  且 CLRS 中推出 full binary tree 和 completed binary tree 有以下性质：

  > A full m-ary tree with i internal nodes has mi + 1 nodes total.
  > 
  > A full m-ary tree with i internal nodes has m(i-1) + 1 leaves total.

  因此，有了以下容易造成疑惑的地方：

  ![image](http://img.cdn.firejq.com/jpg/2018/2/23/1b70a29f7c7df7535341a3d5374048ac.jpg)

  解释：因为如果按照国内的标准，满八叉树的 internal nodes 不可能刚好为 100（1；1+8=9；1+8+64=73；1+8+64+128=201），若按照 CLRS 中对 full tree 的定义标准，则题目没有问题。

### 1.2. 基本性质

二叉树具有下列重要特性：

- **性质 1**: 在二叉树的第 i 层上至多有 `2^(i–1)` 个结点（i≥1）。

- **性质 2**: 深度为 k 的二叉树至多有 `2^k – 1` 个结点（k≥1）。

- **性质 3**: 对任意一棵非空二叉树 T，若其叶结点数为 n0，度为 2 的结点数为 n2，则 n0 = n2 + 1。即：`叶子数 = 二度结点数 + 1`。

- **性质 4**: 具有 n 个结点的完全二叉树的深度为 `floor(log2 n) + 1`。
  
  证明：设完全二叉树的深度为 k，由它的定义和性质可知 2^(k–1)–1 < n ≤ 2^k–1 或 2^(k–l) ≤ n < 2^k，取对数后有 k-1 ≤ log2 n < k，因为 k 是整数，所以 `k = floor(log2 n) + 1`。

- **性质 5**: 如果将一棵有 n 个结点的完全二叉树（其深度为 `floor(log2 n) + 1`）自顶向下、同一层自左向右编号为 1, 2, 3,…, n，则对任意一个结点 i（1 ≤ i ≤ n）有：
  - 如果 i = 1，则此结点为二叉树的根，无双亲；如果 i > 1，则其双亲结点是 `floor(i/2)`。
  - 如果 2i > n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 `2i`。
  - 如果 2i+1 > n，则结点 i 无右孩子；否则其右孩子是结点 `2i+1`。

- **性质 6**: n 个节点的二叉树有 f(n) 种形态，f(n) = ((4n-2)/(n+1)) * f(n-1). (**Catalan Number**)

## 2. 存储结构

二叉树通常采用两种存储方式：顺序存储结构和链式存储结构。

### 2.1. 顺序存储结构

**对于完全二叉树**，可采用一组地址连续的存储单元按照**自上而下、从左至右**的顺序存储树上的结点元素，即编号为 i 的结点元素存储在一维数组的下标为 i-l 的分量中。

**对于一般二叉树**，为了使结点的存储位置能反映出结点之间的逻辑关系，应将其每个结点与完全二叉树上的结点相对应，存储在一维数组的相应分量中，以“0”表示不存在此结点。但显然，这样会造成空间的浪费。

![image](http://img.cdn.firejq.com/jpg/2018/2/23/a568cb27bd847d9ee5173940eaa3fcdc.jpg)

因此，这种顺序存储结构仅适用于完全二叉树。因为**在最坏情况下，一个深度为 k 且只有 k 个结点的单枝树（树中不存在度为 2 的结点）却需要长度为 2^k-1 的一维数组**。

### 2.2. 链式存储结构

**一般二叉树**多采用链式存储，链结点除存放与树结点有关的信息外，还可根据具体应用的需要，设置分别指向双亲结点，左、右子结点的指针。根据指针设置情况，存储方式可分为一指针式、二指针式和三指针式。

#### 2.2.1. 一指针式

该方法也称父指针式，即每个结点只设立指向双亲结点的指针。

![image](http://img.cdn.firejq.com/jpg/2018/2/23/9fa8251f428e9477c0f682dde8d7360a.jpg)

在这种存储方式下，只有从每个叶子出发，才能访问到一棵树中的每个结点。如果已知某个结点的指针，可方便地找到其双亲结点，但找它的子结点很耗时。

#### 2.2.2. 二指针式（二叉链表）

该方法为每个结点只设立指向其后继的指针，分别称为左指针和右指针。

![image](http://img.cdn.firejq.com/jpg/2018/2/23/f0976028b11a4a0f9614c240b082e2d0.jpg)

在这种存储方式下，从根出发可访问到所有结点，并已知某结点的指针，很容易找到它的子结点，但要找到它的双亲结点，则需从根结点开始搜索，很耗时。

#### 2.2.3. 三指针式（三叉链表）

该方法为每个结点分别设立指向其前驱和两个后继的三个指针。

![image](http://img.cdn.firejq.com/jpg/2018/2/23/59b8b54ef74b4458cf35b5f976c15930.jpg)

这种方式同时具有一指针式和二指针式的优点，当然是通过存储空间换来的。

## 3. 基本操作

### 3.1. 根据序列重建二叉树

https://www.oschina.net/code/snippet_217193_12485 

#### 3.1.1. 概念说明

![image](http://img.cdn.firejq.com/jpg/2018/2/23/aa6bd93b6b5180433440d413c3b9e596.jpg)

- 先序序列为：`abdec`
- 中序序列为：`bedac`
- 后序序列为：`edbca`
- 层序序列位：`abcde`
- 先序拓展序列为：`ab*de***c**` (`*`表示 NULL)

**若已知前序遍历序列 + 中序遍历序列，或后序遍历序列 + 中序遍历序列，或层序遍历序列 + 中序遍历序列，都可唯一确定一颗二叉树。**

若已知前序 + 后序，则无法确定一颗二叉树。

#### 3.1.2. 根据先序拓展序列创建二叉树（递归实现）

- 有参数版本

  http://blog.csdn.net/lilypp/article/details/6457621

  http://www.jianshu.com/p/2dfe85f61acd

  根据传入的指针去申请空间，赋地址值给传入的指针。

  ```cpp
  #include <iostream>
  using namespace std;

  template<typename T>
  struct treeNode {
    T value;
    treeNode * lchild;
    treeNode * rchild;
    treeNode(): value(), lchild(NULL), rchild(NULL) {}
  };

  template<typename T>
  class binTree {
  public:
    binTree(treeNode<T> * p = NULL) {this->root = p;}
    //~binTree();
    void preInitialTree(treeNode<T> * &t);// 根据先序扩展序列创建二叉树
    void preOrderTra(treeNode<T> * t);// 先序遍历输出二叉树
  private:
    treeNode<T> * root;
  };

  template<typename T>
  void binTree<T>::preInitialTree(treeNode<T> * &t) {
    cout<<"please input the preorder sequence, use '*' to represent null:\n";
    T in;
    cin>>in;
    if (in != '*') {
      if (!t)//root 结点已经 new 过，跳过此步
        t = new treeNode<T>();
      t->value = in;
      this->preInitialTree(t->lchild);
      this->preInitialTree(t->rchild);
    } else {
      t = NULL;
    }
  }
  // 特别注意：参数必须设置为指针类型的引用参数，因为如果只传指针，将无法操作到实际的指针值（如：t = new treeNode<char>(); 无法将新申请的内存地址赋值到真实指针变量中，只赋值给了临时变量，实际上没有任何作用）
  template<typename T>
  void binTree<T>::preOrderTra(treeNode<T> * t) {                    
    if (t) {
      cout << t->value << ' ';// 访问根结点
        preOrderTra(t->lchild); // 遍历左子树
        preOrderTra(t->rchild);// 遍历右子树
    }
  }

  int main() {
    treeNode<char> * rNode = new treeNode<char>();
    //treeNode<char> * rNode = NULL; 
    //TODO: 特别注意：root 结点必须是已经 new 过的有地址值的，不可以是 NULL，否则输出为空，不明白是为什么？
    binTree<char> * bTree = new binTree<char>(rNode);
    bTree->preInitialTree(rNode);
    cout<<"binary tree has been built!\n";
    bTree->preOrderTra(bTree->getRoot());
    cout<<endl;
    return 0;
  }
  ```

- 无参数版本

  先申请空间，把地址值赋给临时指针变量，再返回该临时指针变量值。

  ```cpp
  #include <iostream>
  using namespace std;

  template<typename T>
  struct treeNode{
    T value;
    treeNode * lchild;
    treeNode * rchild;
    treeNode(): value(), lchild(NULL), rchild(NULL) {}
  };

  template<typename T>
  class binTree {
  public:
    binTree(treeNode<T> * p = NULL) {this->root = p;}
    //~binTree();
    treeNode<T> * preInitialTree();
    treeNode<T> * getRoot() {return this->root;}
    void setRoot(treeNode<T> * root) {this->root = root;}
    void preOrderTra(treeNode<T> * t);
  private:
    treeNode<T> * root;
  };

  template<typename T>
  treeNode<T> * binTree<T>::preInitialTree() { 
  cout<<"please input the preorder sequence, use '*' to represent null:\n";
    T in;
    cin>>in;
    treeNode<T> * t;// 创建临时变量， 储存申请的内存空间地址，用于返回
    if (in != '*') {
      t = new treeNode<T>();
      t->value = in;
      t->lchild = this->preInitialTree();
      t->rchild = this->preInitialTree();
    } else {
      t = NULL;
    }
    return t;
  }// 所有递归结束后，返回的是一开始的 root 结点地址

  template<typename T>
  void binTree<T>::preOrderTra(treeNode<T> * t) {                    
    if (t) {
      cout << t->value << ' ';// 访问根结点
        preOrderTra(t->lchild); // 遍历左子树
        preOrderTra(t->rchild);// 遍历右子树
    }
  }

  int main() {
    binTree<char> * bTree = new binTree<char>();// 暂时把 root 设置为 NULL
    bTree->setRoot(bTree->preInitialTree()); // 根据先序扩展序列创建树的同时，将返回的结点地址设置为 root 结点
    cout<<"binary tree has been built!\n";
    bTree->preOrderTra(bTree->getRoot());
    cout<<endl;
    return 0;
  }
  ```

#### 3.1.3. 根据先序 + 中序 || 后序 + 中序 || 层序 + 中序 序列创建二叉树（递归实现）

http://blog.csdn.net/sgbfblog/article/details/7783935

http://c.biancheng.net/cpp/html/979.html

http://blog.csdn.net/beitiandijun/article/details/41993341

https://www.cnblogs.com/biaobiaoqi/archive/2013/08/29/3288810.html

[已知一棵二叉树的前序遍历为 CABEFDHG，中序遍历为 BAFECHDG，那么它的后续遍历是 ?](https://www.nowcoder.com/questionTerminal/a1ce62a2356b4521897decf9ae21f622)

先确定根与左右子树，然后画出相应的树的结构，以递归思路类推。

#### 3.1.4. 根据层序遍历序列创建二叉树（非递归实现）

http://blog.csdn.net/lilypp/article/details/6457621

### 3.2. 二叉树的遍历

http://blog.csdn.net/lilypp/article/details/6461725 

**时间复杂度都为 O（n）。**

#### 3.2.1. DFS（利用栈）

http://c.biancheng.net/cpp/html/977.html 

http://c.biancheng.net/cpp/html/978.html 

##### 3.2.1.1. 先序遍历（DLR）

- 递归实现
  ```cpp
  template<typename T>
  void binTree<T>::preOrderTra(treeNode<T> * t) { 
      if (t) {
        cout << t->value << ' ';// 访问根结点
        preOrderTra(t->lchild); // 遍历左子树
        preOrderTra(t->rchild);// 遍历右子树
      }
  }
  ```

- 非递归实现

##### 3.2.1.2. 中序遍历（LDR）

- 递归实现
  ```cpp
  template<typename T>
  void binTree<T>::inOrderTra(treeNode<T> * t) {                    
      if (t) {
        this->inOrderTra(t->lchild); // 遍历左子树
        cout << t->value << ' ';// 访问根结点
        this->inOrderTra(t->rchild);// 遍历右子树
      }
  }
  ```

- 非递归实现

##### 3.2.1.3. 后序遍历（LRD）

-	递归实现
  ```cpp
template<typename T>
void binTree<T>::postOrderTra(treeNode<T> * t) {                    
    if (t) {
        this->postOrderTra(t->lchild); // 遍历左子树
        this->postOrderTra(t->rchild);// 遍历右子树
        cout << t->value << ' ';// 访问根结点
    }
}
  ```

- 非递归实现

#### 3.2.2. BFS：层序遍历（利用队列）

http://blog.csdn.net/beitiandijun/article/details/41940417 

- 一次性输出所有结点
  ```cpp
  template<typename T>
  void binTree<T>::levelOrderTra(treeNode<T> * t) {
      if(t == NULL) return;
      queue< treeNode<T> *> que;
      que.push(t);
      while(!que.empty()) {
      	t = que.front();// 这一步必不可少，每一次循环都要重新取队首元素为 t，否则会无限循环
      	cout << t->value << ' ';
          que.pop();
      	if(t->lchild) 
              que.push(t->lchild);  
      	if(t->rchild) 
              que.push(t->rchild);  
      }
  }
  ```

- 分层次依次输出结点
  ```cpp
  template<typename T>
  void binTree<T>::levelOrderTra(treeNode<T> * t) {
      if (t == NULL) 
          return 0;  
      queue< treeNode<T> *> que;  
      que.push(t);  
      int depth = 0;
      while(!que.empty()) {  // 当队列为空，说明已经遍历完二叉树
          depth++;
          cout<<endl<<”第”<<depth<<“层：“;
          int curLevelNodesTotal = que.size(); // 当前层的结点总数
          for (int cnt = 0; cnt < curLevelNodesTotal; cnt++) { // cnt为当前层已访问过的结点数
              t = que.front();
              cout<<t->value<<’ ‘;
              que.pop();
              if (t->lchild)
                  que.push(t->lchild);  
              if (t->rchild)  
                  que.push(t->rchild);  
          }
      }
    	return depth;
  }
  ```

### 3.3. 二叉树与森林的转换

**树或森林与二叉树之间有自然的一一对应关系**。

任何一个森林或一棵树都可唯一地对应得到一棵二叉树。反之，任何一棵二叉树也能唯一地对应成一个森林或一棵树。

从树的二叉链表表示可知，任何一棵树转换成二叉树后，其根结点的右子树必然为空，若将森林中第二棵树的根结点作为第一棵树根结点的兄弟便可使森林转换为二叉树。

#### 3.3.1. 森林转换为二叉树

森林转换成二叉树的方法为：
- 对于森林中的每一棵树，将其所有兄弟结点之间建立一条连线，并在所有的树根之间也建立一条连线；
- 对于连接后的树中的每一个结点，除了保留该结点到它的最左子结点（即第一个子结点）的连线外，删除它到其他子结点的连线；
- 将经过上述步骤得到的树以根结点为轴，顺时针方向旋转 45°，使其层次分明。

由森林与二叉树之间转换的关系可知，**当森林转化成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树**，则上述森林的先序遍历和后序遍历即为其对应的二叉树的先序遍历和中序遍历。因此，**当用二叉链表来存储时，树的先根遍历和后根遍历可借助于二叉树的先序遍历和中序遍历算法来实现**。

#### 3.3.2. 二叉树转换成森林

二叉树转换成森林的方法为：
- 若某结点是其双亲的左子结点，则把该结点的右子结点、右子结点的右子结点都与该结点的双亲结点用线连接起来；
- 删去原二叉树中所有双亲结点与右子结点之间的连线；
- 对前面两个步骤所得到的结果进行旋转整理，使其结构层次分明。下图显示了二叉树转换为森林的过程。

从上述递归定义容易写出相互转换的递归算法。同时，森林和树的操作也可转换成二叉树的操作来实现。

### 3.4. 求二叉树的深度

http://blog.csdn.net/beitiandijun/article/details/41930583 

https://my.oschina.net/u/2477353/blog/662937

- 直接递归实现
  ```cpp
  int depth(treeNode* roor) {
      if (root == NULL) 
          return 0;
      return max(depth(root->lchild), depth(root->rchild)) + 1;
  }
  ```

- 递归实现——利用 DFS
  ```cpp
  #include <iostream>
  using namespace std;

  char a[] = {'a', 'b', '*', 'd', 'e', '*', '*', '*', 'c', '*', '*'};
  int index = 0;

  template<typename T>
  struct treeNode{
    T value;
    treeNode * lchild;
    treeNode * rchild;
    treeNode(): value(), lchild(NULL), rchild(NULL) {}
  };

  template<typename T>
  class binTree {
  public:
    binTree(treeNode<T> * p = NULL) {this->root = p;}
    //~binTree();
    treeNode<T> * preInitialTree();
    int getDepth(treeNode<T> * t);
    treeNode<T> * getRoot() {return this->root;}
    void setRoot(treeNode<T> * root) {this->root = root;}
    void preOrderTra(treeNode<T> * t);
  private:
    treeNode<T> * root;
  };

  template<typename T>
  treeNode<T> * binTree<T>::preInitialTree() {
    //cout<<"please input the preorder sequence, use '*' to represent null:\n";
    T in;
    in = a[index++];
    //cin>>in;
    treeNode<T> * t;
    if (in != '*') {
      t = new treeNode<T>();
      t->value = in;
      t->lchild = this->preInitialTree();
      t->rchild = this->preInitialTree();
    } else {
      t = NULL;
    }
    return t;
  }

  template<typename T>
  void binTree<T>::preOrderTra(treeNode<T> * t) {                    
    if (t) {
      cout << t->value << ' ';// 访问根结点
        preOrderTra(t->lchild); // 遍历左子树
        preOrderTra(t->rchild);// 遍历右子树
    }
  }

  template<typename T>
  int binTree<T>::getDepth(treeNode<T> * t) {
    if(!t) return 0;
      int lDepth = getDepth(t->lchild),
      rDepth = getDepth(t->rchild);
  return (((lDepth > rDepth)? lDepth: rDepth) + 1 );
  }

  int main() {
    binTree<char> * bTree = new binTree<char>();
    bTree->setRoot(bTree->preInitialTree());
    cout<<"binary tree has been built!\n";
    bTree->preOrderTra(bTree->getRoot());
    cout<<endl;
    
    cout<<"depth:"<<bTree->getDepth(bTree->getRoot())<<endl;
    return 0;
  }
  ```

- 非递归实现——利用 BFS（层序遍历实现）
  ```cpp
  #include <iostream>
  using namespace std;

  char a[] = {'a', 'b', '*', 'd', 'e', '*', '*', '*', 'c', '*', '*'};
  int index = 0;

  template<typename T>
  struct treeNode{
    T value;
    treeNode * lchild;
    treeNode * rchild;
    treeNode(): value(), lchild(NULL), rchild(NULL) {}
  };

  template<typename T>
  class binTree {
  public:
    binTree(treeNode<T> * p = NULL) {this->root = p;}
    //~binTree();
    treeNode<T> * preInitialTree();
    int getDepth(treeNode<T> * t);
    treeNode<T> * getRoot() {return this->root;}
    void setRoot(treeNode<T> * root) {this->root = root;}
    void preOrderTra(treeNode<T> * t);
  private:
    treeNode<T> * root;
  };

  template<typename T>
  treeNode<T> * binTree<T>::preInitialTree() {
    //cout<<"please input the preorder sequence, use '*' to represent null:\n";
    T in;
    in = a[index++];
    //cin>>in;
    treeNode<T> * t;
    if (in != '*') {
      t = new treeNode<T>();
      t->value = in;
      t->lchild = this->preInitialTree();
      t->rchild = this->preInitialTree();
    } else {
      t = NULL;
    }
    return t;
  }

  template<typename T>
  void binTree<T>::preOrderTra(treeNode<T> * t) {                    
    if (t) {
      cout << t->value << ' ';// 访问根结点
        preOrderTra(t->lchild); // 遍历左子树
        preOrderTra(t->rchild);// 遍历右子树
    }
  }

  template<typename T>
  int binTree<T>::getDepth(treeNode<T> * t) {
      if(t == NULL) return 0;  
      queue< treeNode<T> *> que;  
      que.push(t);  
      int depth = 0;  
      while(!que.empty()){  // 当队列为空，说明已经遍历完二叉树
          ++depth;  
          int curLevelNodesTotal = que.size(); // 当前层的结点总数
          int cnt = 0;// 当前层已访问过的结点数
          while(cnt < curLevelNodesTotal){
              ++cnt;  
              t = que.front();
              que.pop();
        if(t->lchild)
                  que.push(t->lchild);  
        if(t->rchild)  
                  que.push(t->rchild);  
          }
      }
  return depth;
  }

  int main() {
    binTree<char> * bTree = new binTree<char>();
    bTree->setRoot(bTree->preInitialTree());
    cout<<"binary tree has been built!\n";
    bTree->preOrderTra(bTree->getRoot());
    cout<<endl;
    
    cout<<"depth:"<<bTree->getDepth(bTree->getRoot())<<endl;
    return 0;
  }
  ```
### 3.5. 判断二叉树是否为完全二叉树

采用 BFS（层序遍历）来判断。

http://blog.csdn.net/lilypp/article/details/6158699

http://blog.csdn.net/chdjj/article/details/38685773?utm_source=tuicool&utm_medium=referral

采用广度优先遍历，从根节点开始，入队列，如果队列不为空，循环。**遇到第一个没有左儿子或者右儿子的节点，设置标志位，如果之后再遇到有左 / 右儿子的节点，那么这不是一颗完全二叉树**。

- 实现 Ⅰ
  ```cpp
  template<typename T>
  bool binTree<T>::isCompleteTree() {
    treeNode<T> * t = this->getRoot();
    if (!t) return false;// 空树不是完全二叉树
    if (!t->lchild && !t->rchild) return true;// 只有一个结点的树是完全二叉树
    if (!t->rchild) return false;// 左子树不为空，右子树为空的树不是完全二叉树
    queue< treeNode<T> * > que;
    que.push(t);
    int flag = 0;
    while (!que.empty()) {
      t = que.front();
      que.pop();
      // 对每一个结点的左右孩子进行判断，再入队列并设置标志位
      if (t->lchild) {
        if (flag) return false;
        que.push(t->lchild);
      } else flag = 1;
      if (t->rchild) {
        if (flag) return false;
        que.push(t->rchild);
      } else flag = 1;
    }
    return true;
  }
  ```

- 实现 Ⅱ
  ```cpp
  template<typename T>
  bool binTree<T>::isCompleteTree() {
    treeNode<T> * t = this->getRoot();
    if (!t) return false;
    if (!t->lchild && !t->rchild) return true;
    if (!t->rchild) return false;
    queue< treeNode<T> * > que;
    que.push(t);
    int flag = 0;
    while (!que.empty()) {
      t = que.front();
      que.pop();
      // 每个结点的左右孩子入队列，再进行判断并设置标志位
      if (t) {
        if (flag) return false;
        que.push(t->lchild);
        que.push(t->rchild);
      } else flag = 1;
      
    }
    return true;
  }
  ```

Other:
- 递归判断的方法

  https://www.cnblogs.com/sean10/p/5005184.html

  如果要使用最原始的递归，那么根据分形的原则，完全二叉树并没有处处分形（自相似），所以是肯定不能使用最原始的递归方法，即只传递一个根节点进入的。

  那么，可不可以通过追加其他的形参比如层次、深度、左右子树标记来达成目的呢？

  假设有一个深度为 3 的子树，追加这三项是可以判断出的，然而如果深度为 100 呢？仅一个标记已经无法判断这颗子树的位置，也就无法判断完全二叉树了。

  对于完全二叉树的判断，只能采用队列层次遍历的方法。

- 其他方法
  
  http://lib.csdn.net/article/datastructure/21525

### 3.6. 求二叉树的叶子总数

- 递归实现

  - 如果给定节点为 NULL，则是空树，叶子节点为 0，返回 0。
  - 如果给定节点左右子树均为 NULL，则是叶子节点，且叶子节点数为 1，返回 1。
  - 如果给定节点左右子树不都为 NULL，则不是叶子节点，以 t 为根节点的子树叶子节点数 = 左子树叶子节点数 + 右子树叶子节点数。
  ```cpp
  template<typename T>
  int binTree<T>::getTotalLeaf(treeNode<T> * t) { // 调用时传入 root 结点
      if (t == NULL) 
      	return 0;
      if (t->lchild == NULL && t->rchild == NULL)
      	return 1;
      return getTotalLeaf(t->lchild) + getTotalLeaf (t->rchild);
  }
  ```

- 非递归实现

  在遍历二叉树时，判断当前访问的节点是不是叶子节点，然后对叶子节点求和即可（前序、中序、后序、按层遍历均可）。

### 3.7. 遍历所有叶子结点

```cpp
template<typename T>
void binTree<T>::accessLeaf(treeNode<T> * t) {                    
    if(t == NULL) return;
    queue< treeNode<T> *> que;
    que.push(t);
    while(!que.empty()) {
		t = que.front();
		if (!t->lchild && !t->rchild) 
            cout << t->value << ' ';// 对层序遍历的输出加以判断即可
		que.pop();
		if(t->lchild) que.push(t->lchild);  
		if(t->rchild) que.push(t->rchild);  
    }
}
```

### 3.8. 为二叉树复制一份副本

```cpp
template<typename T>
treeNode<T> * binTree<T>::copyTree(treeNode<T> * t) {
	treeNode<T> * p;
	if (t) {
		p = new treeNode<T>();
		p->lchild = this->copyTree(t->lchild);
		p->rchild = this->copyTree(t->rchild);
		p->value = t->value;
		return p;
	} else
        return NULL;
}
```

### 3.9. 判断两棵树是否相等

```cpp
template<typename T>
bool binTree<T>::isEqual(treeNode<T> * t1, treeNode<T> * t2) {
	if (!t1 && !t2) 
        return true;
	if (t1 && t2 && t1->value == t2->value 
        && this->isEqual(t1->lchild, t2->lchild) 
        && this->isEqual(t1->rchild, t2->rchild))
		return true;
	return false;
}
```

## 4. 其它操作

### 4.1. 求每层的节点数，保存在数组中

https://www.oschina.net/code/snippet_271680_10278

### 4.2. 求二叉树第 K 层的节点数和二叉树第 K 层的叶子节点数，递归方式和非递归方式

http://blog.csdn.net/beitiandijun/article/details/41941211

### 4.3. 打印二叉树中第 K 层的第 M 个节点，非递归算法

http://blog.csdn.net/beitiandijun/article/details/41942429 

### 4.4. 比较两个二叉树是否相同（结构和数据），递归和非递归

http://blog.csdn.net/beitiandijun/article/details/41957181 

### 4.5. 求二叉树的镜像，递归和非递归方式

http://blog.csdn.net/beitiandijun/article/details/41958885 

### 4.6. 查找两个节点的最近公共祖先（LCA 问题）

TODO:

http://blog.csdn.net/beitiandijun/article/details/41970417

### 4.7. 求二叉树中任意两个节点之间的距离，递归和非递归

http://blog.csdn.net/beitiandijun/article/details/41978369

## 5. Refer Links

http://c.biancheng.net/cpp/html/980.html 
