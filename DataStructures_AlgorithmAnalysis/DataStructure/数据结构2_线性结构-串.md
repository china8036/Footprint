- [数据结构：线性结构 - 串](#数据结构线性结构---串)
	- [1. 基本概念](#1-基本概念)
	- [2. 存储结构](#2-存储结构)
		- [2.1. 顺序存储结构](#21-顺序存储结构)
		- [2.2. 链式存储结构](#22-链式存储结构)
	- [3. 基本操作](#3-基本操作)
	- [4. 串的模式匹配](#4-串的模式匹配)
		- [4.1. 回溯方法](#41-回溯方法)
				- [4.1.1. 算法思想](#411-算法思想)
				- [4.1.2. 时间复杂度](#412-时间复杂度)
				- [4.1.3. 代码实现](#413-代码实现)
		- [4.2. 非回溯方法](#42-非回溯方法)
			- [4.2.1. KMP 算法 (Knuth-Morris-Pratt)](#421-kmp-算法-knuth-morris-pratt)
				- [4.2.1.1. 算法思想](#4211-算法思想)
				- [4.2.1.2. 时空效率](#4212-时空效率)
				- [4.2.1.3. 代码实现 C++](#4213-代码实现-c)
				- [4.2.1.4. 代码实现 Java](#4214-代码实现-java)
				- [4.2.1.5. 例题实践](#4215-例题实践)
			- [4.2.2. BM 算法 (Boyer-Moore)](#422-bm-算法-boyer-moore)
				- [4.2.2.1. 概述](#4221-概述)
				- [4.2.2.2. 基本思想](#4222-基本思想)
				- [4.2.2.3. 移动规则](#4223-移动规则)
				- [4.2.2.4. 算法分析](#4224-算法分析)
				- [4.2.2.5. 算法实现](#4225-算法实现)
			- [4.2.3. SUNDY 算法（BM 算法的改进）](#423-sundy-算法bm-算法的改进)
			- [4.2.4. Horspool 算法](#424-horspool-算法)
			- [4.2.5. KR 算法](#425-kr-算法)
			- [4.2.6. AC 自动机](#426-ac-自动机)
	- [5. Refer Links](#5-refer-links)

# 数据结构：线性结构 - 串

## 1. 基本概念

串（string）是由零个或多个字符构成的有限序列，是一种最简单的线性表，其元素为文字符号，用于描述非数值的简单信息。

串一般记为 `s = 's1s2…sn' (n≥0)`，其中，s 是串名，用单引号括起来的字符序列是串的值，但单引号本身并不属于串，si（1≤i≤n）为一个字符。

串的长度：串中字符的数目 n。 

空串：零个字符的串，其长度为零。 

空白串：由一个或多个空格组成的串，其长度为串中空格字符的个数。 

子串：串中任意个连续的字符组成的子序列。 

主串：包含子串的串相应地称为主串。 

字符在串中的位置：字符在序列中的序号。 

串相等：当且仅当这两个串的值相等，即两个串的长度相等，并且各个对应位置的字符都相等。

## 2. 存储结构

与线性表类似，串也有两种基本的存储结构：顺序结构与链式结构。**考虑到存储效率与算法实现的方便性，串多采用顺序存储结构。**

### 2.1. 顺序存储结构

串的顺序存储结构简称为顺序串。与顺序表类似，顺序串用一组地址连续的存储单元来存储串中的字符序列，**可用高级程序语言中字符数组来实现**。按存储分配的不同可将顺序串分为**静态存储分配的顺序串和动态存储分配的顺序串**。

### 2.2. 链式存储结构

用单链表方式存储串的值，这种存储结构简称为链串，链串分为两种形式（但是非常少用）: 
- 非压缩形式

  一个链表结点只存储一个字符。为了操作方便，设置一个指向首元素结点的指针和一个指向尾元素结点的指针，同时仍设置串长度值字段。这种结构类似于线性表的链式存储，其优点是操作方便，但存储利用率很低。

- 压缩形式

  一个链结点存储多个字符，实质上是一种连续存储与链式相结合的结构。这种结构能提高存储利用率，但其对应的操作实现起来较为复杂。

## 3. 基本操作

## 4. 串的模式匹配

http://dsqiu.iteye.com/blog/1700312

### 4.1. 回溯方法

基于回溯的串的模式匹配方法也称为 BF(Brute Force) 算法 / 蛮力算法 / 暴力算法 / 朴素 / 暴风算法。

##### 4.1.1. 算法思想

从目标串的第一个字符起与模式串的第一个字符比较，若相等，则继续对字符进行后续的比较，否则目标串从第二个字符起与模式串的第一个字符重新比较，直至模式串中的每个字符依次和目标串中的一个连续的字符序列相等为止，此时称为匹配成功，否则匹配失败。

##### 4.1.2. 时间复杂度

O(mn)。m: 主串长度，n: 子串长度。

##### 4.1.3. 代码实现

```cpp
#include <iostream>
#include <string>
using namespace std;

size_t BF(string s, string p) {
  if (p.length() > s.length()) return -1;
  size_t ii = 0;
  for (size_t i = 0, j = 0; j < p.length();) {
    if (s[i] == p[j]) {i++;j++;}
    else {
      ii++;
      i = ii;
      j= 0;
      if (s.length() - ii < p.length()) return -1;
    }
  }
  return ii;
}

int main() {
  cout<<BF("ABABAB ABCDEFAB","AB AB");
}
```

### 4.2. 非回溯方法

非回溯的串的模式匹配方法属于**启发式搜索**，包括以下几种算法。

#### 4.2.1. KMP 算法 (Knuth-Morris-Pratt)

##### 4.2.1.1. 算法思想

1. 针对搜索词，算出一张《部分匹配表》（Partial Match Table），得到 next 数组

    下面介绍《部分匹配表》是如何产生的：

    首先，要了解两个概念："前缀"和"后缀"。 "前缀"指除了最后一个字符以外，一个字符串的全部头部组合；"后缀"指除了第一个字符以外，一个字符串的全部尾部组合。**"部分匹配值"就是"前缀"和"后缀"的最长的共有元素的长度**。

    ![image](http://img.cdn.firejq.com/jpg/2018/2/22/6a95983b35ca7a5a4d075a47161ee966.jpg)

    例：对于"ABCDABD"：
    - "A"的前缀和后缀都为空集，共有元素的长度为 0；
    - "AB"的前缀为 [A]，后缀为 [B]，共有元素的长度为 0；
    - "ABC"的前缀为 [A, AB]，后缀为 [BC, C]，共有元素的长度 0；
    - "ABCD"的前缀为 [A, AB, ABC]，后缀为 [BCD, CD, D]，共有元素的长度为 0；
    - "ABCDA"的前缀为 [A, AB, ABC, ABCD]，后缀为 [BCDA, CDA, DA, A]，共有元素为"A"，长度为 1；
    - "ABCDAB"的前缀为 [A, AB, ABC, ABCD, ABCDA]，后缀为 [BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为 2；
    - "ABCDABD"的前缀为 [A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为 [BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为 0。
		因此，可得到《部分匹配表》如下所示：

    ![image](http://img.cdn.firejq.com/jpg/2018/2/22/3629a9f2f1f3b63a68a78ba7d07d1cf7.jpg)

	但在实际代码实践中，通过部分匹配表来决定 pattern 后移的步长还需要额外的计算，因此，可将部分匹配表整体向后移动一列（第一列赋值为 -1），从而得到 next 数组：
	
    |            | A    | B    | C    | D    | A    | B    | D    |
    | ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
    | 部分匹配值 | 0    | 0    | 0    | 0    | 1    | 2    | 0    |
    | next 数组  | -1   | 0    | 0    | 0    | 0    | 1    | 2    |

1. 字符串"BBC ABCDAB ABCDABCDABDE"的第一个字符与搜索词"ABCDABD"的第一个字符，从左到右进行比较。

1. 根据 next 数组决定每次匹配开始的位置，同时将搜索词一步步后移，直到将整个搜索词匹配成功。
    - 如果匹配成功，则匹配搜索词的下一个字符，并且一直匹配搜索词的下一个字符，直到全部匹配完毕。或者直到出现匹配失败的字符。
    - 如果匹配失败，则将匹配搜索词的索引置为 next 数组中的对应值，重新与原字符串的字符进行匹配。

NOTE: 

整个 KMP 的重点就在于**当某一个字符与主串不匹配时，我们应该知道 j 指针要移动到哪？利用已经部分匹配这个有效信息，保持 i 指针不回溯，通过修改 j 指针，让模式串尽量地移动到有效的位置**。

"部分匹配"的实质是，有时候，字符串头部和尾部会有重复。比如，"ABCDAB"之中有两个"AB"，那么它的"部分匹配值"就是 2（"AB"的长度）。搜索词移动的时候，第一个"AB"向后移动 4 位（字符串长度 - 部分匹配值），就可以来到第二个"AB"的位置。

每次都要计算最长的相同的前缀会不会反而浪费了时间？对于模式串来说，我们会提前计算出每个匹配失败的位置应该移动的距离，花费的时间是常数时间。

##### 4.2.1.2. 时空效率

**KMP 算法的时间复杂度为 O(m+n)（m: 主串长度  n: 子串长度）。其中，预处理的时间复杂度是 O(n)，匹配操作的时间复杂度是 O(m)。**

**KMP 算法的空间复杂度为 O(n)。**

##### 4.2.1.3. 代码实现 C++

- 不使用 STL

  http://www.cppblog.com/converse/archive/2006/07/05/9447.html
  
  http://www.xefan.com/archives/83859.html

  ```cpp
  #include <iostream>
  #include <string>
  using namespace std;

  // 根据模式串 p 求得相应的《部分匹配表》，存在 next 数组中
  // i 是主串的游标，j 是模式串的游标，但这里的主串和模式串都是同一个字符串即 p
  // j == -1 表示如果模式串游标已经回退到第一个字符，p[i] == p[j] 表示匹配成功
  int * GetNext(string p) {
    int * next = new int[p.length()];
    next[0] = -1;
    for (unsigned int i = 0, j = -1; i < p.length();) {
      if((j == -1) || (p[i] == p[j])) next[++i] = ++j; // 存放当前的 next 值为此时模式串的游标值
      else j = next[j]; // 匹配不成功 j 就回退到上一个 next 值
    }
    return next;
  }

  int KMP(string p1, string p2) {
    if (p2.length() > p1.length()) return -1;
    int * next = GetNext(p2);

    unsigned int i = 0, j = 0;
    while (j < p2.length()) {
      if (p1[i] == p2[j]) {i++;j++;}
      else {
        if (next[j] > 0) j = next[j];
        else {i++;j = 0;}//next[i]==0 和 next[i]<0 的情况
        if ((p1.length() - i) < (p2.length() - j)) return -1;
      }
    }
    return (i - p2.length());
  }

  int main() {
    string p1 = "BBC ABCDAB ABCDABCDABDE", p2 = "ABDE";
    cout<<"out:"<<KMP(p1, p2);
  }
  ```

- 使用 STL

  https://www.cnblogs.com/kaituorensheng/p/3633700.html

  ```cpp
  #include <iostream>
  #include <cstring>
  #include <string>
  #include <set>
  #include <map>
  using namespace std;

  void BuildPatchMatchTable(int *partMatchTable, char *findstr)
  {
      if(findstr == NULL)
          return;
      partMatchTable[0] = 0;
      int sizefind = strlen(findstr);
      for(int i = 1; i < sizefind; ++i)
      {
          set<string> preset;
          string tmppre = "";
          tmppre = findstr[0];
          preset.insert(tmppre);
          for(int j = 1; j < i; ++j)
          {
              tmppre = tmppre + findstr[j];
              preset.insert(tmppre);
          }

          set<string> postset;
          string tmppost = "";
          tmppost = findstr[i];
          postset.insert(tmppost);
          for(int j = i - 1; j > 0; --j)
          {
              tmppost =  findstr[j] + tmppost;
              postset.insert(tmppost);
          }
          set<string> comset;
          for(set<string>::iterator beg = preset.begin(); beg != preset.end(); ++beg)
          {
              if(postset.count(*beg) > 0)
                  comset.insert(*beg);
          }
          int maxlen = 0;
          for(set<string>::iterator beg = comset.begin(); beg != comset.end(); ++beg)
          {
              if((*beg).size() > maxlen)
                  maxlen = (*beg).size();
          }
          partMatchTable[i] = maxlen;
      }
  }    

  int kmp(char *srcstr, char *findstr)
  {
      if(srcstr == NULL || findstr == NULL)
          return -1;
      int lensrc = strlen(srcstr);
      int lenfind = strlen(findstr);
      int *partMatchTable = new int[lenfind];
      BuildPatchMatchTable(partMatchTable, findstr);
      for(int i = 0; i < lenfind; ++i)
          cout << findstr[i] << "\t" << partMatchTable[i] << endl;
      int curFind = 0;
      for(int i = 0; i < lensrc; )
      {
          if(findstr[curFind] == srcstr[i])
          {
              ++i;
              ++curFind;
          }
          else
          {
              if(curFind == 0)
                  ++i;
              else
              {
                  int movestep = curFind - partMatchTable[curFind-1];
                  i += movestep;
                  curFind = 0;
              }
          }
          if(curFind == lenfind)
          {
              delete []partMatchTable;
              return i - lenfind;
          }
      }
      return -1;
      delete []partMatchTable;
  }
  int main()
  {
      char srcStr[] = "bbc abcdab abcdabcdabde";
      char findStr[] = "abcdabd";
      cout << "pos:" << kmp(srcStr, findStr) << endl;

      char srcStr2[] = "bbc abcdab abcdabcdabdezzz";
      char findStr2[] = "zzz";
      cout << "pos:" << kmp(srcStr2, findStr2) << endl;

      char srcStr3[] = "bbc abcdab abcdabcdabde";
      char findStr3[] = "zzz";
      cout << "pos:" << kmp(srcStr3, findStr3) << endl;
  }
  ```

##### 4.2.1.4. 代码实现 Java

```java
// 总的复杂度为 O(m+n)
public static void main(String[] args) {
	String str = "BBC ABCDCDAB ABCDABCDABDE";
	String pattern = "ABCDABD";
	System.out.println(kmp(str, pattern));
}

// 生成 next 数组，复杂度为 O(m)
// 部分匹配表：0 0 0 0 1 2 0
// 		next: -1 0 0 0 0 1 2
private static int [] getNext(String pattern) {
	int [] next = new int[pattern.length()];
	next[0] = -1;	
	for (int i = 0, k = next[0]; i < pattern.length() - 1;) {
		if (k == -1 || pattern.charAt(k) == pattern.charAt(i))
			next[++i] = ++k;
		else
			k = next[k];
	}
	return next;
}

// 执行匹配，复杂度为 O(n)
private static int kmp(String str, String pattern) {
	int [] next = getNext(pattern);
	for (int i = 0, j = 0; i < str.length() && j < pattern.length();) {
		if (str.charAt(i) == pattern.charAt(j)) {
			i++;
			j++;
		} else {
			if (j == 0)
				i++;
			else
				j = next[j];
		}
		if (j == pattern.length())
			return i - j;
	}
	return -1;
}
```

##### 4.2.1.5. 例题实践

[Leetcode: 28. Implement strStr()](https://leetcode.com/problems/implement-strstr/description/)

- Question
	> Implement strStr().
	> 
	> Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

	Example 1:
	```
	Input: haystack = "hello", needle = "ll"
	Output: 2
	```

- Solution
	```java
	public int strStr(String haystack, String needle) {
			for (int i = 0; ; i++) {
					for (int j = 0; ; j++) {
							if (j == needle.length()) 
									return i;
							if (i + j == haystack.length()) 
									return -1;
							if (needle.charAt(j) != haystack.charAt(i + j)) 
									break;
					}
			}
	}
	```

#### 4.2.2. BM 算法 (Boyer-Moore)

http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html

http://www.xefan.com/archives/83866.html

https://www.cnblogs.com/lanxuezaipiao/p/3452579.html

##### 4.2.2.1. 概述

Boyer-Moore 字符串搜索算法是一种非常高效的字符串搜索算法。**此算法仅对搜索目标字符串（关键字）进行预处理，而非被搜索的字符串。**BM 算法不需要对被搜索的字符串中的字符进行逐一比较，而会跳过其中某些部分。**通常搜索关键字越长，算法速度越快。**它的效率来自于这样的事实：**对于每一次失败的匹配尝试，算法都能够使用这些信息来排除尽可能多的无法匹配的位置**。通过这种字符的移动方式来代替逐个比较是这个算法如此高效的关键所在。

BM 算法是实际应用中字符串匹配效率比较高的算法，其的应用效果是优于 KMP 算法的，其他人测试应该是 2-5 倍，文本编辑器的”查找”功能（Ctrl+F），大多采用的是该算法。不过 KMP 算法在理论上设计是较为优雅的，性能较 BM 算法在最坏情况下，是更优的。

##### 4.2.2.2. 基本思想

BM 算法实际上包含两个并行的算法（也就是两个启发策略）：坏字符算法（bad-character shift）和好后缀算法（good-suffix shift）。这两种算法的目的就是让模式串每次向右移动尽可能大的距离。

算法实现必须对模式串进行预处理，得到坏字符规则和好后缀规则移动的映射表，即移动规则。移动规则实际上是一张间恒定的查找表，通过对 Patten 的预处理产生的。

BM 算法的基本思想是，**每次实际后移这两个规则之中的较大值**。

##### 4.2.2.3. 移动规则

移动字符数（移动规则）是通过两条规则决定的：坏字符规则和好后缀规则。

- 坏字符（Bad-character）规则

  > 后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置（如果"坏字符"不包含在搜索词之中，则上一次出现位置为 -1。）
  
  原理（维基）：

  当 T 中有字符不匹配时，如果 T 中的这个不匹配的字符出现在对应 P 中当前位置的左侧，那么 P 移动位置将这两个在字符对齐。如果 T 中这个不匹配字符不在 P 中当前位置的左侧，那么将当前位置左侧的所有字符均移到该不匹配字符后。右侧的例子中，X 位置发生了不匹配，我们检查 P 中的不匹配字符 N（对应 T 中字符 A）在 P 当前位置（X）的左侧存在，因此，将最靠近该不匹配字符位置的 N 与 P 中的 X 位置的 N 对齐，也就是向右移动两位。
  
	处理
  
	当我们发现不匹配字符时，假设这个字符在 T 中为 c，位置在 T 的 i。字符 c 在 P 中出现的最靠近 i 位置，假设为 j，j<i 或 j = -1（如果 P 不存在字符 c）。那么移动位数为 i - j，复杂度是 O(1)。i，j 的起点为 P 在 T 中位置的开始 T[(k-n+1)..k] 的 (k-n+1)。 国内（China）大多网站都只建立一个一维坏字符数组来保存，但事实这只能保存最靠左或最靠右的字符 c，明显与英文的 wikipedia 里面要求一个二维数组来保存信息的不一样。

		好后缀（Good-suffix）（即所有尾部匹配的字符串包括其子串）规则
	
	> 后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置
	
	举例来说，如果字符串"ABCDAB"的后一个"AB"是"好后缀"。那么它的位置是 5（从 0 开始计算，取最后的"B"的值），在"搜索词中的上一次出现位置"是 1（第一个"B"的位置），所以后移 5 - 1 = 4 位，前一个"AB"移到后一个"AB"的位置。

	再举一个例子，如果字符串"ABCDEF"的"EF"是好后缀，则"EF"的位置是 5 ，上一次出现的位置是 -1（即未出现），所以后移 5 - (-1) = 6 位，即整个字符串移到"F"的后一位。

	这个规则有三个注意点：
	- "好后缀"的位置以最后一个字符为准。假定"ABCDEF"的"EF"是好后缀，则它的位置以"F"为准，即 5（从 0 开始计算）。
	- 如果"好后缀"在搜索词中只出现一次，则它的上一次出现位置为 -1。比如，"EF"在"ABCDEF"之中只出现一次，则它的上一次出现位置为 -1（即未出现）。
	- 如果"好后缀"有多个，则除了最长的那个"好后缀"，其他"好后缀"的上一次出现位置必须在头部。比如，假定"BABCDAB"的"好后缀"是"DAB"、"AB"、"B"，请问这时"好后缀"的上一次出现位置是什么？回答是，此时采用的好后缀是"B"，它的上一次出现位置是头部，即第 0 位。这个规则也可以这样表达：如果最长的那个"好后缀"只出现一次，则可以把搜索词改写成如下形式进行位置计算"(DA)BABCDAB"，即虚拟加入最前面的"DA"。

	原理（维基）:
	
	好后缀规则要更复杂一点。假设有 P 和 T，T 中字串 t 匹配到了 P 的一个后缀，但在比较位置 i 时发生不匹配。设匹配到的好后缀在 T 中为 t，在 P 中为 t'（t = t'）。
	
	分两种情况来讨论：
	- 在 P 中 i 位置的左侧最靠近 i 位置查找字串 t'使得 t'=t（此时 t'不是 P 的后缀，实际上也就是查找匹配到的字串除了在 P 的后缀中存在，是否在 P 的其他位置存在），若存在，则移动相应的位数将找到的 t'与 T 中的 t 对齐。
	- 如果 t'不存在，那我们继续查找 t 的某一个后缀是否为 P 的前缀，若存在，则移动相应的位将 P 的前缀与 t 的后缀位置对齐。否则，将 P 向后移动 n 个字符。
	
	好后缀规则的实质是，将不匹配位置右侧匹配到的字符串 t 的所有字符后缀组合，用于查找它们在 P 的不匹配位置左侧是否存在。通俗的理解是，最长的好后缀 t 是否存在于 i 的左侧（情况 1），其他后缀组合中是否存在与 P 的前缀相同的情况（情况 2）。

##### 4.2.2.4. 算法分析

算法分为两个阶段：预处理阶段和搜索阶段。

假设文本串 text 长度为 n，模式串 pattern 长度为 m，

预处理阶段时间和空间复杂度都是 O(m+n)。

搜索阶段时间复杂度是 O(mn)。

当模式串是非周期性的，在最坏的情况下算法需要进行 3n 次字符比较操作。

算法在最好的情况下达到 O(n / m)，比如在文本串 bn 中搜索模式串 am-1b ，只需要 n/m 次比较。

##### 4.2.2.5. 算法实现

1. 计算坏字符数组 bmBc[]

    坏字符可能在 pattern 中多处出现，而我们需要的是最右边的位置，这样就需要每次循环判断了，非常麻烦，性能差。这里有个小技巧，就是使用字符作为下标而不是位置数字作为下标。这样只需要遍历一遍即可，这貌似是空间换时间的做法，但如果是纯 8 位字符也只需要 256 个空间大小，而且对于大模式，可能本身长度就超过了 256，所以这样做是值得的（这也是为什么数据越大，BM 算法越高效的原因之一）。

1. 计算好后缀数组 bmGs[]

    https://www.cnblogs.com/lanxuezaipiao/p/3452579.html
    
    http://dsqiu.iteye.com/blog/1700312
    
    http://yaowhat.com/2014/08/15/week-str-bm.html

#### 4.2.3. SUNDY 算法（BM 算法的改进）

http://blog.csdn.net/sunmc1204953974/article/dails/43371283

#### 4.2.4. Horspool 算法

http://www.xefan.com/archives/83871.html

http://dsqiu.iteye.com/blog/1700312

#### 4.2.5. KR 算法

#### 4.2.6. AC 自动机

## 5. Refer Links

[阮一峰：字符串匹配的 KMP 算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

[从头到尾彻底理解 KMP](https://blog.csdn.net/v_july_v/article/details/7041827)

[KMP 算法（字符串匹配算法）详解及 java 实现](https://blog.csdn.net/syy0377/article/details/17352539)