- [数据结构：线性结构 - 线性表](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84---%E7%BA%BF%E6%80%A7%E8%A1%A8)
  - [1. 概述](#1-%E6%A6%82%E8%BF%B0)
  - [2. 线性表的顺序存储结构 (Sequential Storge)](#2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-sequential-storge)
    - [2.1. 基本概念](#21-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [2.2. 基本操作](#22-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)
      - [2.2.1. 插入元素](#221-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0)
      - [2.2.2. 删除元素](#222-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0)
      - [2.2.3. 其它](#223-%E5%85%B6%E5%AE%83)
  - [3. 线性表的链式存储结构 (Chain Storge)](#3-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-chain-storge)
    - [3.1. 基本概念](#31-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [3.2. 基本操作](#32-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)
      - [3.2.1. 插入元素](#321-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0)
      - [3.2.2. 删除元素](#322-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0)
      - [3.2.3. 反转链表](#323-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8)
    - [3.3. 双向链表](#33-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8)
  - [4. 线性表应用](#4-%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%BA%94%E7%94%A8)
    - [4.1. 多项式问题](#41-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%97%AE%E9%A2%98)
      - [4.1.1. 多项式表示](#411-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A1%A8%E7%A4%BA)
      - [4.1.2. 多项式相加](#412-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9B%B8%E5%8A%A0)
    - [4.2. 约瑟夫环（Josephus 问题）](#42-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%EF%BC%88josephus-%E9%97%AE%E9%A2%98%EF%BC%89)
  - [5. Refer Links](#5-refer-links)

# 数据结构：线性结构 - 线性表

线性数据结构是实际应用中最基本、最简单、最常用的一种数据结构。

线性数据结构的基本特点是：**数据元素之间具有一种线性关系，即除第一个元素外，集合中的每个元素均有且只有一个直接前驱元素，除最后一个元素外，集合中的每个元素均有且只有一个直接后继元素**。

## 1. 概述

**线性表是由 n（n≥0）个类型相同的数据元素组成的有限序列，通常表示为 L = (a1, …, ai–1, ai, ai+1, …, an)**。其中，L 为线性表名称，ai 为组成该线性表的数据元素，ai–1 领先于 ai，ai 领先于 ai+1，称 ai–1 是 ai 的直接前驱元素，ai+1 是 ai 的直接后继元素。当 i=1, 2, ..., n–1 时，ai 有且仅有一个直接后继；当 i=2, 3, …, n 时，ai 有且仅有一个直接前驱。

**线性表的长度就是线性表中元素的个数 n（n ≥ 0）。当 n=0 时，称为空表。在非空表中的每个数据元素都有一个确定的位置**，如 a1 是第一个数据元素，an 是最后一个数据元素，ai 是第 i 个数据元素，称 i 为数据元素 ai 在线性表中的位序。

## 2. 线性表的顺序存储结构 (Sequential Storage)

### 2.1. 基本概念

线性表的顺序存储结构 / 顺序映射 / 顺序表示，是指用一组地址连续的存储单元依次存储线性表中的数据元素，以数据元素在计算机内“物理位置相邻”来表示线性表中数据元素之间的逻辑关系。通常，称这种存储结构的线性表为顺序表。

设 ai 的存储地址为 Loc(ai)，每个数据元素占用 d 个字节存储单元，则第 i 个数据元素的地址为 `Loc(ai)=Loc(ai)+(i–1)×d，1≤i≤n`。Loc(a1) 通常称作线性表的起始位置或基地址。

特点：
- 线性表的顺序存储结构是一种**随机存取**的存储结构。只要确定了存储线性表的起始位置，线性表中任一个数据元素都可随机存取。

- 线性表的长度可变，而且最大存储空间随问题的不同而不同，因此需要动态地分配线性表的空间。在 C++ 语言中，可用动态分配的一维数组来表示。

优点：
- 属于**随机存取结构，求址方便，随机存取效率高 (O(1))**。

缺点：
- **添加、删除元素需要移动大量元素（除非在表头 / 表尾），效率低 (O(n))**。
- **静态分配内存空间，对存储空间利用不充分，会造成内存的浪费**。

### 2.2. 基本操作

#### 2.2.1. 插入元素

线性表的插入操作是指在线性表的第 i–1 个数据元素和第 i 个数据元素之间插入一个新的数据元素 b，其结果是使长度为 n 的线性表 (a1, …, ai–1, ai, …, an) 变成长度为 n+1 的线性表 (a1, …, ai–1, b, ai, …, an)，并且数据元素 ai–1 和 ai 之间的逻辑关系发生了变化。

在线性表的顺序存储结构中，由于逻辑上相邻的数据元素在物理位置上也相邻，因此需将第 i～n（共 n–i+1）个元素向后移动一个位置，才能反映这个逻辑关系的变化。

也就是说，为了在表中第 k 个元素之后插入一个新元素，首先需要把 k+1 ~ length 的每个元素都向后移动一个位置，然后才能把新元素插入到 k+1 的位置。**在移动元素时，由于后一个元素需要赋值为前一个元素，因此一般会从最后一个元素往前逆向遍历，以避免赋值时出现的覆盖问题**。

```cpp
/* 在第 k 个位置插入元素 x */
template<class T>
bool LinearList<T>::insert(int k, const T& x) {
    // 若不存在第 k 个元素，抛出异常
    if (k < 0 || k > length)
      throw OutOfBounds();
    // 若表已满，抛出异常
    if (length == MaxSize)
      throw NoMem();
    // 从最后一个元素开始，将位置 k 后的每个元素都向后移动一个元素
    for (int i = length - 1; i > k; i --) 
      element[i+1] = element[i];
    // 在第 k 个位置插入 x
    element[k] = x;
    length++;
    
    return true;
}
```
Insert 操作的执行时间的长短取决于需要移动元素的个数，而移动元素的个数取决于插入元素的位置。**通过计算可知，在顺序表中插入一个数据元素，平均需要移动表中一半的元素。若表长为 n，则顺序表插入操作的时间复杂度为 O(n)**。

#### 2.2.2. 删除元素

线性表的删除操作是使长度为 n 的线性表 (a1, …, ai–1, ai, ai+1, …, an) 变为长度为 n–1 的线性表 (a1, …, ai–1，ai+1, …, an)，并且数据元素 ai–1、ai 和 ai+1 之间的逻辑关系也会发生变化。

与线性表的插入运算相反，线性表的删除操作需要把第 i+1～n 个元素（共 n–i 个元素）依次向前移动一个位置来反映这个变化。**在移动元素时，由于不需要考虑插入元素时产生的覆盖问题，因此直接从前往后遍历移动即可**。

```cpp
/* 将第 k 个元素赋值到 x 中，然后删除第 k 个元素 */
template<class T>
bool LinearList<T>::delete(int k, T& x) {
  if (k < 1 || k > length)
    return false;
  x = element[k-1];
  // 从第 k+1 个元素开始，将位置 k 后的每个元素都向前移动一个元素
  for (int i = k; i < length; i ++) 
    element[i-1] = element[i]
  length --;
  return true;
}
```
Delete 操作的执行时间的长短取决于需要移动元素的个数，而移动元素的个数取决于删除元素的位置。通**过计算可知，在顺序表中删除一个数据元素，平均需要移动表中一半的元素。若表长为 n，则顺序表删除操作的时间复杂度为 O(n)**。

**实际应用中，顺序表的删除操作可根据具体应用进行优化**。

例：已知一个线性表中的元素按元素值非递减有序排列，设计算法删除其中**值相同**的元素。

- 方法一：O(n^2)
  ```cpp
  void purge(int * list, int & last) {
    int i = 0;
    while (i < last - 1) {
      if (list[i] != list[i + 1])
        i ++;
      else {
        for (int j = i + 2; j < last; j ++) 
          list[j-1] = list[j];
        last --;
      }
    }
  }
  ```
- 方法二（**使用 2 个索引进行优化**）：O(n)
  ```cpp
  void purge(int * list, int & last) {
        int j = 0, i = 1;
        // j 索引走过的即为最终的序列，i 是探测索引，用于探测是否有重复元素
        while (i <= last) {
              // 若不相同，2 个索引都向后走一步，否则，只有 i 索引往后走，j 索引不动
              if (list[i] != list[j])
                	list[++j] = list[i];
              i ++;
        }
  }
  ```

#### 2.2.3. 其它

考虑一些特殊的情形，如需要维持 3 个线性表，而任何时候**这三个线性表所拥有的元素的总数不会超过 5000 个**，但有可能在某个时刻，线性表 1 需要 5000 个元素（表 2 和 3 为空），或者线性表 2 、线性表 3 需要 5000 个元素。

若采用类 Linear List，则即使在任何时刻都不会使用总共 5000 以上的元素，这 3 个线性表中的每一个线性表都还是需要有 5000 个元素的容量，即一共 15000 个元素的容量。

对于这种情况，比较好的方法是**把所有的线性表都放在一个数组 list 中描述，并使用两个附加的数组 first 和 last 对这个数组进行索引，分别指向 3 个线性表的头部索引和尾部索引**。

![image](http://img.cdn.firejq.com/jpg/2018/6/18/e220e594b8aea754abaa39a8116861d3.jpg)

first[i] 为第 i 个表中的第一个元素，last[i] 是第 i 个表中的最后一个元素。

根据这些约定，每当第 i 个表不为空时，有 last[i]>first[i], 而当第 i 个表为空时，有 last[i]=first[i]。

## 3. 线性表的链式存储结构 (Chain Storage)

### 3.1. 基本概念

线性链表是指用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的），通过存储数据元素信息的数据域和直接后继存储位置的指针域构成数据元素 ai 的存储映射，即结点 (node)。n 个结点 ai（1≤i≤n）链接成一个链表，即为线性表 (a1, a2, …, an) 的链式存储结构。由于此链表的每个结点中只包含一个指针域，故又称为线性链表或单链表。 

整个链表的存取由头指针 H 开始进行，它指向链表中第一个结点的存储位置，线性链表中最后一个结点的指针为“空”（NULL）。有时，在单链表的第一个结点之前附设一个结点，称为头结点。头结点的数据域可不存储任何信息，也可存储线性表长度等附加信息；头结点的指针域存储指向第一个结点的指针（即第一个元素结点的存储位置）。

线性表的链式存储结构**没有顺序存储结构的缺点，但同时也失去了顺序表可随机存取的优点**。

优点：
- **通过不连续存储，避免了插入、删除元素时移动元素的线性开销**。
- **动态分配内存空间，不会造成内存的浪费**。

缺点：
- **属于顺序存取结构，随机存取效率低**。
- **链式存储不利于管理和维护**。

### 3.2. 基本操作

#### 3.2.1. 插入元素

假设要在线性表的两个数据元素 X 和 Y 之间插入一个数据元素 Z，已知 p 为单链表存储结构中指向结点的指针。为插入数据元素 Z，首先要生成一个数据域为 Z 的结点，然后插入到单链表中。根据单链表的逻辑定义，还需修改结点 X 中的指针域，令其指向结点 Z，而结点 Z 中的指针域应指向结点 Y。

![image](http://img.cdn.firejq.com/jpg/2018/2/21/018b4bfb80b56afb9a7fff49f6f2dbcc.jpg)

```cpp
template<class T>
bool LinearList::Insert(int k, const T& x) {
  if (k < 0)
    throw OutOfBounds();
  LinkNode<T> * p = first;
  for (int index = 1; index < k && p; index ++) 
    p = p->link;
  if (k > 0 && !p)
    throw OutOfBounds();
  LinkNode<T> * y = new LinkNode<T>;
  y->data = x;
  if (k) {
    y->link = p->link;
    p->link = y;
  } else {
    y->link = first;
    first = y;
  }
  if (!y->link)
    last = y;
  
  return true;
}
```
时间复杂度为 O(n)。

#### 3.2.2. 删除元素

反之，在线性表中删除元素 Y 时，仅需修改结点 X 中的指针域来实现链表中逻辑关系的变化即可。

![image](http://img.cdn.firejq.com/jpg/2018/2/21/91d546e276548cc2420c8b062555541f.jpg)

```cpp
// 不使用虚拟头结点
// 时间复杂度：O(n)，空间复杂度：O(1)
ListNode* removeElements(ListNode* head, int val) {
    // 需要对头结点进行特殊处理
    while (head != NULL && head->val == val) {
        ListNode* node = head;
        head = head->next;
        delete node;
    }
    if (head == NULL)
        return head;

    ListNode* cur = head;
    while (cur->next != NULL) {
        if (cur->next->val == val) {
            ListNode* delNode = cur->next;
            cur->next = delNode->next;
            delete delNode;
        }
        else
            cur = cur->next;
    }
    return head;
}
```

```cpp
// 使用虚拟头结点，从而不用对实际的头节点做特殊处理
// 时间复杂度：O(n)，空间复杂度：O(1)
ListNode* removeElements(ListNode* head, int val) {
    // 创建虚拟头结点
    ListNode* dummyHead = new ListNode(0);
    dummyHead->next = head;

    ListNode* cur = dummyHead;
    while(cur->next != NULL){
        if(cur->next->val == val){
            ListNode* delNode = cur->next;
            cur->next = delNode->next;
            delete delNode;
        }
        else
            cur = cur->next;
    }

    ListNode* retNode = dummyHead->next;
    delete dummyHead;

    return retNode;
}
```

#### 3.2.3. 反转链表

使用 3 个指针 pre、cur、next，从头遍历链表：
```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

// 非递归实现
// 时间复杂度：O(n)，空间复杂度：O(1)
ListNode* reverseList(ListNode* head) {
    ListNode* pre = NULL;
    ListNode* cur = head;
    while(cur != NULL){
        ListNode* next = cur->next;
        cur->next = pre;
        pre = cur;
        cur = next;
    }
    // 返回新的头指针
    return pre;
}

// 递归实现
// 时间复杂度：O(n)，空间复杂度：O(1)
ListNode* reverseList(ListNode* head) {
    // 递归终止条件
    if(head == NULL || head->next == NULL)
        return head;

    ListNode* rhead = reverseList(head->next);

    // head->next 此刻指向 head 后面的链表的尾节点
    // head->next->next = head 把 head 节点放在了尾部
    head->next->next = head;
    head->next = NULL;

    return rhead;
}
```

### 3.3. 双向链表

**在需要频繁地同时访问前驱和后继结点时，可采用另一种链表结构，即双向链表**。所谓双向链表，就是每个结点都有两个指针域，一个指向直接后继结点，另一个指向直接前驱结点。**相比单向链表，对于表的前项操作更加方便**。

在双向链表中，若 p 为指向表中某结点的指针，则显然有 p->next->prior=p->prior->next=p。对双向链表进行插入和删除时需同时修改两个方向的指针，两者时间复杂度均为 O(n)。

![image](http://img.cdn.firejq.com/jpg/2018/2/21/ceb2ed3cac169ef01bdfbfff12d4150d.jpg)

![image](http://img.cdn.firejq.com/jpg/2018/2/21/bd9e9c233b0c31b836002249aca3780c.jpg)

## 4. 线性表应用

### 4.1. 多项式问题

#### 4.1.1. 多项式表示

对于一元 n 次多项式：

![image](http://img.cdn.firejq.com/jpg/2018/2/22/def46e6cab4e4a4d7398b8ebf64a353d.jpg)

其中 pi 是指数为 ei 的项的非零系数，且满足 0 ≤ e1 < e2 < ... < em ＝ n。

可采用一个长度为 m 且每个元素有两个数据项（系数项和指数项）的线性表 `Pn(x)：((p1, e1), (p2, e2), ..., (pm, em))` 来存储。

**在实际应用程序中，若只对多项式进行“求值”等不改变多项式的系数和指数的运算，则采用类似于顺序表的顺序存储结构即可，否则应采用链式存储表示。**

例：基于链式存储线性表的多项式类定义。

![image](http://img.cdn.firejq.com/jpg/2018/2/22/16cee276325047d9d77f465016abd8fd.jpg)

#### 4.1.2. 多项式相加

多项式相加的运算规则如下：

1. 先创建“和多项式 C”的头结点，并用指针 p、q、r 分别指向多项式 A、多项式 B 以及和多项式 C 的头结点。
1. p、q 从 A、B 两个链表的第一个结点开始，比较它们所指向结点的指数值，**复制指数值*较小*的结点并将其链接到 r 所指单链表的尾结点**。
  
    若所指两个结点的指数值相等，且它们的系数值相加后不为零，则**以该相加值和指数值为数据域值创建新的结点，并链接到 r 所指链表的尾结点**。
1. 按照上述步骤进行**并逐一移动 p、q 指针，直至 p、q 中有一个走到对应链表的尾结点为止**，然后将未扫描完的多项式链表的结点复制并链接到 r 所指的和多项式 C 的尾结点之后，则整个相加过程结束。

![image](http://img.cdn.firejq.com/jpg/2018/2/22/4a1f6acde9dc728a28b28838788fce41.jpg)

### 4.2. 约瑟夫环（Josephus 问题）

描述：n 个人（编号 1~n）围成一个圈，从 1 开始报数，报到 m 的退出，剩下的人继续从 1 开始报数。不断循环直到只剩下最后一个人（胜利者），求胜利者的编号。

- 解法一：**用循环链表模拟整个过程，得到最后的胜利者**，时间复杂度为 O(n*m)。

  - 用自定义链表实现
    ```cpp
    struct ListNode
    {
      int num;        // 编号
      ListNode *next; // 下一个
      ListNode(int n = 0, ListNode *p = NULL) 
      { num = n; next = p;}
    };

    // 自定义链表实现
    int JosephusProblem_Solution1(int n, int m)
    {
      if(n < 1 || m < 1)
        return -1;

      ListNode *pHead = new ListNode(); // 头结点
      ListNode *pCurrentNode = pHead;   // 当前结点
      ListNode *pLastNode = NULL;       // 前一个结点
      unsigned i;

      // 构造环链表
      for(i = 1; i < n; i++)
      {
        pCurrentNode->next = new ListNode(i);
        pCurrentNode = pCurrentNode->next;
      }
      pCurrentNode->next = pHead;

      // 循环遍历
      pLastNode = pCurrentNode;
      pCurrentNode = pHead;

      while(pCurrentNode->next != pCurrentNode)
      {
        // 前进 m - 1 步
        for(i = 0; i < m-1; i++)
        {
          pLastNode = pCurrentNode;
          pCurrentNode = pCurrentNode->next;
        }
        // 删除报到 m - 1 的数
        pLastNode->next = pCurrentNode->next;
        delete pCurrentNode;
        pCurrentNode = pLastNode->next;
      }
      // 释放空间
      int result = pCurrentNode->num;
      delete pCurrentNode;

      return result;
    }
    ```

  - 用 STL 的 list 实现
    ```cpp
    // 使用标准库
    int JosephusProblem_Solution2(int n, int m)
    {
      if(n < 1 || m < 1)
        return -1;

      list<int> listInt;
      unsigned i;
      // 初始化链表
      for(i = 0; i < n; i++)
        listInt.push_back(i);

      list<int>::iterator iterCurrent = listInt.begin();
      while(listInt.size() > 1)
      {
        // 前进 m - 1 步
        for(i = 0; i < m-1; i++)
        {
          if(++iterCurrent == listInt.end())
            iterCurrent = listInt.begin();
        }
        // 临时保存删除的结点
        list<int>::iterator iterDel = iterCurrent;
        if(++iterCurrent == listInt.end())
          iterCurrent = listInt.begin();
        // 删除结点
        listInt.erase(iterDel);
      }

      return *iterCurrent;
    }
    ```

- 解法二：**通过数学推导得出递推公式，直接求得最后胜利者**，时间复杂度为 O(n)。

  递推公式（第 i 个出列的人的序号为 f[i]）:
  ```
  f[1] = 0
  f[i] = (f[i-1] + m) % i (i > 1)
  ```

  NOTE: 下边两段代码都是编号从 0 开始，也就是说如果编号从 1 开始，最后输出结果要加 1。

  - 迭代实现（非递归实现）
    ```cpp
    int josephus(int n, int m) { 
        int s = 0;
        for (int i = 2; i <= n; i++)
        	s = (s + m) % i;
        return s;
    }
    ```
  - 递归实现 
    ```cpp
    int josephus_recursion(int n, int m) {
        return n > 1 ? (josephus_recursion(n - 1, m) + m) % n : 0;
    }
    ```

  输出结果：
  ```cpp
  int main () {
      int n, m;
      cin>>n>>m;
      cout<<josephus(n, m) + 1<<‘ ’<<josephus_recursion(n, m)<<endl;
  }
  ```

## 5. Refer Links