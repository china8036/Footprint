- [数据结构：树结构 - 线索二叉树](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E7%BB%93%E6%9E%84---%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91)
  - [1. 基本概念](#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
  - [2. 基本操作](#2-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)
    - [2.1. 线索化二叉树](#21-%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91)
      - [2.1.1. 中序线索化](#211-%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96)
      - [2.1.2. 前序线索化](#212-%E5%89%8D%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96)
      - [2.1.3. 后序线索化](#213-%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96)
      - [2.1.4. 线索二叉树的遍历（非递归实现）](#214-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%89)
      - [2.1.5. 线索二叉树的查找](#215-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE)
        - [2.1.5.1. 中序线索二叉树中的查找](#2151-%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE)
        - [2.1.5.2. 后序线索二叉树中的查找](#2152-%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE)
        - [2.1.5.3. 前序线索二叉树中的查找](#2153-%E5%89%8D%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE)
      - [2.1.6. 线索二叉树的更新](#216-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9B%B4%E6%96%B0)
  - [3. Refer Links](#3-refer-links)

# 数据结构：树结构 - 线索二叉树

## 1. 基本概念

**具有 n 个结点的二叉链表中，其二叉链表的 n 个结点中共有 2n 个指针域，在这 2n 个指针域中，真正用于指向后件（左子结点或右子结点）的指针域只有 n-1 个，而另外的 n+1 个指针域（叶子结点的指针域）都是空的。**

因此，可利用二叉链表中的空指针域，存放指向结点在某种遍历次序下的前趋和后继结点的指针（这种附加的指针称为 " **线索** " ），这种加上了线索的二叉链表称为线索链表，相应的二叉树称为**线索二叉树** (ThreadedBinaryTree) 。线索链表解决了二叉链表能找到结点的左、右孩子，但无法直接找到该结点在某种遍历序列中的前驱、后继结点的问题。

根据线索性质的不同，线索二叉树可分为
- 前序线索二叉树
- 中序线索二叉树
- 后序线索二叉树

线索链表中的结点结构为：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/23/241439433ca75d2a0d285e13e8321a0b.jpg)

其中：
- lTag = 0，lChild 域指示结点的左孩子；lTag = 1，lChild 域指示结点的前驱；
- rTag = 0，rChild 域指示结点的右孩子；rTag = 1，rChild 域指示结点的后继。

## 2. 基本操作

### 2.1. 线索化二叉树

https://www.youtube.com/watch?v=qjAfV1XBRpQ

对二叉树以某种次序遍历使其变为线索二叉树的过程叫作线索化。

#### 2.1.1. 中序线索化

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/23/90ca69b5fbc173fb645a954ad9a1e09b.jpg)

- 递归
  ```cpp
  enum pointerTag{link, thread};

  template<typename T>
  struct thrTreeNode {
    T value;
    thrTreeNode<T> * lchild;
    thrTreeNode<T> * rchild;
    pointerTag lTag;
    pointerTag rTag;
  };

  template<typename T>
  class thrBinTree {
  public:
    thrBinTree(thrTreeNode<T> * r = NULL): root(r), pre(NULL){}
    void inOrderThreading(treeNode<T> * t);
    bool inOrderTra_thr();
  private:
    thrTreeNode<T> * root;// 不变，线索二叉树的根节点
    thrTreeNode<T> * pre;// 会变，作为全局变量，始终表示遍历时上一个访问的结点
    void inThreading(treeNode<T> * t);// 作为内调函数，递归实现线索化过程
  };

  template<typename T>
  void thrBinTree<T>::inOrderThreading(thrTreeNode<T> * thr_t) {
    /*对线索二叉树的根节点进行初始化*/
  this->root = new thrTreeNode<T>();
    this->root->lTag = link;
    this->root->rTag = thread;
    this->root->rchild = this->root;// 右指针回指
    if (!thr_t)
  this->root->lchild = this->root;// 若二叉树为空，则左指针也回指
    else {
      this->root->lchild = t_thr;// 若二叉树不为空，左指针指向普通二叉树的根
      this->pre = this->root;// 初始化 pre
      
      this->inThreading(t);// 内调递归函数，从根节点开始实现中序遍历线索化的过程
      
      // 线索化完毕，将最后一个遍历的结点指回根节点，
      // 将根结点的右指针指向最后一个结点，成功构造双向线索链表
      this->pre->rTag = thread;
      this->pre->rchild = this->root;
      this->root->rchild = this->pre;
    }
  }

  template<typename T>
  void thrBinTree<T>::inThreading(thrTreeNode<T> * thr_t) {
    if (t) {
      inThreading(t_thr->lchild);// 先线索化左子树
          
      if (!t_thr->lchild) {
        t_thr->lTag = thread;
        t_thr->lchild = pre;
      }
      if (!pre->rchild) {
        pre->rTag = thread;
        pre->rchild = t_thr;
      }
      pre = t_thr;

      inThreading(t_thr->rchild);// 最后线索化右子树
    }
  }
  ```

- 非递归（利用栈）

  http://luoyafei.blog.51cto.com/10731357/1767450

  ```cpp
  template<class T>
  void BinaryTreeThd<T>::InOrderThreading_NonR()// 中序线索化二叉树 -- 非递归
  {
      // 栈实现中序线索化
      stack<Node*> s;
      Node* prev = NULL;
      Node* cur = _root;
      if (cur == NULL)
      {
          return;
      }
      while (cur || !s.empty())
      {
          while(cur)// 找到最左结点，入栈
          {
              s.push(cur);
              cur = cur->_left;
          }//cur 不为空进栈，cur 为空说明 cur 已经线索化了
          cur = s.top();// 循环进入使 cur 为栈顶元素并判断是否需要线索化
          if (cur->_left == NULL)
          {
              cur->_leftTag = THREAD;
              cur->_left = prev;
          }
          s.pop();// 弹出栈顶元素，使栈顶保存需要线索化的 cur 的后继
          prev = cur;
          if (cur->_right == NULL && !s.empty())
          {
              cur->_rightTag = THREAD;
              cur->_right = s.top();
              cur = NULL;// 设置 cur 为空，防止死循环（2）
          }
          else
          {
              cur = cur->_right;// 线索化跳到右子树进行
          }
      }
  }
  ```

P.S.

前序线索化和后序线索化算法与二叉树的中序线索化类似。

#### 2.1.2. 前序线索化

```cpp
template<typename T>
void thrBinTree<T>::preThreading(thrTreeNode<T> * thr_t) {
	if (t) {
		if (!t_thr->lchild) {
			t_thr->lTag = thread;
			t_thr->lchild = pre;
		}
		if (!pre->rchild) {
			pre->rTag = thread;
			pre->rchild = t_thr;
		}
		pre = t_thr;

    preThreading (t_thr->lchild);// 线索化左子树
		preThreading (t_thr->rchild);// 线索化右子树
	}
}
```

#### 2.1.3. 后序线索化

```cpp
template<typename T>
void thrBinTree<T>::postThreading(thrTreeNode<T> * thr_t) {
	if (t) {
postThreading (t_thr->lchild);// 线索化左子树
		postThreading (t_thr->rchild);// 线索化右子树

		if (!t_thr->lchild) {
			t_thr->lTag = thread;
			t_thr->lchild = pre;
		}
		if (!pre->rchild) {
			pre->rTag = thread;
			pre->rchild = t_thr;
		}
		pre = t_thr;
	}
}
```

#### 2.1.4. 线索二叉树的遍历（非递归实现）

遍历某种次序的线索二叉树，只要从该次序下的开始结点开发，反复找到结点在该次序下的后继，直至终端结点。

- 中序遍历（中序）线索二叉树
  ```cpp
  template<typename T>
  bool thrBinTree<T>::inOrderTra_thr() {
    if (!this->root) return false;
    thrTreeNode<T> * p = this->root->lchild;
    
    while (p != this->root) {
      while (p->lTag != thread) p = p->lchild;// 每次都找到最左的结点才开始遍历，符合中序遍历的次序
      cout<<p->value<<' ';// 访问第一个结点（最左的结点）

      while (p->rTag == thread && p->rchild != this->root) {
        // 访问后继结点
        p = p->rchild;
        cout<<p->value<<' ';
      }
      p = p->rchild;
    }
    return true;
  }
  ```

- 前序遍历（前序）线索二叉树
  ```cpp
  template<class T>  
  void preOrderTra_thr () {
    if (!this->root) return false;
    thrTreeNode<T> * p = this->root->lchild;
    while (p != this->root) {// 回到根节点之前不断循环
      cout<<p->value<<’ ‘;// 访问 p 结点
      if (p->lTag == link && p->lchild) p = p->lchild;// 若有左孩子，p 指向左孩子
      else p = p->rchild;// 若没有左孩子，p 指向右孩子或后继结点
  }
  ```

- 后序遍历（后序）线索二叉树
  ```cpp
  template<class T>  
  void posthtraverse(tbtnode<T> *tbt)  
  {  
      tbtnode<T> *h;  
      if (tbt == NULL) return;  
      h = tbt;  
  }  
  ```

#### 2.1.5. 线索二叉树的查找

##### 2.1.5.1. 中序线索二叉树中的查找

- 在中序线索二叉树中，查找结点 *p 的中序后继结点

  在中序线索二叉树中，查找结点 *p 的中序后继结点分两种情形：
  - 若 *p 的右子树空 ( 即 p->rtag 为 Thread) ，则 p->rchild 为右线索，直接指向 *p 的中序后继。
  - 若 *p 的右子树非空 ( 即 p->rtag 为 Link) ，则 *p 的中序后继必是其右子树中第一个中序遍历到的结点。也就是从 *p 的右孩子开始，沿该孩子的左链往下查找，直至找到一个没有左孩子的结点为止，该结点是 *p 的右子树中 “ 最左下 ” 的结点，即 *P 的中序后继结点。

  ```cpp
  BinThrNode *Inorderpre(BinThrNode *p)  
  {   // 在中序线索树中找结点*p 的中序前趋，设 p 非空  
      BinThrNode *q；  
      if (p->ltag==Thread) //*p 的左子树为空  
          return p->lchild； // 返回左线索所指的中序前趋  
      else{  
          q=p->lchild； // 从*p 的左孩子开始查找  
          while (q->rtag==Link)  
              q=q->rchild； // 右子树非空时，沿右链往下查找  
          return q； // 当 q 的右子树为空时，它就是最右下结点  
      } //end if  
  }  
  // 该算法的时间复杂度不超过树的高度 h ，即 O(h) 。
  ```

- 在中序线索二叉树中查找结点 *p 的中序前趋结点

  中序是一种对称序，故在中序线索二叉树中查找结点 *p 的中序前趋结点与找中序后继结点的方法完全对称。具体情形如下：
  - 若 *p 的左子树为空，则 p->1child 为左线索，直接指向 *p 的中序前趋结点；
  - 若 *p 的左子树非空，则从 *p 的左孩子出发，沿右指针链往下查找，直到找到一个没有右孩子的结点为止。该结点是 *p 的左子树中 “ 最右下 ” 的结点，它是 *p 的左子树中最后一个中序遍历到的结点，即 *p 的中序前趋结点。

  ```cpp
  BinThrNode *Inorderpre(BinThrNode *p)  
  {   // 在中序线索树中找结点*p 的中序前趋，设 p 非空  
      BinThrNode *q；  
      if (p->ltag==Thread) //*p 的左子树为空  
          return p->lchild； // 返回左线索所指的中序前趋  
      else{  
          q=p->lchild； // 从*p 的左孩子开始查找  
          while (q->rtag==Link)  
          q=q->rchild； // 右子树非空时，沿右链往下查找  
          return q； // 当 q 的右子树为空时，它就是最右下结点  
      } //end if  
  }
  ```   
  由上述讨论可知：对于非线索二叉树，仅从 *p 出发无法找到其中序前趋 ( 或中序后继 ) ，而必须从根结点开始中序遍历，才能找到 *p 的中序前趋 ( 或中序后继 ) 。线索二叉树中的线索使得查找中序前趋和中序后继变得简单有效。

- 在中序线索二叉树上查找任意结点在先序下的后继

  这一操作的实现依据是：若一个结点是某子树在中序下的最后一个结点，则它必是该子树在先序下的最后一个结点。该结论可以用反证法证明。

  下面就依据这一结论，讨论在中序线索二叉树上查找某结点在先序下后继结点的情况。设开始时，指向此某结点的指针为 p。
  - 若待确定先序后继的结点为分支结点，则又有两种情况：
    - 当 p->ltag=0 时，p->lchild 为 p 在先序下的后继；
    - 当 p->ltag=1 时，p->rchild 为 p 在先序下的后继。
  - 若待确定先序后继的结点为叶子结点，则也有两种情况：
    - 若 p->rchild 是头结点，则遍历结束；
    - 若 p->rchild 不是头结点，则 p 结点一定是以 p->rchild 结点为根的左子树中在中序遍历下的最后一个结点，因此 p 结点也是在该子树中按先序遍历的最后一个结点。此时， 若 p->rchild 结点有右子树， 则所找结点在先序下的后继结点的地址为 p->rchild->rchild；若 p->rchild 为线索，则让 p＝p->rchild，反复情况（2）的判定。
  ```cpp
  BiThrTree IPrePostNode（BiThrTree head,BiThrTree p）
  {
    /*在中序线索二叉树上寻找结点 p 的先序的后继结点，head 为线索树的头结点*/
    BiThrTree post;
    if (p->ltag==0) 
      post=p->lchild;
    else {
      post=p;
      while (post->rtag==1&&post->rchild!=head) 
        post=post->rchild;
      post=post->rchild;
    }
    return(post);
  }
  ```

- 在中序线索二叉树上查找任意结点在后序下的前驱

  这一操作的实现依据是：若一个结点是某子树在中序下的第一个结点，则它必是该子树在后序下的第一个结点。该结论可以用反证法证明。

  下面就依据这一结论，讨论在中序线索二叉树上查找某结点在后序下前驱结点的情况。设开始时，指向此某结点的指针为 p。
  - 若待确定后序前驱的结点为分支结点，则又有两种情况：
    - 当 p->ltag=0 时，p->lchild 为 p 在后序下的前驱；
    - 当 p->ltag=1 时，p->rchild 为 p 在后序下的前驱。
  - 若待确定后序前驱的结点为叶子结点，则也有两种情况：
    - 若 p->lchild 是头结点，则遍历结束；
    - 若 p->lchild 不是头结点，则 p 结点一定是以 p->lchild 结点为根的右子树中在中中序遍历下的第一个结点，因此 p 结点也是在该子树中按后序遍历的第一个结点。此时，若 p->lchild 结点有左子树， 则所找结点在后序下的前驱结点的地址为 p->lchild->lchild；若 p->lchild 为线索，则让 p＝p->lchild，反复情况（2）的判定。
  ```cpp
  BiThrTree IPostPretNode（BiThrTree head,BiThrTree p）
  {
    /*在中序线索二叉树上寻找结点 p 的先序的后继结点，head 为线索树的头结点*/
    BiThrTree pre;
    if (p->rtag==0) 
      pre=p->rchild;
    else {
      pre=p;
      while (pre->ltag==1&& post->rchild!=head) 
        pre=pre->lchild;
      pre=pre->lchild;
    }
    return(pre);
  }
  ```

- 在中序线索二叉树上查找值为 x 的结点

  利用在中序线索二叉树上寻找后继结点和前驱结点的算法，就可以遍历到二叉树的所有结点。比如，先找到按某序遍历的第一个结点，然后再依次查询其后继；或先找到按某序遍历的最后一个结点，然后再依次查询其前驱。这样，既不用栈也不用递归就可以访问到二叉树的所有结点。

  在中序线索二叉树上查找值为 x 的结点，实质上就是在线索二叉树上进行遍历，将访问结点的操作具体写为那结点的值与 x 比较的语句。

  ```cpp
  BiThrTree Search (BiThrTree head,elemtype x)
  {
    /*在以 head 为头结点的中序线索二叉树中查找值为 x 的结点*/
    BiThrTree p;
    p=head->lchild;
    while (p->ltag==0&&p!=head) 
      p=p->lchild;
    while(p!=head && p->data!=x) 
      p=InPostNode(p);
    if (p==head) {
      printf(“Not Found the data!\n”);
      return(0);
    } else
      return(p);
  }
  ```

##### 2.1.5.2. 后序线索二叉树中的查找

- 在后序线索二叉树中，查找指定结点 *p 的后序前趋结点

  在后序线索二叉树中，查找指定结点 *p 的后序前趋结点的具体规律是：
  - 若 *p 的左子树为空，则 p->lchild 是前趋线索，指示其后序前趋结点。
  - 若 *p 的左子树非空，则 p->lchild 不是前趋线索。由于后序遍历时，根是在遍历其左右子树之后被访问的，故 *p 的后序前趋必是两子树中最后一个遍历结点。
  
  当 *p 的右子树非空时， *p 的右孩子必是其后序前趋；当 *p 无右子树时， *p 的后序前趋必是其左孩子。

- 在后序线索二叉树中，查找指定结点 *p 的后序后继结点

  具体的规律：
  - 若 *p 是根，则 *p 是该二叉树后序遍历过程中最后一个访问到的结点。 *p 的后序后继为空；
  - 若 *p 是其双亲的右孩子，则 *p 的后序后继结点就是其双亲结点
  - 若 *p 是其双亲的左孩子，但 *P 无右兄弟， *p 的后序后继结点是其双亲结点；
  - 若 *p 是其双亲的左孩子，但 *p 有右兄弟，则 *p 的后序后继是其双亲的右子树中第一个后序遍历到的结点，它 是该子树中 “ 最左下的叶结点 ” ；

  由上述讨论中可知：在后序线索树中，仅从 *p 出发就能找到其后序前趋结点；要找 *p 的后序后继 结点，仅当 *p 的右子树为空时，才能直接由 *p 的右线索 p->rchild 得到。否则必须知道 *p 的双亲结点才能找到其后序后继。因此，如果线索二叉树中的结点没有指向其双亲结点的指针，就可能要从根开始进行后序遍历才能找到结点 *P 的后序后继。由此，线索对查找指定结点的后序后继并无多大帮助。

##### 2.1.5.3. 前序线索二叉树中的查找

- 在前序线索二叉树中，查找指定结点 *p 的前序后继结点

- 在前序线索二叉树中，查找指定结点 *p 的前序前趋结点
  
  在前序线索二叉树中，找某一点 *p 的前序后继也很简单，仅从 *p 出发就可以找到；但找其前序前趋 也必须知道 *p 的双亲结点。当树中结点未设双亲指针时，同样要进行从根开始的前序遍历才能找到结点 *p 的前序前趋。

#### 2.1.6. 线索二叉树的更新

线索二叉树的更新是指，在线索二叉树中插入一个结点或者删除一个结点。一般情况下，这些操作有可能破坏原来已有的线索，因此，在修改指针时，还需要对线索做相应的修改。一般来说，这个过程的代价几乎与重新进行线索化相同。这里仅讨论一种比较简单的情况，即在中序线索二叉树中插入一个结点 p，使它成为结点 s 的右孩子。

下面讨论中序线索二叉树的更新，分两种情况来分析：

- 若 s 的右子树为空，如图 6.13 (a) 所示，则插入结点 p 之后成为图 6.13 (b) 所示的情形。在这种情况中，s 的后继将成为 p 的中序后继，s 成为 p 的中序前驱，而 p 成为 s 的右孩子。二叉树中其它部分的指针和线索不发生变化。

- 若 s 的右子树非空，如图 6.14 (a) 所示，插入结点 p 之后如图 6.14 (b) 所示。S 原来的右子树变成 p 的右子树，由于 p 没有左子树，故 s 成为 p 的中序前驱，p 成为 s 的右孩子；又由于 s 原来的后继成为 p 的后继，因此还要将 s 原来的本来指向 s 的后继的左
线索，改为指向 p。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/23/a9ad631d77055d03bc007d83ced2d72b.jpg)

```cpp
void InsertThrRight(BiThrTree s,BiThrTree p) {
  /* 在中序线索二叉树中插入结点 p 使其成为结点 s 的右孩子 */
  BiThrTree w;
  p->rchild=s->rchild;
  p->rtag=s->rtag;
  p->lchild=s;
  p->ltag=1; /*将 s 变为 p 的中序前驱*/
  s->rchild=p;
  s->rtag=0; /*p 成为 s 的右孩子*/
  if(p->rtag==0) {
    /*当 s 原来右子树不空时，找到 s 的后继 w，变 w 为 p 的后继，p 为 w 的前驱*/
    w=InPostNode(p);
    w->lchild=p;
  }
}
```

## 3. Refer Links

http://waret.iteye.com/blog/709779 

https://my.oschina.net/woshixiaomayi/blog/607605  

http://c.biancheng.net/cpp/html/982.html 