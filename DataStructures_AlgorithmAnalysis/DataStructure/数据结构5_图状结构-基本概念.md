- [数据结构：图结构 - 基本概念](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9B%BE%E7%BB%93%E6%9E%84---%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
  - [1. 基本概念](#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [1.1. 图的二元组定义](#11-%E5%9B%BE%E7%9A%84%E4%BA%8C%E5%85%83%E7%BB%84%E5%AE%9A%E4%B9%89)
    - [1.2. 有向图和无向图](#12-%E6%9C%89%E5%90%91%E5%9B%BE%E5%92%8C%E6%97%A0%E5%90%91%E5%9B%BE)
    - [1.3. 度](#13-%E5%BA%A6)
    - [1.4. 稀疏图和稠密图](#14-%E7%A8%80%E7%96%8F%E5%9B%BE%E5%92%8C%E7%A8%A0%E5%AF%86%E5%9B%BE)
    - [1.5. 图的分类](#15-%E5%9B%BE%E7%9A%84%E5%88%86%E7%B1%BB)
    - [1.6. 子图和补图](#16-%E5%AD%90%E5%9B%BE%E5%92%8C%E8%A1%A5%E5%9B%BE)
    - [1.7. 图的同构](#17-%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84)
    - [1.8. 通路与回路](#18-%E9%80%9A%E8%B7%AF%E4%B8%8E%E5%9B%9E%E8%B7%AF)
    - [1.9. 连通与可达](#19-%E8%BF%9E%E9%80%9A%E4%B8%8E%E5%8F%AF%E8%BE%BE)
    - [1.10. 生成树](#110-%E7%94%9F%E6%88%90%E6%A0%91)
  - [2. 存储结构](#2-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
    - [2.1. 邻接矩阵](#21-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5)
    - [2.2. 邻接表](#22-%E9%82%BB%E6%8E%A5%E8%A1%A8)
    - [2.3. 十字链表（有向图）](#23-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%89)
    - [2.4. 邻接多重表（无向图）](#24-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89)
  - [3. 无权图的应用](#3-%E6%97%A0%E6%9D%83%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8)
    - [3.1. 魔棒抠图 Flood Fill](#31-%E9%AD%94%E6%A3%92%E6%8A%A0%E5%9B%BE-flood-fill)
    - [3.2. 扫雷](#32-%E6%89%AB%E9%9B%B7)
    - [3.3. 走迷宫](#33-%E8%B5%B0%E8%BF%B7%E5%AE%AB)
    - [3.4. 生成迷宫](#34-%E7%94%9F%E6%88%90%E8%BF%B7%E5%AE%AB)
    - [3.5. 地图填色](#35-%E5%9C%B0%E5%9B%BE%E5%A1%AB%E8%89%B2)
  - [4. 有权图的应用](#4-%E6%9C%89%E6%9D%83%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8)
    - [4.1. AOV 和 AOE](#41-aov-%E5%92%8C-aoe)
    - [4.2. 最小生成树](#42-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91)
    - [4.3. 最短路径](#43-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84)
  - [5. Refer Links](#5-refer-links)

# 数据结构：图结构 - 基本概念

图是一种比树更复杂的非线性结构。在这种结构中，任意两个结点之间都可能存在关系，即结点之间的连接关系是任意的，因此图可用来描述更加复杂的数据对象。

## 1. 基本概念

### 1.1. 图的二元组定义

**图 G 由两个集合 V 和 E 组成，记为 G=(V, E)**。其中，V 是顶点（Vertex，图中的数据元素）的有穷非空集合，E 是 V 中顶点对（也称为边，表示两个顶点之间的关系）的有穷集。通常，也将图 G 的顶点集和边集分别记为 V(G) 和 E(G)。E(G) 可以是空集，若 E(G) 为空，则图 G 只有顶点而没有边。

### 1.2. 有向图和无向图

- 有向图 Directed Graph

  若图 G 中的每条边都是有方向的，则称 G 为有向图（digraph）。在有向图中，一条有向边是由两个顶点组成的有序对，有序对通常用尖括号表示，一个有向图可表示为：D=<V, E>。

  **有向边也称为弧（arc），边的始点称为弧尾（tail），终点称为弧头（head）**。例如，<vi, vj>表示一条有向边，vi 是边的始点（起点），vj 是边的终点。因此，<vi, vj>和<vj, vi>是两条不同的有向边。

- 无向图 Undirected Graph

  若图 G 中的每条边都是没有方向的，则称 G 为无向图（undigraph）。无向图中的边均是顶点的无序对，无序对通常用圆括号表示，一个无向图可以表示为：G=(V, E)。

- 平行边：如果关联一对结点的边多于一条，则称这些边为平行边。

- 邻接：如果有边关联于一对结点，则称这对结点是邻接的（**邻接是针对结点的概念，而不是针对边的概念**）。

- 环：一条边的两个端点如果关联于同一个结点，则称为环。

- 孤立点：和任何边都不关联的点称为孤立点。

- **n 阶图：n 个顶点的图**。

- **零图：E 为空集的图，即只有顶点没有边的图**。

- **平凡图：1 阶零图，即只有 1 个顶点没有边的图**。

- **空图：V 为空集的图，即没有顶点也没有边的图**。

### 1.3. 度

- 度：设 G=<V,E>为无向图，v ∈ V, **v 所关联的边数称为 v 的度数**，简称度，记作 d(v)。注：**在无向图中每个环提供给它的结点 2 度**。

- 悬挂顶点：度数为 1 的顶点。

- 悬挂边：与悬挂顶点关联的边。

- **握手定理：任何图中所有结点的度数之和为边数的两倍**。

### 1.4. 稀疏图和稠密图

- 稀疏图 (Sparse Graph)：**当图中边的个数远小于该图所能拥有的最大边数时，称为稀疏图**。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/17/905efc361deb665099ac9927efc411e6.jpg)

- 稠密图 (Dense Graph)：**当图中边的个数接近于该图所能拥有的最大边数时，称为稠密图**。当图中边的个数等于该图所能拥有的最大边数时，称为**完全图**。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/17/6dbfb4aca86b8beecbb19bfad99c8785.jpg)

### 1.5. 图的分类

- 简单图：设图 G=（V，E）为无向图或有向图，如果 G 中**不含平行边，也不含环**，则称为简单图。

- 多重图：设图 G=（V，E）为无向图或有向图，如果 G 中**含有平行边**，则称为多重图。

- 完全图
  - 无向完全图：设 G =（V，E）是 n 阶无向简单图，若 **G 中任何结点都与其余的 n-1 个结点相邻**，则称 G 为 n 阶无向完全图，记作 Kn。n 阶无向完全图中，每个结点的度数为 n-1，所有结点的总度数为 n(n-1)，边数为 n(n-1)/2。

  - 有向完全图：设 G =（V，E）为 n 阶有向简单图，若**对于 V 中任意的两个结点 u 和 v，既有有向边<u，v>，又有有向边<v，u>**，则称 G 是 n 阶有向完全图。n 阶有向完全图中，每个结点的度数为 n-1，所有结点的总度数为 n(n-1)，边数为 n(n-1)。

  **无特别说明时，完全图均指无向完全图。**n 阶完全图的总边数和总度数都是确定的。

- 正则图：设 G 为 n 阶无向简单图，若对于任意 v ∈ V（G），均有 d(v)=k, 则称 G 为 k - 正则图，即 k - 正则图中每个结点的度数都等于 k。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/fcea8216d1e0a11f6a65b636858108a9.jpg)

- 环图：如果图 G =（V，E）的结点集 V={v1, v2, ..., vn}（n >= 3），边集 E={(v1, v2), (v2, v3), , ( vn-1, vn), (vn, v1)}，则称 G 为环图，记为 Cn。环图都是 2 - 正则图。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/12d046cec77472d8e4c19928090f7012.jpg)

- 轮图：当给环图 Cn-1（n >= 4）添加一个结点，并把这个结点和 Cn-1 里的每个结点逐个连接后得到的图成为轮图，记作 Wn。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/d608c08b4dd74cb74920e976ba8604e3.jpg)

- 方体图：如果图 G =（V，E）有 2^n 个结点，每个结点表示一个长度为 n 的位串，任何两个相邻的结点表示的位串只有一位不同，则称 G 称为 n 方体图，记作 Qn。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/9ffdcf42db33caf1d5def7e8cd822d8e.jpg)

- 二分图：如果图 G =（V，E）的结点集 V 能划分为两个子集：V1 和 V2，使每条边有一个端点在 V1 中，另一个端点在 V2 中，则称该图为二分图（或二部图）。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/1b70f42ead3e89de6c7516fd3db95d27.jpg)

  - 完全二分图：二分图 G =（V，E）的结点集 V 能划分为两个子集：V1 和 V2，若 V1 中的每个结点和 V2 中的每个结点均有边相连，则称 G 为完全二分图。若|V1|=m，|V2|=n, 则可记为 Km,n。下图所示的是 K2,3 和 K3,3：

    ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/1b7ad9b984c8c7c1c12aaea380bc397f.jpg)

- 带权图 / 网：每个结点或每条边都带有数值的图称为带权图 / 网。

  下图左边为边带权图，右边为结点带权图：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/d8cd0279d932acf739119fc8ba3ea308.jpg)

- 欧拉图

  设 G=(V, E) 是无向图或有向图，若 G 中**有一条包含所有边（有向边）的简单回路**，则称该回路为欧拉回路，称图 G 为欧拉图。

  若 G 中有一条包含 G 中所有边（有向边）的简单通路，则称为欧拉通路，称图 G 为半欧拉图。

- 哈密顿图

  设 G=(V, E) 是无向图或有向图，若 G 中**有一条包含 G 中的每一个顶点一次且仅一次的回路**，则称该回路为哈密顿回路，称图 G 为哈密顿图。

  若图 G 有一条包含 G 的所有结点的通路，则称该通路为哈密顿通路，称图 G 为半哈密顿图。

### 1.6. 子图和补图

- 子图

  设 G =（V，E）和 G1=(V1，E1) 是两个图。
  - 子图：若 V1 ⊆V，且 E1 ⊆ E，则称 G1 是 G 的子图，G 是 G1 的母图，记作 G1 ⊆ G。　
  - 真子图：若 G1 ⊆ G 且 G1 != G( 即 V1 != V, 或 E1 != E )，则称 G1 是 G 的真子图。　　
  - 生成子图：若 G1 ⊆ G 且 V1 = V，则称 G1 是 G 的生成子图。

  NOTE: 两个完全相同的图有子图关系，也有生成子图关系。

  例：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/37bca8a198dd7dc635105beff87d83c7.jpg)
  ```
  (1),(2),(3) 是 (1) 的子图，(2),(3) 是真子图，(1) 是母图。
  (1),(3) 是 (1) 的生成子图。
  (2) 是{d,e,f }的导出子图，也是{e5, e6, e7}导出子图。
  (3) 是{e1, e3, e5, e7}的导出子图
  ```

- 补图  

  设 G=(V，E) 是 n 阶无向简单图或有向简单图。以 V 为结点，以所有能使 G 成为完全图需添加的边组成的集合为边集的图，称为 G 相对于完全图的补图，简称 G 的补图，记作 ~G。

  补图的应用：发表在 1958 年美国《数学月刊》上的一个数学问题：在任意 6 个人的集会上，总会有 3 个人互相认识或有 3 个人互相不认识（假设认识是相互的）。

### 1.7. 图的同构

设两个图 G=（V，E）和 G'=（V '，E'），如果从 V 到 V '存在双射函数 f，使得对于任意的 u，v ∈ V，(u，v) ∈ E, 当且仅当 (f(u)，f(v)) ∈ E' ；如果在 u，v 间存在平行边，则关联于结点 u，v 的平行边数与关联于结点 f(u)，f(v) 的平行边数相同，则称 G 与 G'是同构的。


由此可见，判断两个图同构的必要条件（不是两个图同构的充分条件）：
- 必须具有相同的顶点数。
- 必须具有相同的边数。
- 度数相同的结点数相等（对应顶点的度数相同）。
- 相同长度的回路数相同。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/c9d1532e2f14d8eefc3616e349b3b669.jpg)

### 1.8. 通路与回路

- 通路：给定图 G=（V，E）中，以 v0 为起点，vn 为终点的由结点和边交替出现的序列 v0e1v1e2v2…vn-1envn 称为从结点 v0 到 vn 的长度为 n 的通路。

  - 简单通路 / 迹：若通路中的**所有边互不相同**，则称它为简单通路或迹。

  - 基本通路 / 初级通路 / 路径：若通路中的**所有结点互不相同，所有边互不相同**，则称它为基本通路或初级通路、路径。 

- 回路：若一条通路的起点和终点是同一点，称它是一条回路。 

  - 简单回路 / 闭迹：若回路中的**所有边互不相同**，则称它为简单回路或闭迹。

  - 基本回路 / 初级回路 / 圈：若回路中的**所有结点互不相同，所有边互不相同**，则称它为基本回路或初级回路、圈。

### 1.9. 连通与可达

- 连通（无向图）

  若**无向图** G 中**任意两结点间都有一条通路**（长度 >= 1），则称 G 是连通图；否则，称 G 是非连通图。

  **连通属于等价关系，可用于有向图和无向图。**

- 可达

  设**有向图** G=（V,E）, 对于 G 中任意两个结点 u 和 v，若从 u 到 v 存在通路，则称 u 到 v 是可达的。若 u 可达 v 且 v 可达 u，则称 u 和 v 是相互可达的。

  **可达属于非等价关系（不具有对称性），仅可用于有向图。**

- 无向连通图

  **若无向连通图 G 有 n 个顶点，则 G 至少有 n-1 条边；当 G 的边数为 n-1 时，G 实际上是这 n 个顶点的一棵生成树**。

- 有向连通图：具有以下三种连通性中的任何一种的有向图称为有向连通图。

  - 单向连通：若 G 的任意两个结点间至少从一个结点到另一个结点是可达的，则称 G 是单向连通的。G 是单向连通的当且仅当 G 中存在经过所有顶点的通路。

  - 强连通：若 G 的任意两个结点间是互相可达的，则称 G 是强连通的。G 是强连通的当且仅当 G 中存在经过所有顶点的回路。

    - 强分图：每个 Vi 导出的子图 Gi 是强连通的，称为 G 的一个强分图。

  - 弱连通：若 G 在略去有向边的方向后所得到的无向图是连通的，则称 G 是弱连通的。

- 极大连通子图

  - 无向连通图中：一个无向连通图的极大连通子图为其本身（又称为连通分量）。

  - 有向连通图中：一个有向连通图的极大连通子图为其本身（又称为强连通分量）。

  - 非连通图中：非连通图有多个极大连通子图（说傻话就是分拨，连着的分一拨，每拨都是极大连通子图）。

- 极小连通子图

  - 无向连通图中：一个无向连通图的极小连通子图为其生成树。就像一个四边形，四个节点四条边，其实三条边就能连通了，所以四个节点三条边，就 OK 了，就是在能连通的前提下，把多余的边去掉。

  - 有向连通图中：有向连通图中不存在极小连通子图的概念。

  - 非连通图：非连通图中不存在极小连通子图的概念。

### 1.10. 生成树

- 生成树

  生成树表示一个无向图中符合特定条件的子图：V 表示顶点，E 表示边，若图 G = (V(G),E(G)) 和树 T = (V(T),E(T))，有 E(T) ⊂ E(G) 和 V(G) = V(T)，那么 T 是 G 的生成树。

  **一个连通图的生成树为该连通图的一个极小连通子图**。

- 最小生成树 / 最小权重生成树

  **一个连通图的生成树可能有多个。当连通图中的边具有权值时，权值之和最小的生成树称为最小生成树。广义上而言，对于非连通无向图来说，它的每一连通分量同样有最小生成树**。

  以有线电视电缆的架设为例，若只能沿著街道布线，则以街道为边，而路口为顶点，其中必然有一最小生成树能使布线成本最低。

## 2. 存储结构

**图的存储表示方法最常用的有 4 种，分别是邻接矩阵、邻接表、邻接多重表和十字链表表示法**，在使用过程中要根据具体的应用特点和相关操作来进行选择。

### 2.1. 邻接矩阵

邻接矩阵（adjacency matrix）是一种**用边的集合表示图**的方法，其中边的集合用一个**二维数组**表示，数组的每个元素表示一条边，元素的两个下标值分别表示边的两个端点的编号，结点编号与数组的下标相对应。

图的邻接矩阵可定义为：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/0724111edac794ff3a3c7fb4579d9ac8.jpg)

通过邻接矩阵，很容易判断任意两个顶点之间是否有边（或弧）相连，同时，也可以很方便地求得各个顶点的度。对于无向图，顶点 i 的度是邻接矩阵中第 i 行（或第 i 列）的元素之和；对于有向图，第 i 行的元素之和为顶点 vi 的出度 OD(vi)，第 j 列的元素之和为顶点 vj 的入度 ID(vj)。

- 例：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/17/35d93d37edee98f88eac5c6677d70075.jpg)

- 优缺点
  
  对于边数相对顶点较少的图，会造成极大的空间浪费。

  **在遍历某个节点的邻边时，需要 O(V) 的时间复杂度，开销较大**。

- 适用场景
  
  邻接矩阵适用于有向图和无向图，且由于其存储结构的特性，**适合用于表示稠密图 (Dense Graph)**。

- 代码实现
  ```java
  // 稠密图 - 邻接矩阵
  public class DenseGraph {
  	private int n;  // 节点数
  	private int e;  // 边数
  	private boolean isDirected;   // 是否为有向图
  	private boolean [][] g;      // 图的具体数据

  	// 构造函数
  	public DenseGraph(int n, boolean isDirected) {
  		assert n >= 0;
  		this.n = n;
  		this.e = 0;    // 初始化没有任何边
  		this.isDirected = isDirected;
  		// g 初始化为 n*n 的布尔矩阵, 每一个 g[i][j] 均为 false, 表示没有任何边
  		// false 为 boolean 型变量的默认值
  		g = new boolean[n][n];
  	}

  	public int V() {
  		return n; // 返回节点个数
  	}

  	public int E() {
  		return e; // 返回边的个数
  	}

  	// 向图中添加一个边
  	public void addEdge(int v, int w) {
  		assert v >= 0 && v < n;
  		assert w >= 0 && w < n;

  		if (hasEdge(v, w))
  			return;

  		g[v][w] = true;
  		if(!isDirected)
  			g[w][v] = true;

  		e++;
  	}

  	// 验证图中是否有从v到w的边
  	boolean hasEdge(int v, int w) {
  		assert v >= 0 && v < n;
  		assert w >= 0 && w < n;
  		return g[v][w];
  	}

  	// 返回图中一个顶点的所有邻边
  	// 由于java使用引用机制，返回一个Vector不会带来额外开销,
  	public Iterable<Integer> adj(int v) {
  		assert v >= 0 && v < n;
  		Vector<Integer> adjV = new Vector<>();
  		for (int i = 0; i < n; i ++)
  			if (g[v][i])
  				adjV.add(i);
  		return adjV;
  	}
  }
  ```

  ```cpp
  // 稠密图 - 邻接矩阵
  class DenseGraph {
  private:
      int n, m;       // 节点数和边数
      bool directed;  // 是否为有向图
      vector<vector<bool>> g; // 图的具体数据

  public:
      // 构造函数
      DenseGraph( int n , bool directed ){
          assert( n >= 0 );
          this->n = n;
          this->m = 0;    // 初始化没有任何边
          this->directed = directed;
          // g 初始化为 n*n 的布尔矩阵，每一个 g[i](j) 均为 false, 表示没有任和边
          g = vector<vector<bool>>(n, vector<bool>(n, false));
      }

      ~DenseGraph(){ }

      int V(){ return n;} // 返回节点个数
      int E(){ return m;} // 返回边的个数

      // 向图中添加一个边
      void addEdge( int v , int w ){

          assert( v >= 0 && v < n );
          assert( w >= 0 && w < n );

          if( hasEdge( v , w ) )
              return;

          g[v](w) = true;
          if( !directed )
              g[w](v) = true;

          m ++;
      }

      // 验证图中是否有从 v 到 w 的边
      bool hasEdge( int v , int w ){
          assert( v >= 0 && v < n );
          assert( w >= 0 && w < n );
          return g[v](w);
      }

      // 显示图的信息
      void show(){
          for( int i = 0 ; i < n ; i ++ ){
              for( int j = 0 ; j < n ; j ++ )
                  cout<<g[i](j)<<"\t";
              cout<<endl;
          }
      }

      // 不直接暴露内部变量 g，而是使用迭代器，使得外部访问不同图的实现接口完全相同
      // 邻边迭代器，传入一个图和一个顶点，迭代在这个图中和这个顶点向连的所有顶点
      class adjIterator{
      private:
          DenseGraph &G;  // 图 G 的引用
          int v;
          int index;

      public:
          // 构造函数
          adjIterator(DenseGraph &graph, int v): G(graph){
              assert( v >= 0 && v < G.n );
              this->v = v;
              this->index = -1;   // 索引从 -1 开始，因为每次遍历都需要调用一次 next()
          }

          ~adjIterator(){}

          // 返回图 G 中与顶点 v 相连接的第一个顶点
          int begin(){

              // 索引从 -1 开始，因为每次遍历都需要调用一次 next()
              index = -1;
              return next();
          }

          // 返回图 G 中与顶点 v 相连接的下一个顶点
          int next(){

              // 从当前 index 开始向后搜索，直到找到一个 g[v](index) 为 true
              for( index += 1 ; index < G.V() ; index ++ )
                  if( G.g[v](index) )
                      return index;
              // 若没有顶点和 v 相连接，则返回 -1
              return -1;
          }

          // 查看是否已经迭代完了图 G 中与顶点 v 相连接的所有顶点
          bool end(){
              return index >= G.V();
          }
      };
  };
  ```

### 2.2. 邻接表

邻接表 (adjacency list) 是图的顺序存储和链式存储相结合的一种存储方法，它是一种**用顶点表示图**的方法。该方法**对图 G 中的每个顶点 vi 建立一个单链表，将所有邻接于 vi 的顶点放到该链表中**。每个结点包含三个域：
- 邻接点域（adjvex），指示与顶点 vi 邻接的点的连接关系；
- 链域（nextarc），指示下一条边或弧的结点；
- 数据域（info），存储与边或弧相关的信息，如权值等。
每个链表上附设一个头结点，该结点除了设有链域（firstarc）指向链表中第一个结点之外，还设有存储顶点 vi 的名称或其他有关信息的数据域（data）。头结点通常采用顺序结构进行存储，以便进行随机访问。

- 例：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/e10ecebe96841bf8048ffdf2d18ca161.jpg)

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/89fe259a03d8e1b8f975be7d41098152.jpg)

- 逆邻接表

  为了便于确定顶点的入度或以顶点 vi 为头的弧，可建立一个有向图的逆邻接表，即对每个顶点 vi 建立一个链接以 vi 为头的弧的表。例如，下图所示为有向图 Gl 的逆邻接表：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/ec6de105ec5506c013e755262684774c.jpg)

- 优缺点

  在邻接表上找任意一个顶点的第一个邻接点和下一个邻接点比较容易，但要判定任意两个顶点 vi 和 vj 之间是否有边或有弧相连，则需搜索第 i 个或第 j 个链表，此操作不如邻接矩阵方便。

  **在遍历某个节点的邻边时，需要 O(E) 的时间复杂度，相比邻接矩阵效率更优**。

- 适用场景
  
  邻接表适用于有向图和无向图，相比邻接矩阵，邻接表更**适合用于表示稀疏图 (Sparse Graph)**。

- 代码实现
  ```java
  // 稀疏图 - 邻接表
  public class SparseGraph {

  	private int n;  // 节点数
  	private int e;  // 边数
  	private boolean isDirected;    // 是否为有向图
  	private ArrayList<Integer> [] g; // 图的具体数据

  	// 构造函数
  	public SparseGraph(int n, boolean isDirected) {
  		assert n >= 0;
  		this.n = n;
  		this.e = 0;    // 初始化没有任何边
  		this.isDirected = isDirected;
  		// g初始化为n个空的ArrayList, 表示每一个g[i]都为空, 即没有任何边
  		g = (ArrayList<Integer>[]) new ArrayList[n];
  		for (int i = 0; i < n; i ++)
  			g[i] = new ArrayList<>();
  	}

  	public int V() {
  		return n; // 返回节点个数
  	}

  	public int E() {
  		return e; // 返回边的个数
  	}

  	// 向图中添加一个边
  	public void addEdge(int v, int w) {
  		assert v >= 0 && v < n;
  		assert w >= 0 && w < n;

  		g[v].add(w);
  		if (v != w && !isDirected)
  			g[w].add(v);
  		e++;
  	}

  	// 验证图中是否有从v到w的边
  	boolean hasEdge(int v, int w) {
  		assert v >= 0 && v < n;
  		assert w >= 0 && w < n;

  		for (int i = 0; i < g[v].size(); i ++)
  			if (g[v].get(i) == w)
  				return true;
  		return false;
  	}

  	// 返回图中一个顶点的所有邻边
  	// 由于java使用引用机制，返回一个ArrayList不会带来额外开销
  	public Iterable<Integer> adj(int v) {
  		assert v >= 0 && v < n;
  		return g[v];
  	}
  }
  ```

  ```cpp
  // 稀疏图 - 邻接表
  class SparseGraph{

  private:
      int n, m;       // 节点数和边数
      bool directed;  // 是否为有向图
      vector<vector<int>> g;  // 图的具体数据

  public:
      // 构造函数
      SparseGraph( int n , bool directed ){
          assert( n >= 0 );
          this->n = n;
          this->m = 0;    // 初始化没有任何边
          this->directed = directed;
          // g 初始化为 n 个空的 vector, 表示每一个 g[i] 都为空，即没有任何边
          g = vector<vector<int>>(n, vector<int>());
      }

      ~SparseGraph(){ }

      int V(){ return n;} // 返回节点个数
      int E(){ return m;} // 返回边的个数

      // 向图中添加一个边
      void addEdge( int v, int w ){

          assert( v >= 0 && v < n );
          assert( w >= 0 && w < n );

          g[v].push_back(w);
          if( v != w && !directed )
              g[w].push_back(v);

          m ++;
      }

      // 验证图中是否有从 v 到 w 的边
      bool hasEdge( int v , int w ){

          assert( v >= 0 && v < n );
          assert( w >= 0 && w < n );

          for( int i = 0 ; i < g[v].size() ; i ++ )
              if( g[v](i) == w )
                  return true;
          return false;
      }

      // 显示图的信息
      void show(){

          for( int i = 0 ; i < n ; i ++ ){
              cout<<"vertex "<<i<<":\t";
              for( int j = 0 ; j < g[i].size() ; j ++ )
                  cout<<g[i](j)<<"\t";
              cout<<endl;
          }
      }

      // 不直接暴露内部变量 g，而是使用迭代器，使得外部访问不同图的实现接口完全相同
      // 邻边迭代器，传入一个图和一个顶点，迭代在这个图中和这个顶点向连的所有顶点
      class adjIterator{
      private:
          SparseGraph &G; // 图 G 的引用
          int v;
          int index;

      public:
          // 构造函数
          adjIterator(SparseGraph &graph, int v): G(graph){
              this->v = v;
              this->index = 0;
          }

          ~adjIterator(){}

          // 返回图 G 中与顶点 v 相连接的第一个顶点
          int begin(){
              index = 0;
              if( G.g[v].size() )
                  return G.g[v](index);
              // 若没有顶点和 v 相连接，则返回 -1
              return -1;
          }

          // 返回图 G 中与顶点 v 相连接的下一个顶点
          int next(){
              index ++;
              if( index < G.g[v].size() )
                  return G.g[v](index);
              // 若没有顶点和 v 相连接，则返回 -1
              return -1;
          }

          // 查看是否已经迭代完了图 G 中与顶点 v 相连接的所有顶点
          bool end(){
              return index >= G.g[v].size();
          }
      };
  };
  ```

### 2.3. 十字链表（有向图）

十字链表（orthogonal list）是一种**用边表示图**的方法，它**实际上是邻接表与逆邻接表的结合**，即把每条弧的两个结点分别放入以弧尾顶点为头结点的链表和以弧头顶点为头结点的链表中。

在十字链表中，有向图的每个弧和每个顶点都有一个结点，结点的结构如下所示：
- 弧结点

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/63d4f55ea2feacbaf32c80992817c8c4.jpg)

  在弧结点中有 5 个域：
  - 信息域（info）：指向该弧的相关信息。无相关信息时，可用“#”表示。
  - 尾域（tailvex）：指示弧尾（起点）顶点编号。
  - 头域（headvex）：指示弧头（终点）顶点编号。
  - 头链域（hlink）：指向弧头（终点）相同的下一条弧。
  - 尾链域（tlink）：指向弧尾（起点）相同的下一条弧。
- 头结点（顶点结点）

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/da7e3604846b7717abb1c8dbc14eded2.jpg)

  顶点结点有 3 个域：
  - 数据域（data）：存储与顶点相关的信息，如顶点的名称等。
  - 入链域（firstin）：指向以该顶点为弧头（终点）的第一个弧结点。
  - 出链域（firstout）：指向以该顶点为弧尾（起点）的第一个弧结点。

例：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/6111c9f7108e682435e7e29d829c2a4f.jpg)

在十字链表中，同时具备邻接表与逆邻接表的优点。既容易找到以 vi 为尾的弧，也容易找到以 vi 为头的弧，因此容易求得顶点的出度和入度，并且，建立十字链表的时间复杂度与建立邻接表的是相同的。但由于十字链表中每个链表结点（图中的边对应的结点）有两个链域，所以它的存储效率要比邻接表低。

如果将图的邻接矩阵用矩阵的十字链表表示，可发现，图的十字链表是图的邻接矩阵的十字链表的变形。二者的主要差别是：
- 前者的链表结点不需按起点与终点（相当于行号与列号）的大小顺序排列。
- 前者的“行”与“列”链表一般不需构成循环结构。

十字链表仅适用于有向图。

### 2.4. 邻接多重表（无向图）

邻接多重表（adjacency multilist）是存储无向图的一种链式结构。邻接多重表的存储结构和十字链表类似，也是由顶点表和边表组成的，每一条边用一个结点表示：
- 边表结点由以下 6 个域组成：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/83e89c597e94903807238ee531fbb1ba.jpg)

  - info 为与边相关的各种信息。无相关信息时，可用“#”表示。
  - mark 为标志域，可用于标记该条边是否被搜索过。
  - ivex 和 jvex 为该边依附的两个顶点在图中的位置。
  - ilink 指向下一条依附于顶点 ivex 的边。
  - jlink 指向下一条依附于顶点 jvex 的边。

- 顶点结点由以下 2 个域组成：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/3fbe54db92159ce6ccae814bfd500e01.jpg)

  - data 域存储和该顶点相关的信息；
  - firstedge 域指示第一条依附于该顶点的边。

例：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/06710c2ca10e7ba55a5a731cbb9f0fe6.jpg)

虽然用邻接表来存储无向图可以很容易求得图的顶点和边的各种信息，但邻接表将每条边（vi, vj）的两个结点放在不同的链表中，使得某些图的操作很不方便。例如，对图中已访问过的边作记号或删除一条边等，都需要找到同一条边的两个结点。因此，当进行这一类操作时，无向图多采用邻接多重表进行存储。

无向图的两种存储方法——邻接多重表和邻接表中，它们的差别仅仅在于同一条边用两个结点表示还是用一个结点表示，因此，邻接多重表除比邻接表在边结点中多增加一个标志域外，其他方面（如各种基本操作的实现等），二者都颇为相似。

邻接多重表仅适用于无向图。

## 3. 无权图的应用

### 3.1. 魔棒抠图 Flood Fill

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/17/07a8553efaacff3a5a8039626fc9518b.jpg)

基本原理就是取连通分量的过程。

### 3.2. 扫雷

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/17/30a5d79bdcd844d371b05d8db68c3ad7.jpg)

### 3.3. 走迷宫

### 3.4. 生成迷宫

迷宫的本质是一棵树，生成迷宫的过程就是一个生成树的过程。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/17/20250fd79d5a0d3d70508aca8375fd7b.jpg)

如上图所示，红色块表示通路，蓝色块表示墙。生成迷宫的过程，只需不断地将蓝色块变为红色块，形成通路。由于使用 BFS 或 DFS 会导致无法生成随机的迷宫，因此应利用一个随机队列，每次从队列中取出一个随机元素进行遍历，进而生成一个随机的迷宫。

### 3.5. 地图填色

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/4/17/ef14ec95f67ae62b2105018a93709662.jpg)

将每个国家作为图的一个顶点，即可将问题转换为：如何为图的顶点填色，使得每个顶点与其相邻顶点的颜色不重复？

## 4. 有权图的应用

### 4.1. AOV 和 AOE

### 4.2. 最小生成树

### 4.3. 最短路径

## 5. Refer Links

http://c.biancheng.net/cpp/u/shuju8/  

http://blog.csdn.net/qq_38262266/article/details/77010230

http://blog.csdn.net/matrix_laboratory/article/details/11879127

http://blog.csdn.net/wang379275614/article/details/13990163

http://blog.csdn.net/u011240016/article/details/53171808
