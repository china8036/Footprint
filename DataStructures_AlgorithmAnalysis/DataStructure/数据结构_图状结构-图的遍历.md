- [数据结构：图结构 - 图的遍历](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9B%BE%E7%BB%93%E6%9E%84---%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86)
  - [1. 深度优先遍历 DFS](#1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-dfs)
    - [1.1. 递归实现](#11-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0)
    - [1.2. 非递归实现](#12-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0)
    - [1.3. DFS 应用](#13-dfs-%E5%BA%94%E7%94%A8)
  - [2. 广度优先遍历 BFS](#2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86-bfs)
    - [2.1. 非递归实现](#21-%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0)
    - [2.2. BFS 应用](#22-bfs-%E5%BA%94%E7%94%A8)
  - [3. 连通性问题](#3-%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98)
    - [3.1. 求非连通图的连通分量](#31-%E6%B1%82%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F)
    - [3.2. 求连通图的生成树](#32-%E6%B1%82%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91)
    - [3.3. 求非连通图的生成森林](#33-%E6%B1%82%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90%E6%A3%AE%E6%9E%97)
  - [4. Refer Links](#4-refer-links)

# 数据结构：图结构 - 图的遍历

图的遍历（traversing graph）是指从某个顶点出发，对图中每个顶点各做一次且仅做一次访问，它是许多图算法的基础。

深度优先遍历和广度优先遍历是两种最重要的遍历图的方法，它们对无向图和有向图均适用。

## 1. 深度优先遍历 DFS

无向图的深度优先搜索（depth-first search，简称 DFS）遍历是从图中某个顶点 v 出发，访问此顶点，然后依次从 v 的未被访问的邻接点出发按深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问过，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止。

**深度优先搜索遍历类似于树的前序遍历**。

时间复杂度：
- **对于邻接矩阵结构，DFS 的时间效率为 O(V^2)。**
- **对于邻接表结构，DFS 的时间效率为 O(V+E)。**

### 1.1. 递归实现

伪代码：
```cpp
/* 从结点 v0 触发，深度优先遍历图 g，函数返回访问到的结点总数 */
long DFS( 图 g, 结点 v0 ) {
  long nNodes; // 寄存访问到的结点总数
  访问 v0;
  为 vo 设置已访问标志；
  nNodes = 1;

  求出 v0 的第 1 个可达邻接点 v;
  while( v 存在 ) {
    if ( v 未被访问过 ) {
      nNodes = nNodes + DFS(g, v);
    }
    求出 v0 的下一个可达邻接点 v;
  }
  return nNodes;
}
```

### 1.2. 非递归实现

DFS 的非递归实现主要通过栈结构来实现。

伪代码：
```cpp
/* 从结点 v0 触发，深度优先遍历图 g，函数返回访问到的结点总数 */
long DFS( 图 g, 结点 v0 ) {
  long nNodes = 0; // 寄存访问到的结点总数
  访问 v0;
  为 vo 设置已访问标志；
  将 v0 进栈 S;
  nNodes = 1;

  求出 v0 的第 1 个可达邻接点 v;
  while( 栈 S 不为空 ) {
    v = 栈 S 顶部元素；
    求出 v 的下一个未访问的邻接点 i;
    访问 i;
    为 i 设置已访问标志；
    将 i 进栈 S;
    nNodes++;
    if ( v 已无未被访问过的邻接点 ) {
      将 v 出栈；
    }
  }
  return nNodes;
}
```

### 1.3. DFS 应用

- 求一个无向图的连通分量

- 右手摸墙定律 / 迷宫遍历问题

- **检测有向图中的环**（一条深度遍历路线中如果有结点被第二次访问到，那么有环）

  https://blog.csdn.net/login_sonata/article/details/78002042

  **假设图以邻接矩阵表示，一条深度遍历路线中如果有结点被第二次访问到，那么有环**。我们用一个变量来标记某结点的访问状态（未访问，访问过，其后结点都被访问过），然后判断每一个结点的深度遍历路线即可。

  因为采用邻接矩阵存储，一般至少需要将矩阵中元素的一半给过一下，由于矩阵元素个数为n^2，因此时间复杂度就是**O(n^2)**。如果采用邻接表存储，则只存储了边结点(e条边，无向图是2e条边)，加上表头结点为n（也就是顶点个数），因此时间复杂度为**O(n+e)**。  

- 马踏棋盘问题—哈密顿图（看离散课本）

## 2. 广度优先遍历 BFS

广度优先搜索（breadth first search，简称 BFS）遍历从图中某顶点 v 出发，在访问 v 之后依次访问 v 的各个未被访问过的邻接点，然后分别从这些邻接点出发再依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问，直至图中所有已被访问顶点的邻接点都被访问到为止。若此时图中尚有顶点未被访问过，则另选图中一个未曾被访问过的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止。

**广度优先搜索遍历类似于树的层序遍历**。

对于深度优先遍历，用递归方法描述很自然，而广度优先遍历则不然，使用递归描述反而会使问题复杂化，所以一般都使用非递归的方法来实现 BFS。

- **为什么使用 BFS 走迷宫的路程是最小值而使用 DFS 就不一定**？

  - BFS 是每走一步，就把所有可能的下一步走法存入数组。然后数组指针向后移一位，也就是说 BFS 是把所有可能的走法全部同时走一遍，也就是说在同一时刻，走法的数组里还未判断的位置已经走过的步数是相同的（或者只差 1），这样一来，当抵达终点后，那一个算法一定是走的步数最少的。
  - 而 DFS 是把一条路走到底再换另一条，可以想象，一条很绕的路碰巧走到终点，DFS 就判断为计算出来了，当然不是最短。

时间复杂度（与 DFS 相同）：
- **对于邻接矩阵结构，BFS 的时间效率为 O(V^2)。**
- **对于邻接表结构，BFS 的时间效率为 O(V+E)。**

### 2.1. 非递归实现

BFS 的非递归实现通常使用队列结构来实现。

伪代码：
```cpp
/* 从结点 v0 触发，广度优先遍历图 g，函数返回访问到的结点总数 */
long DFS( 图 g, 结点 v0 ) {
  long nNodes = 0; // 寄存访问到的结点总数
  初始化队列 Q;
  if ( v0 存在 ) {
    v0 入队列 Q;
    将 v0 设置已访问标志；
  }

  while ( Q 不为空 ) {
    将队列 Q 的头部元素 v 出队列；
    访问 v;
    nNodes++;
    求出 v 的第 1 个可达邻接点 w;
    while ( w 存在 ) {
      if ( w 未被访问过 ) {
        w 入队列 Q;
        将 w 设置已访问标志；
      }
      求出 v 的下一个可达邻接点 w;
    }
  }
  
  return nNodes;
}
```

### 2.2. BFS 应用

- 求两点间的最短路径

## 3. 连通性问题

图的连通性问题实质上是图的遍历的一种应用。

### 3.1. 求非连通图的连通分量

以无向图的遍历为例：
- 若是连通图，则从图中任一顶点出发进行深度优先搜索或广度优先搜索，便可访问到图中所有顶点。
- 若是非连通图，则**需要从多个顶点出发进行搜索，由此而得到图中各个连通分量中的顶点集**。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/5a12959ecca7fd06d15b8030abf2398b.jpg)

### 3.2. 求连通图的生成树

设 E(G) 为连通子图 G 中所有边的集合，则从图中任一顶点出发遍历图时，必定将 E(G) 分成两个集合 T(G) 和 B(G)，其中 T(G) 是遍历过程中经历的边的集合，B(G) 是剩余边的集合。显然，**T(G) 和图 G 中所有顶点一起构成连通图 G 的极小连通子图，是连通图的一棵生成树**。

由深度优先搜索得到的生成树为深度优先生成树，由广度优先搜索得到的生成树为广度优先生成树（生成树不唯一）。

例：下图所示分别为无向图 G4 的深度和广度优先生成树。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/67902c845ce8797cb01eaae344593a48.jpg)

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/bbee7c5e833a40c976348f7b118381d1.jpg)

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/75d39667f0976ed8b9d1a4c306f8ff8a.jpg)

### 3.3. 求非连通图的生成森林

对于非连通图，每个连通分量中的顶点集和遍历时走过的边一起构成若干棵生成树，这些连通分量的生成树组成非连通图的生成森林。

例：下图（c）所示为 G5 的深度优先生成森林，它由三棵深度优先生成树组成。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/25/701fe64116083cc821ab14383b570d5c.jpg)

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/24/b2cfe58ecaf6db4de25ebb278c2286dd.jpg)

## 4. Refer Links

http://c.biancheng.net/cpp/u/shuju8/  
