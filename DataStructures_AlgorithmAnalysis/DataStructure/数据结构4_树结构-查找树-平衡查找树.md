- [数据结构：树结构 - 查找树 - 平衡查找树](#数据结构树结构---查找树---平衡查找树)
    - [1. AVL 树](#1-avl-树)
        - [1.1. 基本概念](#11-基本概念)
        - [1.2. 效率](#12-效率)
        - [1.3. 自平衡操作：旋转](#13-自平衡操作旋转)
            - [1.3.1. 单旋转](#131-单旋转)
            - [1.3.2. 双旋转](#132-双旋转)
        - [1.4. 插入元素](#14-插入元素)
        - [1.5. 删除元素](#15-删除元素)
        - [1.6. 查找元素](#16-查找元素)
    - [2. 二三树](#2-二三树)
        - [2.1. 基本概念](#21-基本概念)
        - [2.2. 效率](#22-效率)
        - [2.3. 查找元素](#23-查找元素)
        - [2.4. 插入元素](#24-插入元素)
            - [2.4.1. 往一个二节点插入](#241-往一个二节点插入)
            - [2.4.2. 往一个三节点插入](#242-往一个三节点插入)
        - [2.5. 删除元素](#25-删除元素)
        - [2.6. 实现](#26-实现)
    - [3. 红黑树 (RB-Tree)](#3-红黑树-rb-tree)
        - [3.1. 基本概念](#31-基本概念)
            - [3.1.1. 红黑树的定义](#311-红黑树的定义)
            - [3.1.2. 红黑树的实质](#312-红黑树的实质)
            - [3.1.3. 红黑树的阶 (rank)](#313-红黑树的阶-rank)
            - [3.1.4. 红黑树的性质](#314-红黑树的性质)
        - [3.2. 效率](#32-效率)
        - [3.3. 查找元素](#33-查找元素)
        - [3.4. 插入元素](#34-插入元素)
            - [3.4.1. 插入](#341-插入)
            - [3.4.2. 调整](#342-调整)
            - [3.4.3. 插入效率](#343-插入效率)
        - [3.5. 删除元素](#35-删除元素)
            - [3.5.1. 删除](#351-删除)
            - [3.5.2. 调整](#352-调整)
            - [3.5.3. 删除效率](#353-删除效率)
        - [3.6. 应用](#36-应用)
    - [4. B 树（B- 树）](#4-b-树b--树)
        - [4.1. 基本概念](#41-基本概念)
            - [4.1.1. 概念定义](#411-概念定义)
            - [4.1.2. 结构定义](#412-结构定义)
            - [4.1.3. 结点结构](#413-结点结构)
            - [4.1.4. 性质](#414-性质)
        - [4.2. 效率](#42-效率)
        - [4.3. 基本操作](#43-基本操作)
            - [4.3.1. 查找](#431-查找)
            - [4.3.2. 插入](#432-插入)
            - [4.3.3. 删除](#433-删除)
        - [4.4. 应用](#44-应用)
    - [5. B+ 树](#5-b-树)
        - [5.1. 基本概念](#51-基本概念)
            - [5.1.1. 结构定义](#511-结构定义)
            - [5.1.2. B+ 树的性质](#512-b-树的性质)
            - [5.1.3. B+ 树与 B 树的区别](#513-b-树与-b-树的区别)
            - [5.1.4. 另一种 B+ 树](#514-另一种-b-树)
        - [5.2. 基本操作](#52-基本操作)
            - [5.2.1. 查找](#521-查找)
            - [5.2.2. 插入](#522-插入)
            - [5.2.3. 删除](#523-删除)
        - [5.3. 应用](#53-应用)
    - [6. B*树](#6-b树)
    - [7. Splay 树](#7-splay-树)
    - [9. Refer Links](#9-refer-links)

# 数据结构：树结构 - 查找树 - 平衡查找树

平衡查找树是计算机科学中的一类数据结构，是对一般查找树的一类改进。

一般的查找树的查询复杂度是跟目标结点到树根的距离（即深度）有关，因此当结点的深度普遍较大时，查询的复杂度会上升，为了更高效的查询，平衡树应运而生了。在这里，**平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的复杂度偏低**。

## 1. AVL 树

### 1.1. 基本概念

对于一般的二叉查找树（Binary Search Tree），其期望高度（即为一棵平衡树时）为 logn，其各操作的时间复杂度 O(logn) 同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即 O(n)。也就是说，二叉排序树的形态直接影响了它的查找效率。树的形态越平衡越好。

AVL 树（得名于它的发明者 G. M. Adelson-Velsky 和 E. M. Landis），是最先发明的自平衡二叉查找树。它或者是一棵空树，或者具有下列性质：**它的左子树和右子树的深度之差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树**。

n 个结点的 AVL 树最大深度约 1.44logn。

### 1.2. 效率

- 时间效率

	**AVL 树的所有操作在平均和最坏情况下都是 O(logn)**。

	这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在 O(logN)。但是，增加和删除操作可能需要通过一次或多次树旋转来重新平衡这个树，频繁旋转会使插入和删除牺牲掉 O(logN) 左右的时间，不过相对二叉查找树来说，时间上稳定了很多。

- 空间效率 

	**AVL 树的平均和最差空间复杂度都为 O(n)**。

### 1.3. 自平衡操作：旋转

AVL 树最关键的也是最难的一步操作就是旋转。旋转主要是为了实现 AVL 树在实施了插入和删除操作以后，树重新回到平衡的方法。

对于一颗（平衡的）AVL 树，若插入 / 删除一个结点后导致 AVL 树不平衡，则不平衡的结点的两棵子树的高度差为 2。又由于 AVL 树上的任意结点最多只有两个孩子，因此，此时该不平衡的结点符合以下四种情况之一：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/27/39bdbe04e5ccd3baa706e72311b0afc4.jpg)

- 6 节点的左子树 3 节点高度比右子树 7 节点大 2，左子树 3 节点的左子树 1 节点高度大于右子树 4 节点，这种情况成为**左左**。
- 6 节点的左子树 2 节点高度比右子树 7 节点大 2，左子树 2 节点的左子树 1 节点高度小于右子树 4 节点，这种情况成为**左右**。
- 2 节点的左子树 1 节点高度比右子树 5 节点小 2，右子树 5 节点的左子树 3 节点高度大于右子树 6 节点，这种情况成为**右左**。
- 2 节点的左子树 1 节点高度比右子树 4 节点小 2，右子树 4 节点的左子树 3 节点高度小于右子树 6 节点，这种情况成为**右右**。

从图 2 中可以可以看出：
- 1 和 4 两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，称之为单旋转。
- 2 和 3 两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，称之为双旋转。

#### 1.3.1. 单旋转

单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了其中一种情况，另一种情况同理即可推出。

以下左左情况的解决方案：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/27/7994c177ffb65e1af993007e77d05e20.jpg)

为使树恢复平衡，我们把 k1 变成这棵树的根节点，因为 k2 大于 k1，把 k2 置于 k1 的右子树上，而原本在 k1 右子树的 Y 大于 k1，小于 k2，就把 Y 置于 k2 的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。

这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵 AVL 树，因为 X 向上一移动了一层，Y 还停留在原来的层面上，Z 向下移动了一层。**整棵树的新高度和之前没有在左子树上插入的高度相同**，插入操作使得 X 高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。

动画示意图：

![image](https://images0.cnblogs.com/blog/94031/201403/270024492492764.gif)

![image](https://images0.cnblogs.com/blog/94031/201403/270025006402285.gif)

```cpp
// 左左情况下的旋转
template<class T>
void AVLTree<T>::SingRotateLeft(TreeNode<T>* &k2)
{
    TreeNode<T>* k1;
    k1=k2->lson;
    k2->lson=k1->rson;
    k1->rson=k2;

    k2->hgt=Max(height(k2->lson),height(k2->rson))+1;
    k1->hgt=Max(height(k1->lson),k2->hgt)+1;
}
```
```cpp
// 右右情况下的旋转
template<class T>
void AVLTree<T>::SingRotateRight(TreeNode<T>* &k2)
{
    TreeNode<T>* k1;
    k1=k2->rson;
    k2->rson=k1->lson;
    k1->lson=k2;

    k2->hgt=Max(height(k2->lson),height(k2->rson))+1;
    k1->hgt=Max(height(k1->rson),k2->hgt)+1;
}
```

#### 1.3.2. 双旋转

对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的。

以下是左右情况的解决方案：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/27/49185654ec6a41bae9e9b42d25d106c5.jpg)

为使树恢复平衡，我们需要进行两步，第一步，把 k1 作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以 k2 为根的平衡二叉树树。

```cpp
// 左右情况的旋转
template<class T>
void AVLTree<T>::DoubleRotateLR(TreeNode<T>* &k3)
{
    SingRotateRight(k3->lson);
    SingRotateLeft(k3);
}
```
```cpp
// 右左情况的旋转
template<class T>
void AVLTree<T>::DoubleRotateRL(TreeNode<T>* &k3)
{
    SingRotateLeft(k3->rson);
    SingRotateRight(k3);
}
```

### 1.4. 插入元素

插入的方法和二叉查找树基本一样，区别是，**插入完成后需要从插入的节点开始向上维护树的平衡一直到根节点，每经过一个节点都要维持树的平衡**。维持树的平衡要根据高度差的特点选择不同的旋转算法。

```cpp
// 插入
template<class T>
void AVLTree<T>::insertpri(TreeNode<T>* &node,T x)
{
    if(node==NULL)// 如果节点为空，就在此节点处加入 x 信息
    {
        node=new TreeNode<T>();
        node->data=x;
        return;
    }
    if(node->data>x)// 如果 x 小于节点的值，就继续在节点的左子树中插入 x
    {
        insertpri(node->lson,x);
        if(2==height(node->lson)-height(node->rson))
            if(x<node->lson->data)
                SingRotateLeft(node);
            else
                DoubleRotateLR(node);
    }
    else if(node->data<x)// 如果 x 大于节点的值，就继续在节点的右子树中插入 x
    {
        insertpri(node->rson,x);
        if(2==height(node->rson)-height(node->lson))// 如果高度之差为 2 的话就失去了平衡，需要旋转
            if(x>node->rson->data)
                SingRotateRight(node);
            else
                DoubleRotateRL(node);
    }
    else ++(node->freq);// 如果相等，就把频率加 1
    node->hgt=Max(height(node->lson),height(node->rson));
}
// 插入接口
template<class T>
void AVLTree<T>::insert(T x)
{
    insertpri(root,x);
}
```

### 1.5. 删除元素

删除的方法也和二叉查找树的一致，区别是，**删除完成后，需要从删除节点的父亲开始向上维护树的平衡一直到根节点，每经过一个节点都要维持树的平衡**。维持树的平衡要根据高度差的特点选择不同的旋转算法。

```cpp
// 删除
template<class T>
void AVLTree<T>::Deletepri(TreeNode<T>* &node,T x)
{
    if(node==NULL) return ;// 没有找到值是 x 的节点
    if(x < node->data)
    {
         Deletepri(node->lson,x);// 如果 x 小于节点的值，就继续在节点的左子树中删除 x
         if(2==height(node->rson)-height(node->lson))
            if(node->rson->lson!=NULL&&(height(node->rson->lson)>height(node->rson->rson)) )
                DoubleRotateRL(node);
            else
                SingRotateRight(node);
    }

    else if(x > node->data)
    {
         Deletepri(node->rson,x);// 如果 x 大于节点的值，就继续在节点的右子树中删除 x
         if(2==height(node->lson)-height(node->rson))
            if(node->lson->rson!=NULL&& (height(node->lson->rson)>height(node->lson->lson) ))
                DoubleRotateLR(node);
            else
                SingRotateLeft(node);
    }

    else// 如果相等，此节点就是要删除的节点
    {
        if(node->lson&&node->rson)// 此节点有两个儿子
        {
            TreeNode<T>* temp=node->rson;//temp 指向节点的右儿子
            while(temp->lson!=NULL) temp=temp->lson;// 找到右子树中值最小的节点
            // 把右子树中最小节点的值赋值给本节点
            node->data=temp->data;
            node->freq=temp->freq;
            Deletepri(node->rson,temp->data);// 删除右子树中最小值的节点
            if(2==height(node->lson)-height(node->rson))
            {
                if(node->lson->rson!=NULL&& (height(node->lson->rson)>height(node->lson->lson) ))
                    DoubleRotateLR(node);
                else
                    SingRotateLeft(node);
            }
        }
        else// 此节点有 1 个或 0 个儿子
        {
            TreeNode<T>* temp=node;
            if(node->lson==NULL)// 有右儿子或者没有儿子
            node=node->rson;
            else if(node->rson==NULL)// 有左儿子
            node=node->lson;
            delete(temp);
            temp=NULL;
        }
    }
    if(node==NULL) return;
    node->hgt=Max(height(node->lson),height(node->rson))+1;
    return;
}
// 删除接口
template<class T>
void AVLTree<T>::Delete(T x)
{
    Deletepri(root,x);
}
```

### 1.6. 查找元素

和二叉查找树相比，查找方法没有变法，不过根据存储的特性，AVL 树能维持在一个 O(logN) 的稳定的时间，而二叉查找树则相当不稳定。

## 2. 二三树

### 2.1. 基本概念

2-3 查找树或者是一颗空树，或者是一颗满足以下性质的平衡查找树：

- 对于 2-node，该节点**保存 1 个 key 及对应 value，以及 2 个指向左右节点的节点**，左节点也是一个 2-3 节点，所有的值都比 key 要小，右节点也是一个 2-3 节点，所有的值比 key 要大。

- 对于 3-node，该节点**保存 2 个 key 及对应 value，以及 3 个指向左中右的节点**。左节点也是一个 2-3 节点，所有的值均比两个 key 中的最小的 key 还要小；中间节点也是一个 2-3 节点，中间节点的 key 值在两个跟节点 key 值之间；右节点也是一个 2-3 节点，节点的所有 key 值比两个 key 中的最大的 key 还要大。

- 在一棵完全平衡的 2-3 查找树中，根节点到每一个为叶节点的距离都相同，也就是说**所有子树的左子树和右子树深度相同**。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/28/24b7159f576948087a78ff2007661a93.jpg)

### 2.2. 效率

- 时间效率

	**2-3 树的检索、插入、删除操作的平均和最差时间复杂度都是 O(log n)。**
	
	2-3 树的查找效率与树的高度是息息相关的：
	- 在最坏的情况下，也就是所有的节点都是 2-node 节点，查找效率为 logn。
	- 在最好的情况下，所有的节点都是 3-node 节点，查找效率为 log(3)n 约等于 0.631logn。

	举例来说，对于 1 百万个节点的 2-3 树，树的高度为 12-20 之间，对于 10 亿个节点的 2-3 树，树的高度为 18-30 之间。

	对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。

- 空间效率 

	**2-3 树的平均和最差空间复杂度都为 O(n)**。

### 2.3. 查找元素

2-3 树的查找和二叉查找树类似，要确定一个节点是否属于 2-3 树，我们首先和其跟节点进行比较，如果相等，则查找成功；否则根据比较的条件，在其左中右子树中递归查找，如果找到的节点为空，则未找到，否则返回。

查找过程如下图：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/28/cffd8b8520f0221e26cb9c4c83c53809.jpg)

### 2.4. 插入元素

往 2-3 树中插入元素和往二叉查找树中插入元素一样，首先要进行查找，然后将节点挂到未找到的节点（叶节点）上。不同之处在于插入元素后 2-3 树需保证自身的平衡状态，**2-3 树的自平衡通过元素提升实现**。

#### 2.4.1. 往一个二节点插入

如果查找后未找到的节点是一个 2-node 节点，那么只需要将新的元素放到这个 2-node 节点里面使其变成一个 3-node 节点即可：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/28/ab9bb53a6daed76aad8b0a43efd89503.jpg)

#### 2.4.2. 往一个三节点插入

如果查找的节点结束于一个 3-node 节点，可能会遇到很多种不同的情况：
- 只包含一个 3-node 节点

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/28/ea470d0183ea03d3132cf208433b1043.jpg)

  假设 2-3 树只包含一个 3-node 节点，这个节点有两个 key，没有空间来插入第三个 key 了，最自然的方式是我们假设这个节点能存放三个元素，暂时使其变成一个 4-node 节点，同时他包含四个子节点。
  
  然后，我们**将这个 4-node 节点的中间元素提升，左边的节点作为其左节点，右边的元素作为其右节点**。插入完成，变为平衡 2-3 查找树，树的高度从 0 变为 1。

- 节点是 3-node，父节点是 2-node

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/28/2d87ffa1e81587c9899f59fd15dabc9a.jpg)

  和第一种情况一样，我们也可以将新的元素插入到 3-node 节点中，使其成为一个临时的 4-node 节点。
  
  然后，将**该节点中的中间元素提升到父节点即 2-node 节点中**，使其父节点成为一个 3-node 节点，然后将左右节点分别挂在这个 3-node 节点的恰当位置。

- 节点是 3-node，父节点也是 3-node

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/28/dd760abe7a6654c651fd3c146b3bcfc9.jpg)

  当我们插入的节点是 3-node 的时候，我们将该节点拆分，中间元素提升至父节点，但是此时父节点是一个 3-node 节点，插入之后，父节点变成了 4-node 节点，然后**继续将中间元素提升至其父节点，直至遇到一个父节点是 2-node 节点**，然后将其变为 3-node，不需要继续进行拆分。

- 节点到根结点都是 3-node 节点

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/28/ca134354eafcb43f144c6bfb92c8f698.jpg)

  当根节点到字节点都是 3-node 节点的时候，这是如果我们要在字节点插入新的元素的时候，会一直查分到跟节点，**在最后一步的时候，跟节点变成了一个 4-node 节点，这个时候，就需要将根节点拆分为两个 2-node 节点，树的高度加 1**。

### 2.5. 删除元素

TODO:

### 2.6. 实现

直接实现 2-3 树比较复杂，因为：
- 需要处理不同的节点类型，非常繁琐。

- 需要多次比较操作来将节点下移。

- 需要上移来拆分 4-node 节点。

- 拆分 4-node 节点的情况有很多种。

- 某些情况插入后的平衡操作可能会使得效率降低。

因此，**在 2-3 查找树基础上进行改进，便有了红黑树。它不仅具有较高的效率，并且实现起来较 2-3 查找树简单。**

## 3. 红黑树 (RB-Tree)

### 3.1. 基本概念

红黑树是一种自平衡的二叉查找树，是一种高效的查找树。它是由 Rudolf Bayer 于 1978 年发明，在当时被称为对称二叉 B 树 (symmetric binary B-trees)。后来，在 1978 年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的红黑树。

**红黑树是一种扩充的平衡的查找二叉树，可以保证在最坏情况下各种集合操作的时间复杂度为 O(logn)**。

**红黑树的平衡是一种局部平衡，统计性能要好于要求完全平衡的 AVL 树。**

**在实现上，红黑树相比 AVL、2-3 树要更加简洁**。

- P.S. [The Red-Black Tree Song](http://webhome.csc.uvic.ca/~ruskey/classes/326/TreeSong.html)

  > I see a brand new node
  > I want to paint it black.
  >
  > We need a balanced tree,
  > we've got to paint it black.
  >
  > I want to find my key in log n time -- that's all,
  > Rotating sub-trees 'round sure can be a ball.
  >
  > I see a brand new node
  > I want to paint it black.
  >
  > Can't have a lot of red nodes,
  > We must paint them black.
  >
  > Unfortunately, coding them can be a bitch.
  > If we had half a brain to splay trees we would switch.
  >
  > I see a brand new node
  > I want to paint it black.
  >
  > No time for AVL trees
  > we must paint it BLACK.
  >
  > And if they're still confusing, you should have no fear.
  > Because outside this class, of them you'll never hear.
  >
  > I wanna paint 'em BLACK. Paint nodes black. Again and again.

#### 3.1.1. 红黑树的定义

红黑树**在二叉查找树定义的基础上**增加了如下 5 个特征定义：
1. **颜色特征**：每个节点要么是红色，要么是黑色。
1. **根特征**：根节点永远是黑色的。
1. **外部特征**：所有的叶节点都是空的黑色结点（即 NIL 节点）。
1. **内部特征**：每个红色节点的两个子节点一定都是黑色，即不允许两个连续的红色结点。
1. **深度特征**：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。

这些性质可以避免二叉查找树退化成单链表的极端情况，其中，性质 4 和性质 5 可保证任意节点到其每个叶子节点路径最长不会超过最短路径的 2 倍（如果某些路径长度过长，那在对这些路径上的及诶单进行增删查操作时，效率也会大大降低）。

#### 3.1.2. 红黑树的实质

**若将一棵红黑树中的每个红色节点都吸收到其父结点，就成为了一棵标准的 4 阶 B 树（2-3-4 树）**。其中，红黑树中的一黑节点、一黑一红节点和一黑二红节点分别对应 2-3-4 树中的 2-node、3-node 和 4-node。

**红黑树事实上是用标准的二叉查找树和一些额外的信息来表示 2-3-4 树，从而将 BST 和 2-3-4 树的优点结合起来：BST 中简洁高效的查找方法和 2-3-4 树中高效的平衡插入方法。**

#### 3.1.3. 红黑树的阶 (rank)

红黑树结点的阶也称为“ 黑色高度”，指的是从该结点到外部结点的黑色结点的数量，不包括该结点本身，包括叶结点。
- 外部结点的阶为零。

根的阶称为该红黑树的阶。

#### 3.1.4. 红黑树的性质

- **红黑树是满二叉树**。

- 阶为 k 的红黑树，从根到叶的简单路径长度最短是 k，最长是 2k；树高最小是 k+1，最大是 2k+1。

- 阶为 k 的红黑树的内部结点数最少是 2^k-1，所有内部结点构成一棵完全满二叉树。

- n 个内部结点的红黑树树高最大为 2log((n+1)+1)。

### 3.2. 效率

- 时间效率

  **检索、插入、删除操作的平均和最差时间复杂度都是 O(log n)。**

- 空间效率 

  **红黑树的平均和最差空间复杂度都为 O(n)**。 

### 3.3. 查找元素

红黑树中查找元素的操作与 BST 的查找操作基本相同。

### 3.4. 插入元素

红黑树的插入主要分两步：
1. 首先和二叉查找树的插入一样，查找、插入。
1. 然后调整结构，保证满足红黑树状态。

#### 3.4.1. 插入

红黑树插入操作的实现思路与 BST 的插入操作基本相同。

不同之处在于：红黑树的第 5 条特征规定，任一节点到它子树的每个叶子节点的路径中都包含同样数量的黑节点。当我们往红黑树中插入一个黑色节点时，会违背这条特征。这个调整起来会比较麻烦（参考红黑树的删除操作，就知道为啥多一个或少一个黑色节点时，调整起来这么麻烦了）。如果插入的节点是红色，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可，比之前的简单多了。

因此，**在红黑树中插入结点规定只插入红色结点**。

#### 3.4.2. 调整

红黑树的第 4 条特征规定，红色节点的左右孩子一定都是黑色节点。当我们给一个红色节点下插入一个红色节点时，会违背这条特征。

因此，我们需要关心插入的红色结点的父节点是否为红。
- 若父结点为黑色，则无须调整，插入算法结束。

- 若父结点为红色，则插入新结点后会出现两个红节点相邻的情况，因此需要进行**双红调整**：
	
	<!-- 在插入节点后进行结构调整，将父节点进行变化，让父节点变成黑色，或者换一个黑色节点当父亲，这些操作的同时不能影响不同路径上的黑色节点数一致的规则。 -->

	- 插入结点的叔父为黑色结点：结构调整

		原则：保持 BST 的中序性质。

		根据插入结点、父结点与父父结点的结构不同，结构调整分为 4 种情况（与 [AVL 树旋转的 4 种情况](#13- 自平衡操作旋转) 类似）：

		![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/0b7ad0bcd7e9ff76db3cf8451e3229c9.jpg)

	- 插入结点的叔父为红色结点：父祖换色

		![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/ff9543cc0b41fceddd2aac795a09ccb6.jpg)

例：插入新结点 4。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/3604c73632f03f2d2c7bf27dea56b501.jpg)

进行父祖换色：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/d552d223836822ecbca9b1df31f48193.jpg)

进行结构调整：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/009079c9a5d04c5db2864bac7869370c.jpg)

#### 3.4.3. 插入效率

红黑树高度为 O(log n)，因此：
- 第 1 步，执行 BST 的插入操作，共访问 O(log n) 个结点，时间代价为 O(log n)。
	
- 第 2 步，将新结点标记为红色，时间代价为 O(1)。

- 第 3 步，进行红黑树调整，最多 O(log n) 重着色，每次 O(1)；最多 O(1) 次 重构着色。因此，时间代价为 O(log n)。
	```
	while doubleRed(z)
		if isBlack(sibling(parent(z)))
			z ← restructure(z)
			return
		else { sibling(parent(z) is red }
			z ← recolor(z)
	```
	
因此，红黑树结点插入时间代价为 O(log n)。

### 3.5. 删除元素

红黑树的删除也是分两步：
1. 首先执行二叉查找树的删除操作。
1. 然后调整结构，保证满足红黑树状态。

#### 3.5.1. 删除

红黑树删除元素操作的实现思路与 BST 的元素删除操作基本相同，但**在节点交换时需要交换节点的颜色**。

- 如果被删除的节点没有双非空子女，则直接删除这个节点，用它的唯一子节点顶替它的位置。
- 如果它的子节点分是空节点，那就用空节点顶替它的位置。
- 如果它的双子全为非空，我们就把它的直接后继节点内容复制到它的位置，之后以同样的方式删除它的后继节点，它的后继节点不可能是双子非空，因此此传递过程最多只进行一次。

#### 3.5.2. 调整

- 若被删除节点或被删除节点的某个儿子节点是红色的，则它被删除之后只需用该儿子节点替换被删除节点，并标记为黑色即可。对当前树的特性不会造成任何破坏影响，无须调整，删除算法结束。

- 若被删除节点是黑色的，则需要进行**双黑调整**：

	如下图，v 是被删除节点，x 是 v 的左儿子，w 是 v 的右儿子，此时 x 需要标记为双黑，根据双黑 X 的兄弟节点 C 进行结构调整：

	![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/a13bfa75b8293d2a35750370dbf61d65.jpg)

	- C 是黑色，且子结点有红色：结构调整

		- C 的红节点在 X 的同一侧

			![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/a6d2f9666e5f48ed8dca7a3b3b67c634.jpg)

			即将 D 结点旋转为 C 结点的父结点，D 继承原子根 B 的颜色，B 着为黑色即可。

		- C 的红节点在 X 的另一侧

			![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/4ca2db7e9f23bb447bfbfdb687928120.jpg)

			即将兄弟结点 C 提上去，C 继承原父结点的颜色，然后把 B 着为黑色，D 着为黑色，其他颜色不变即可。

	- C 是黑色，且子结点没有红色：父祖换色，可能需要从 B 继续向上调整

		![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/83ff95d388079fba79e0a1afaccff0fe.jpg)

		即把 C 着红色，B 着黑色，如果 B 原为红色，则算法结束；否则，对 B 继续作“双黑”调整。

	- C 是红色：转换状态，将 C 转换为父节点，调整为情况 1 或 2 继续处理

		![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/f6ec4e6ce5cd1c70e916bc4376d5004e.jpg)

		执行旋转，X 结点仍是“双黑”结点，转化为前面 2 种情况。

#### 3.5.3. 删除效率

删除算法的平均和最差效率都是 O(log n)。

### 3.6. 应用

红黑树这种数据结构应用十分广泛，在多种编程语言中被用作符号表的实现，如：
- Java 中的 java.util.TreeMap、java.util.TreeSet 以及 JDK 1.8 中的 HashMap
- C++ STL 中的：map,multimap,multiset
- .NET 中的：SortedDictionary,SortedSet 

## 4. B 树（B- 树）

https://www.coursera.org/learn/gaoji-shuju-jiegou/lecture/NNc6c/b-shu

### 4.1. 基本概念

B 树与 B- 树指的是同一个概念。因为 B 树的原英文名称为 B-tree，而国内很多人喜欢把 B-tree 译作 B- 树，其实，这是个非常不好的直译，很容易让人产生误解。

B 树也是一种用于查找的平衡多叉树。

#### 4.1.1. 概念定义

> 在计算机科学中，B 树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以 O(log n) 的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B 树，概括来说是一个节点可以拥有多于 2 个子节点的二叉查找树。与 AVL 树不同，B- 树为系统最优化大块数据的读和写操作。B-tree 算法减少定位记录时所经历的中间过程，从而加快存取速度，因此普遍运用在数据库和文件系统的实现中。

对于规模较大的、存放在外存中的文件，如果再以结点为单位进行内存与外存设备之间的数据交换，则需要多次访问外磁盘，这样大大降低了效率。B 树有效减少了查找树的高度，从而大大减少了访问外磁盘的次数，提高查找效率。但也导致添加、删除操作较为复杂。

#### 4.1.2. 结构定义

m 阶 B 树的结构定义：
-  每个结点至多有 m 个子结点。
-  除根结点和叶结点外，其它**每个结点至少有 ceil(m/2) 个子结点**。
-  根结点至少有两个子结点，当 B 树只有一个结点时根结点没有子结点。
- **所有叶子结点位于同一层**，树高为 logN。
- 有 k 个子结点的非根结点恰好包含 k-1 个关键码。

2-3 树实际上是 3 阶 B 树，2-3-4 树实际上是 4 阶 B 树，以此类推。B 树的阶数应该大于 3，因此 2-3 树是最小的 B 树。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/28/f21dfd2eae703c75dd479de35ee48464.jpg)

#### 4.1.3. 结点结构

B 树的一个包含 j 个关键码，j+1 个指针的结点的一般形式：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/4dc8db274c417554366497a059f890e4.jpg)

其中 K i 是关键码值，K1 <K2 <…<Kj， Pi 是指向包括 Ki 到 Ki+1 之间的关键码的子树的指针。

#### 4.1.4. 性质

- 高度平衡，所有叶结点都在同一层。

- 关键码没有重复，父结点中的关键码是其子结点的分界。

- **B 树把值接近的相关记录（即一个 B 树结点的所有关键码和指向该结点的指针）放在同一个磁盘页中，从而利用了访问局部性原理（cache），大大减少了访问外磁盘的次数，提高查找效率。**
	- **实际应用中，需要先根据操作系统的页块大小，计算存储结构 B 树的阶数。**

- B 树保证树中至少有一定比例的结点是满的，从而改进空间的利用率，减少了检索和更新操作的磁盘读取数目。

### 4.2. 效率

- 时间效率

	**B- 树的检索、插入、删除操作的平均和最差时间复杂度都是 O(log n)。**

	包含 N 个关键码的 B 树，有 N+1 个外部空指针，假设外部指针在第 k 层，则：
	- 第一层至少两个结点。
	- 第二层至少 2ceil(m/2) 个结点。
	- 第 k 层至少 2ceil(m/2)^(k-1)。

	也就是说，对于 1,999,998 个关键码的 B 树，取 m=199 时，k=4 即树高最高为 4，一次查找过程最多只用访问 4 次外存。

- 空间效率 

	**B- 树的平均和最差空间复杂度都为 O(n)。**

### 4.3. 基本操作

#### 4.3.1. 查找

首先将根结点读出来，在根结点所包含的关键码 K1 ，…，Kj 中查找给定的关键码值，找到则检索成功。

否则，确定要查的关键码值是在某个 Ki 和 Ki+1 之间，于是取 pi 所指向的结点继续查找• 如果 pi 指向外部空结点，表示检索失败。

#### 4.3.2. 插入

类似 BST，插入过程实际上是一个失败的查找过程。

查找到最底层，在叶节点上进行插入。**若元素溢出，则结点分裂，中间关键码连同新指针插入父结点。若父结点也溢出，则继续分裂。若传达到根结点，则树升高一层。**

例题：在以下 B 树连续插入 14、55、19 的过程中，假设访问过的页块都会进行缓存，则访问外存储器的次数是多少？

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/40deed2b298b8704fa91a69c28a15d58.jpg)

解析：

插入 14、55、19 后，B 树呈现以下形态：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/f8da173fb4ffd6d5d469322601b4ebd3.jpg)

因此，读磁盘共 7 次（a,b,f; d,k; c,g），写磁盘共 11 次（f; k,k',d; g,g',c,c',a,a',t）。

#### 4.3.3. 删除

B 树的删除操作分为以下两种情况：
- 删除的关键码不在叶结点层，跟叶中后继对换即可。

- 删除的关键码在叶结点层：
	- 若删除后关键码个数不小于 ceil(m/2)-1，直接删除即可。
	- 若删除后关键码个数小于 ceil(m/2)-1：
		- 若兄弟结点关键码个数不等于 ceil(m/2)-1，则从兄弟结点移若干个关键码到该结点中来（父结点中的一个关键码要做相应变化)。
		- 若兄弟结点关键码个数等于 ceil(m/2)-1，则合并。

### 4.4. 应用

B 树在文件系统、数据库系统中的应用

由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高 I/O 效率。**预读的长度一般为页（page）的整倍数**。文件系统及数据库系统的设计者利用了磁盘预读原理，**将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入**。为了达到这个目的，在实际实现 B-Tree 还需要使用如下技巧：
- **每次新建一个节点的同时，直接申请一个页的空间 ( 512 或者 1024)，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个 node 只需一次 I/O**。如，将 B 树的度 M 设置为 1024，这样在前面的例子中，600 亿个元素中只需要小于 4 次查找即可定位到某一存储位置。
- 同时**在 B+ 树中，内节点只存储导航用到的 key，并不存储具体值，这样内节点个数较少，能够全部读取到主存中，外接点存储 key 及值，并且顺序排列，具有良好的空间局部性**。所以 B 及 B+ 树比较适合与文件系统的数据结构。

对于一颗节点为 N 度为 M 的子树，查找和插入需要 logM-1N ~ logM/2N 次比较。这种效率是很高的，对于 N=62*1000000000 个节点，如果度为 1024，则 logM/2N <=4，即在 620 亿个元素中，如果这棵树的度为 1024，则只需要小于 4 次即可定位到该节点，然后再采用二分查找即可找到要找的值。

B/B+ 树也经常用做数据库的索引，可参考张洋的 [MySQL 索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)，对 MySQL 中的如何使用 B+ 树进行索引有比较详细的介绍。

- B 树作为索引结构
	
	![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/1f78450dbce590ecb9bb5f45f5aae4ce.jpg)

## 5. B+ 树

https://www.coursera.org/learn/gaoji-shuju-jiegou/lecture/5iuEZ/b-shu

### 5.1. 基本概念

B+ 树是对 B 树的一种变形：
- 在叶结点上存储信息，即所有的关键码均出现在叶结点上。
- 非叶结点仅具有索引作用，各层结点中的关键码均是下一层相应结点中最大关键码（或最小关键码）的复写。
- 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。

#### 5.1.1. 结构定义

B+ 树的结构定义：
- 每个结点至多有 m 个子结点。
- 每个结点（除根外) 至少有 ceil(m/2) 个子结点。
- 根结点至少有两个子结点。
- 有 k 个子结点的结点必然有 k 个关键码。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/55a6c41aba9d0e7b092e59d1173357b9.jpg)

#### 5.1.2. B+ 树的性质

B+ 的性质：
- 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的。
- 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层。
- B 树的平均树高为 log(0.5m) N，B+ 树的平均树高为 log(0.75m) N。因此 B+ 树有比 B 树更高的存储效率，几乎没有被浪费的空指针，更适合文件索引系统。

#### 5.1.3. B+ 树与 B 树的区别

下面是 B 树和 B+ 树的区别图：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/28/95e8875b8c7d8ed3ef6c3a79c1bb3f4a.jpg)

#### 5.1.4. 另一种 B+ 树

B+ 树还有另一种结构定义，区别在于叶结点中关键码数目与非叶的不同，且内部非叶结点构成 B 树，而叶的阶与 B+ 树一致，例如叶结点阶 5，内部阶 4。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/2/06b7e0f6aba27492ee2e78ea09176d6e.jpg)

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/2/28/7385604ce73bf16d37e42575f17e14dc.jpg)

### 5.2. 基本操作

#### 5.2.1. 查找

B+ 树的查找过程与 B 树基本相同，区别是若在上层已找到待查的关键码，并不停止，而是继续沿指针向下一直查到叶结点层的这个关键码，即 B+ 树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找。

#### 5.2.2. 插入

B+ 树的插入过程和 B 树类似，但需要注意保证上一层结点中有这两个结点的最大 / 小关键码。

#### 5.2.3. 删除

当关键码下溢出时，与左或右兄弟进行调整（甚至合并）。

关键码在叶结点层删除后，其在上层的复本可以保留，作为一个“分界关键码”存在；也可以替换为新的最大关键码（或最小关键码）。

### 5.3. 应用

- 数据库系统索引实现。

	相比 B 树，B + 树的存储效率更高、检索层次更少（树较矮），且 B+ 树中叶子节点的相邻叶子指针（顺序访问指针）提高了区间查询的效率，因此，在各大 DBMS 的索引实现中也大多使用的是 B+ 树。

- 基于 B+ 树的磁盘文件虚拟存储存取管理 VSAM (Virtual Storage Access Method)，取代了基于多分树的 ISAM。

## 6. B*树

B* 树是 B+ 树的变体，**在 B+ 树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从 1/2 提高到 2/3**。

B* 树定义了非叶子结点关键字个数至少为 `(2/3)*M`，即块的最低使用率为 2/3（代替 B+ 树的 1/2）。

- B+ 树的分裂：当一个结点满时，分配一个新的结点，并将原结点中 1/2 的数据复制到新结点，最后在父结点中增加新结点的指针；B+ 树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。
- B* 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制 1/3 的数据到新结点，最后在父结点增加新结点的指针。
所以，**B* 树分配新结点的概率比 B+ 树要低，空间使用率更高**。

## 7. Splay 树

todo:

## 9. Refer Links

[一步一步写平衡二叉树（AVL 树）](http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html)

[浅谈算法和数据结构：八 平衡查找树之 2-3 树（含动画）](https://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)

[浅谈算法和数据结构：十 平衡查找树之 B 树（含动画）](https://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html)

[浅谈算法和数据结构：九 平衡查找树之红黑树（含动画）](https://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)

[重温数据结构：深入理解红黑树](http://blog.csdn.net/u011240877/article/details/53329023)

[数据结构中各种树](https://www.cnblogs.com/maybe2030/p/4732377.html)

https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E6%A0%91

https://www.zhihu.com/question/30527705

[红黑树详细分析](http://www.coolblog.xyz/2018/01/11/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/)

[红黑树插入 & 删除动画演示](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)

[MySQL 索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)