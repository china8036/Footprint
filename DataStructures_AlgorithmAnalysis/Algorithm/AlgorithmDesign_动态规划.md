- [算法设计方法：动态规划](#算法设计方法动态规划)
  - [1. 算法思想](#1-算法思想)
  - [2. 适用场景](#2-适用场景)
  - [3. 求解步骤](#3-求解步骤)
    - [3.1. 状态定义](#31-状态定义)
    - [3.2. 状态转移](#32-状态转移)
    - [3.3. 最优决策表](#33-最优决策表)
  - [4. 应用](#4-应用)
    - [4.1. Dijkstra 最短路径算法](#41-dijkstra-最短路径算法)
    - [4.2. 图像压缩](#42-图像压缩)
    - [4.3. 矩阵连乘法](#43-矩阵连乘法)
  - [5. Refer Links](#5-refer-links)

# 算法设计方法：动态规划

## 1. 算法思想

动态规划（Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

> dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler sub problems.

**动态规划的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。**在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

**与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）**。

## 2. 适用场景

能采用动态规划求解的问题的一般要具有 3 个性质：
- **最优化原理**：**如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构**，即满足最优化原理。

- **有重叠子问题**：即子问题之间是不独立的，**一个子问题在下一阶段决策中可能被多次使用到**（该性质并不是动态规划适用的必要条件，但是**如果没有这条性质，动态规划算法同其他算法相比就不具备优势**）。

  由于动态规划解决的问题多数有重叠子问题这个特点，**为减少重复计算，可将其不同阶段的不同状态保存在一个二维数组中，将其记忆化存储，从而对每一个子问题只求解一次**。在重复子问题的数目关于输入的规模呈指数增长时特别有用。

- **无后效性**：即**某阶段状态一旦确定，就不受这个状态以后决策的影响**。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。

需要注意的是，一个问题可能有多种不同的状态定义和状态转移方程定义，存在一个有后效性的定义，但这不代表该问题不适用动态规划。

P.S.

**大多数动态规划问题的描述是这么开头的：“设计一个算法，计算第n个……”、“编写代码列出前n个……”、“实现一个方法，计算所有……”**。

## 3. 求解步骤

动态规划通过拆分问题、定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。**如何拆分问题是动态规划的核心，而拆分问题靠的是状态的定义和状态转移方程的定义**。因此，**动态规划的本质就是对问题状态的定义和状态转移方程的定义**。

### 3.1. 状态定义

**适用动态规划解决问题，首先要定义这个问题的状态**。当然，状态的选择要满足无后效性。

- e.g.（LIS 问题）：

  给定一个数列，长度为 N，求这个数列的最长上升（递增）子数列的长度。以 1 7 2 8 3 4 为例，这个数列的最长递增子数列是 1 2 3 4，长度为 4；次长的长度为 3，包括 1 7 8; 1 2 3 等。

  对该问题进行状态定义：
  ```
  给定一个数列，长度为 N，设 Fk 为：以数列中第 k 项结尾的最长递增子序列的长度。求 F1 ... FN 中的最大值。
  ```
  显然，这个新问题与原问题等价。而对于 Fk 来讲，F1 ... Fk-1 都是 Fk 的子问题：因为以第 k 项结尾的最长递增子序列（下称 LIS），包含着以第 1..k-1 中某项结尾的 LIS。

  上述的新问题 Fk 也可以叫做状态，定义中的“Fk 为数列中第 k 项结尾的 LIS 的长度”，就叫做对状态的定义。

需要注意的是，对同一个问题的状态定义可以有多种。

### 3.2. 状态转移

**状态定义好之后，状态和状态之间的关系式，就叫做状态转移方程**。

给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。

- e.g.

  对于 LIS 问题上述的状态定义：
  > 设 Fk 为：以数列中第 k 项结尾的最长递增子序列的长度。

  则设 A 为题中数列，状态转移方程为：
  ```
  F1 = 1 （根据状态定义导出边界情况）
  Fk=max(Fi+1 | Ak>Ai, i ∈ (1...k-1)) (k>1)
  ```
  即以第 k 项结尾的 LIS 的长度是：保证第 i 项比第 k 项小的情况下，以第 i 项结尾的 LIS 长度加一的最大值，取遍 i 的所有值（i 小于 k）。

从前一个阶段转化到后一个阶段之间的递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，**动态规划往往可以用递归程序来实现**。且由于递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势。

### 3.3. 最优决策表

**确定了动态规划的三要素（状态定义、状态转移、边界条件），整个求解过程就可以用一个最优决策表来描述**。

最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等）。填表的过程就是根据递推关系，从 1 行 1 列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。

> f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}

## 4. 应用

### 4.1. Dijkstra 最短路径算法

状态定义：shortestPath(i) 表示从 start 到 i 的最短路径长度

状态转移方程：shortestPath(x) = min(shortestPath(a) + w(a->x))

### 4.2. 图像压缩

### 4.3. 矩阵连乘法

## 5. Refer Links

[五大常用算法之二：动态规划算法](http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html)

[漫画：什么是动态规划？](https://juejin.im/post/5a29d52cf265da43333e4da7)

[知乎：什么是动态规划？动态规划的意义是什么？](https://www.zhihu.com/question/23995189)