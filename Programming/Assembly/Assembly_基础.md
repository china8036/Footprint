- [汇编语言：基础概念](#汇编语言基础概念)
  - [1. 基本概念](#1-基本概念)
    - [1.1. 发展由来](#11-发展由来)
    - [1.2. 意义](#12-意义)
    - [1.3. 优缺点](#13-优缺点)
  - [2. 语法格式](#2-语法格式)
    - [2.1. Intel 汇编格式](#21-intel-汇编格式)
    - [2.2. AT&T / GAS 汇编格式](#22-att--gas-汇编格式)
    - [2.3. 语法格式区别](#23-语法格式区别)
  - [3. 开发形式](#3-开发形式)
    - [3.1. 完全汇编](#31-完全汇编)
    - [3.2. 内联汇编](#32-内联汇编)
  - [4. 汇编工具](#4-汇编工具)
    - [4.1. 汇编器](#41-汇编器)
    - [4.2. 连接器](#42-连接器)
    - [4.3. 调试器](#43-调试器)
  - [5. Refer Links](#5-refer-links)

# 汇编语言：基础概念

## 1. 基本概念

### 1.1. 发展由来

TODO:

### 1.2. 意义

作为最基本的编程语言之一，汇编语言虽然应用的范围不算很广，但重要性却勿庸置疑，因为它能够完成许多其它语言所无法完成的功能。就拿 Linux 内核来讲，虽然绝大部分代码是用 C 语言编写的，但仍然不可避免地在某些关键地方使用了汇编代码，其中主要是在 Linux 的启动部分。由于这部分代码与硬件的关系非常密切，即使是 C 语言也会有些力不从心，而汇编语言则能够很好扬长避短，最大限度地发挥硬件的性能。

大多数情况下 Linux 程序员不需要使用汇编语言，因为即便是硬件驱动这样的底层程序在 Linux 操作系统中也可以用完全用 C 语言来实现，再加上 GCC 这一优秀的编译器目前已经能够对最终生成的代码进行很好的优化，的确有足够的理由让我们可以暂时将汇编语言抛在一边了。但实现情况是 Linux 程序员有时还是需要使用汇编，或者不得不使用汇编，理由很简单：精简、高效和 libc 无关性。假设要移植 Linux 到某一特定的嵌入式硬件环境下，首先必然面临如何减少系统大小、提高执行效率等问题，此时或许只有汇编语言能帮上忙了。

### 1.3. 优缺点

- 汇编语言直接同计算机的底层软件甚至硬件进行交互，它具有如下优点：

  - 能够直接访问与硬件相关的存储器或 I/O 端口。
  - 能够不受编译器的限制，对生成的二进制代码进行完全的控制。
  - 能够对关键代码进行更准确的控制，避免因线程共同访问或者硬件设备共享引起的死锁。
  - 能够根据特定的应用对代码做最佳的优化，提高运行速度。
  - 能够最大限度地发挥硬件的功能。

- 汇编语言是一种层次非常低的语言，它仅仅高于直接手工编写二进制的机器指令码，因此不可避免地存在一些缺点：

  - 编写的代码非常难懂，不好维护。
  - 很容易产生 bug，难于调试。
  - 只能针对特定的体系结构和处理器进行优化。
  - 开发效率很低，时间长且单调。

## 2. 语法格式

从严格意义上讲，“汇编”并不是一门语言，因为每个平台甚至同一平台的不同汇编器所支持的“汇编语言”也都不一样。以实际硬件的机器语言 / 汇编为目标，具体语法格式的细节都需要参照各自的手册（ISA 手册 / 汇编器手册）。

常见的汇编语法格式有以下 2 种：

### 2.1. Intel 汇编格式

在 DOS/Windows 系统中的汇编语言都是 Intel 风格的。

### 2.2. AT&T / GAS 汇编格式

在 Unix/Linux 系统中的汇编语言通常是 AT&T 风格的，但在新的汇编器版本中也支持了 Intel 风格，但更多采用的还是 AT&T 格式。

由于在 Unix/Linux 系统中通常使用的是 GNU 汇编器（GCC 后端），AT&T 汇编格式也称为 GAS(GNU ASembler) 汇编格式。

### 2.3. 语法格式区别

- 在 AT&T 汇编格式中，寄存器名要加上 '%' 作为前缀；而在 Intel 汇编格式中，寄存器名不需要加前缀。
- 在 AT&T 汇编格式中，用 '$' 前缀表示一个立即操作数；而在 Intel 汇编格式中，立即数的表示不用带任何前缀。
- 在 Intel 汇编格式中，目标操作数在源操作数的左边；而在 AT&T 汇编格式中，目标操作数在源操作数的右边。
- 在 AT&T 汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀'b'、'w'、'l'分别表示操作数为字节（byte，8 比特）、字（word，16 比特）和长字（long，32 比特）；而在 Intel 汇编格式中，操作数的字长是用 "byte ptr" 和 "word ptr" 等前缀来表示的。
- 在 AT&T 汇编格式中，绝对转移和调用指令（jump/call）的操作数前要加上'*'作为前缀，而在 Intel 格式中则不需要。
- 远程转移指令和远程子调用指令的操作码，在 AT&T 汇编格式中为 "ljump" 和 "lcall"，而在 Intel 汇编格式中则为 "jmp far" 和 "call far"。
- 在 AT&T 汇编格式中，内存操作数的寻址方式是 `section:disp(base, index, scale)`；而在 Intel 汇编格式中，内存操作数的寻址方式为 `section:[base + index*scale + disp]`。

i.e.
- AT&T 格式
  ```asm
  #hello.s
  .data                    # 数据段声明
          msg : .string "Hello, world!\\n" # 要输出的字符串
          len = . - msg                   # 字串长度
  .text                    # 代码段声明
  .global _start           # 指定入口函数

  _start:                  # 在屏幕上显示一个字符串
          movl $len, %edx  # 参数三：字符串长度
          movl $msg, %ecx  # 参数二：要显示的字符串
          movl $1, %ebx    # 参数一：文件描述符 (stdout)
          movl $4, %eax    # 系统调用号 (sys_write)
          int  $0x80       # 调用内核功能

                          # 退出程序
          movl $0,%ebx     # 参数一：退出代码
          movl $1,%eax     # 系统调用号 (sys_exit)
          int  $0x80       # 调用内核功能
  ```

- Intel 格式
  ```asm
  ; hello.asm
  section .data            ; 数据段声明
          msg db "Hello, world!", 0xA     ; 要输出的字符串
          len equ $ - msg                 ; 字串长度
  section .text            ; 代码段声明
  global _start            ; 指定入口函数
  _start:                  ; 在屏幕上显示一个字符串
          mov edx, len     ; 参数三：字符串长度
          mov ecx, msg     ; 参数二：要显示的字符串
          mov ebx, 1       ; 参数一：文件描述符 (stdout)
          mov eax, 4       ; 系统调用号 (sys_write)
          int 0x80         ; 调用内核功能
                          ; 退出程序
          mov ebx, 0       ; 参数一：退出代码
          mov eax, 1       ; 系统调用号 (sys_exit)
          int 0x80         ; 调用内核功能
  ```

## 3. 开发形式

使用汇编语言进行开发通常具有 2 种不同的形式：

### 3.1. 完全汇编

整个程序全部用汇编语言编写。尽管是完全的汇编代码，Linux 平台下的汇编工具也吸收了 C 语言的长处，使得程序员可以使用 #include、#ifdef 等预处理指令，并能够通过宏定义来简化代码。

### 3.2. 内联汇编

TODO:

C 语言简洁易读，容易组织规模较大的代码，而汇编效率高，而且写一些特殊指令必须用汇编。为了兼顾这两方面的好处，虽然 ANSI 的 C 语言标准中没有关于内嵌汇编代码的相应规定，但大多数 C 编译器（如 GCC）都提供了一种扩展语法，可以在 C 代码中使用内联汇编 (Inline Assembly)。

但一般来讲，在 C 代码中嵌入汇编语句要比"纯粹"的汇编语言代码复杂得多，因为需要解决如何分配寄存器，以及如何与C代码中的变量相结合等问题。

i.e.
```c
/* inline.c */
int main()
{
    int a = 10, b = 0;
    __asm__ __volatile__("movl %1, %%eax;\\n\\r"
                         "movl %%eax, %0;"
                         :"=r"(b)      /* 输出 */
                         :"r"(a)       /* 输入 */
                         :"%eax");     /* 不受影响的寄存器 */

    printf("Result: %d, %d\\n", a, b);
}
```
上面的程序完成将变量a的值赋予变量b，有几点需要说明：
- 变量b是输出操作数，通过%0来引用，而变量a是输入操作数，通过%1来引用。
- 输入操作数和输出操作数都使用r进行约束，表示将变量a和变量b存储在寄存器中。输入约束和输出约束的不同点在于输出约束多一个约束修饰符'='。
- 在内联汇编语句中使用寄存器eax时，寄存器名前应该加两个'%'，即%%eax。内联汇编中使用%0、%1等来标识变量，任何只带一个'%'的标识符都看成是操作数，而不是寄存器。
- 内联汇编语句的最后一个部分告诉GCC它将改变寄存器eax中的值，GCC在处理时不应使用该寄存器来存储任何其它的值。
- 由于变量b被指定成输出操作数，当内联汇编语句执行完毕后，它所保存的值将被更新。

## 4. 汇编工具

汇编工具虽然种类很多，其中最基本的是汇编器、连接器和调试器。

### 4.1. 汇编器

汇编器（assembler）的作用是将用汇编语言编写的源程序转换成二进制形式的目标代码。

- Windows 平台

- Linux 平台

  - GAS

    Linux 平台的标准汇编器是 GAS，它是 GCC 所依赖的后台汇编工具，通常包含在 binutils 软件包中。GAS 使用标准的 AT&T 汇编语法，可以用来汇编用 AT&T 格式编写的程序：
    ```
    $ as -o hello.o hello.s
    ```

  - NASM

    Linux 平台上另一个经常用到的汇编器是 NASM，它提供了很好的宏指令功能，并能够支持相当多的目标代码格式，包括 bin、a.out、coff、elf、rdf 等。NASM 采用的是人工编写的语法分析器，因而执行速度要比 GAS 快很多，更重要的是它使用的是 Intel 汇编语法，可以用来编译用 Intel 语法格式编写的汇编程序：
    ```
    $ nasm -f elf hello.asm
    ```

### 4.2. 连接器

由汇编器产生的目标代码是不能直接在计算机上运行的，它必须经过链接器的处理才能生成可执行代码。链接器通常用来将多个目标代码连接成一个可执行代码，这样可以先将整个程序分成几个模块来单独开发，然后才将它们组合（链接）成一个应用程序。

- Windows 平台

- Linux 平台

  Linux 使用 ld 作为标准的链接程序，它同样也包含在 binutils 软件包中。汇编程序在成功通过 GAS 或 NASM 的编译并生成目标代码后，就可以使用 ld 将其链接成可执行程序了：
  ```
  $ ld -s -o hello hello.o
  ```

### 4.3. 调试器

有人说程序不是编出来而是调出来的，足见调试在软件开发中的重要作用，在用汇编语言编写程序时尤其如此。

- Windows 平台

- Linux 平台

  Linux 下调试汇编代码既可以用 GDB、DDD 这类通用的调试器，也可以使用短小精悍的专门用来调试汇编代码的 ALD(Assembly Language Debugger)。

## 5. Refer Links

[Linux 汇编语言开发指南](https://www.ibm.com/developerworks/cn/linux/l-assembly/index.html)

TODO:

[阮一峰：汇编语言入门教程](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)

