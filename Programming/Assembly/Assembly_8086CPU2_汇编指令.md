- [汇编语言：8086 汇编指令](#汇编语言8086-汇编指令)
  - [1. mov](#1-mov)
  - [2. add](#2-add)
  - [3. inc](#3-inc)
  - [4. sub](#4-sub)
  - [5. mul](#5-mul)
  - [6. div](#6-div)
  - [7. jmp](#7-jmp)
  - [8. jcxz](#8-jcxz)
  - [9. push & pop](#9-push--pop)
  - [10. loop](#10-loop)
  - [11. and](#11-and)
  - [12. or](#12-or)
  - [13. ret & retf](#13-ret--retf)
  - [14. call](#14-call)
  - [15. adc](#15-adc)
  - [16. sbb](#16-sbb)
  - [17. cmp](#17-cmp)
  - [18. pushf & popf](#18-pushf--popf)
  - [19. iret](#19-iret)
  - [20. int](#20-int)
  - [21. Refer Links](#21-refer-links)

# 汇编语言：8086 汇编指令

## 1. mov

mov 指令为传送指令。8086CPU 中大部分寄存器的值都可以通过 mov 指令来改变。

i.e.
- `mov ax,18`: 将指令缓冲器中的 18 送入 AX，相当于高级语言的 `AX=18`。
- `mov ah,78`: 将指令缓冲器中的 78 送入 BX，相当于高级语言的 `BX=78`。
- `mov ax,bx`: 将 BX 中的数据送入 AX，相当于高级语言的 `AX=BX`。
- `mov ax,ss:[0]`: 将段地址在 ss 中、偏移地址为 0 的内存单元的数据送入 AX。
- `mov ax,[bx+si]`:

NOTE
- 数据位置的表达
  - 立即数：对于直接包含在机器指令中的数据（执行前在 CPU 的指令缓冲器中），在汇编指令中直接给出。i.e. `mov ax,1`.
  - 寄存器：对于在寄存器中的数据，在汇编指令中给出相应的寄存器名称。i.e. `mov ax,bx`.
  - 段地址 SA 和偏移地址 EA：对于在内存中的数据，在汇编指令中可通过 `[]` 的格式指定 EA，而 SA 在某个段寄存器中（默认在 DS 中，也可通过段前缀显式指定）。
- 数据长度的表达
  - 可通过寄存器名称指明要处理的数据类型。i.e. `mov ax,1` 指明指令要进行的是字操作；`mov al,1` 指明指令要进行的是字节操作。
  - 在没有寄存器名存在的情况下，可通过操作符 `X ptr` 指明内存单元的长度，其中 `X` 为 `word` / `byte`。i.e. `mov word ptr ds:[0],1`.
  - 有些指令默认了访问的是字单元还是字节单元。i.e. push 指令只允许进行字操作，因此，`push [1000H]` 不用指明访问的是字单元还是字节单元。
- 在 8086CPU 中，只有 BX、SI、DI、BP 这 4 个寄存器可以用在 `[]` 中来进行内存单元的寻址。这 4 个寄存器可以单个出现，或只能以 4 种组合出现：
  - BX 和 SI
  - BX 和 DI
  - BP 和 SI
  - BP 和 DI
- 8086CPU 的寻址方式有以下类型：

  ![image](http://img.cdn.firejq.com/jpg/2019/2/16/8a555e1d1225492a50db5efc075126cc.jpg)

## 2. add

i.e.
- `add ax,8`: 将 AX 中的数值加上 8，相当于高级语言的 `AX+=8`。
- `add ax,bx`: 将 AX 和 BX 中的数值相加，结果存储在 AX 中，相当于高级语言的 `AX+=BX`。

## 3. inc

## 4. sub

## 5. mul

mul 指令是乘法指令。

## 6. div

div 指令是除法指令。

- 除数：有 8 位和 16 位，在一个 reg 或内存单元中。
- 被除数：默认放在 AX 或 AX+DX 中：
  - 如果除数为 8 位，被除数则为 16 位，默认在 AX 中存放。
  - 如果除数为 16 位，被除数则位 32 位，默认在 AX 和 DX 中存放，其中 DX 存放高 16 位，AX 存放低 16 位。
- 结果：
  - 如果除数为 8 位，则 AL 存放除法操作的商，AH 存放除法操作的余数。
  - 如果除数为 16 位，则 AX 存放除法操作的商，DX 存放除法操作的余数。

## 7. jmp

jmp 指令是最简单的转移指令，能够改变 CS、IP 寄存器的内容。

- 若希望同时修改 CS、IP 中的内容，可通过 `jmp M:N` 来完成。执行后，CS 内容为 M，IP 内容为 N。
- 若希望指修改 IP 中的内容，可通过 `jmp R` 来完成，R 为某一合法寄存器名称。执行后，IP 内容为寄存器 R 的值。

## 8. jcxz

jcxz 指令是有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目标地址。对 IP 的修改范围为：-129～127.

## 9. push & pop

8086CPU 提供了 push 和 pop 指令，来让开发者以栈的方式访问一段内存空间。如：`push ax` 表示将 AX 中的数据送入栈中，`pop ax` 表示将栈中的数据取出并送入 AX 中。

8086CPU 的入栈和出栈操作都是以字为单元进行的。

i.e.

![image](http://img.cdn.firejq.com/jpg/2019/2/16/d1bea5e2d18fea71057cd6ef3e4ebead.jpg)

NOTE：
- 8086CPU 并不保证我们对栈的操作不会越界，因此在进行汇编编程时，需要自己操心栈顶越界的问题：
  - 要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致越界。
  - 执行出栈操作时，要防止栈空的时候继续出栈而导致的越界。

- 程序经常需要进行数据的暂存，我们可以使用寄存器来暂存它们，但由于寄存器数量有限，且每个程序可使用的寄存器都不一样，因此这不是一个一般化的方法。**通常，我们会使用内存来暂存数据，即把需要暂存的数据放到内存单元中，需要使用的时候，再从内存单元中恢复。一般来说，在需要暂存数据的时候都应该使用栈作为数据结构**。

## 10. loop

loop 指令是循环指令，通常用 loop 指令来实现循环功能，cx 中存放循环次数。

`loop n` 执行时，会进行 2 步操作：
1. `(cx)=(cx)-1`
1. 判断 cx 中的值，若不为 0 则转移至标号 n 处执行程序；若为 0 则向下执行。

i.e.
```
  mov cx,100
s:
  ...some code...

  loop s
```

## 11. and

and 指令是逻辑与指令，按位进行与运算。

i.e.
```
mov al,01100011B
and al,00111011B
```
执行后：al=00100011B

## 12. or

or 指令是逻辑或指令，按位进行或运算。

i.e.
```
mov al,01100011B
or al,00111011B
```
执行后：al=01111011B

## 13. ret & retf

ret 指令用栈中的数据，修改 IP 的内容，从而实现近转移。

retf 指令用栈中的数据，修改 CS 和 IP 中的内容，从而实现远转移。

## 14. call

call 指令执行时，实际上进行了 2 步操作：
1. 将当前的 IP 和 CS 或 IP 压入栈中。
1. 转移。

NOTE：call 指令不能实现短转移。

指令格式：
- `call 16-bits_reg`
- `call 标号`
- `call far prt 标号`
- `call word ptr 内存单元地址`
- `call dword ptr 内存单元地址`

## 15. adc

adc 指令是带进位加法指令，它利用了 CF 位上记录的进位值。

i.e.
```
adc 操作对象 1, 操作对象 2
```
执行后，操作对象 1 = 操作对象 1 + 操作对象 2 + CF

## 16. sbb

sbb 指令是带借位减法指令，它利用了 CF 位上记录的借位值。

i.e.
```
sbb 操作对象 1, 操作对象 2
```
执行后，操作对象 1 = 操作对象 1 - 操作对象 2 - CF

## 17. cmp

cmp 指令是比较指令，执行后其它相关指令可通过被影响的标志寄存器 FLAG 位来得知比较结果。

i.e.
```
cmp 操作对象 1, 操作对象 2
```
执行后，计算操作对象 1 - 操作对象 2 但不保存结果，仅仅根据计算结果对 FLAG 进行设置。

## 18. pushf & popf

pushf 指令将 FLAG 寄存器的值压栈，popf 指令将值从栈中弹出，送入 FLAG 寄存器中。

pushf 和 popf 为直接访问 FLAG 寄存器提供了一种方法。

## 19. iret

iret 指令的功能用汇编语法描述为：
```
pop IP
pop CS
popf
```

iret 指令通常和硬件自动完成的中断过程配合使用。iret 指令执行后，CPU 回到执行中断处理程序前的执行点继续执行程序。

## 20. int

int 指令用于引发内中断过程，其指令格式为：
```
int n
```
其中，n 为中断类型码。

## 21. Refer Links
