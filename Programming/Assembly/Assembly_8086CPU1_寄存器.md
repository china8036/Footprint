- [汇编语言：8086 寄存器](#汇编语言8086-寄存器)
  - [1. 通用寄存器 (General Register)](#1-通用寄存器-general-register)
  - [2. 段寄存器 (Segment Register)](#2-段寄存器-segment-register)
  - [3. 指令寄存器 (Instruction Register)](#3-指令寄存器-instruction-register)
  - [4. 地址寄存器 (Index Register)](#4-地址寄存器-index-register)
  - [5. 标志寄存器 (Status Register)](#5-标志寄存器-status-register)
  - [6. Refer Links](#6-refer-links)

# 汇编语言：8086 寄存器

**在 CPU 中，程序员能用指令读写的部件只有寄存器，通过改变各种寄存器中的内容可以实现对 CPU 的控制**。因此，对于一个汇编程序员来说，CPU 中最主要的部件就是寄存器。

不同的 CPU 中寄存器的个数和结构都是不同的。

对于 8086 CPU，有 14 个寄存器，所有寄存器都是 16 位的，各自可以存放 2 个字节。每个寄存器都有一个名称：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。

![image](http://img.cdn.firejq.com/jpg/2019/2/16/1efc2f463c23c35d7b4b920e9e919aad.jpg)

P.S.
- [汇编语言里所有寄存器，就是现代 CPU 内部中所有的寄存器吗？](https://www.zhihu.com/question/24229120)

  CPU 硬件里的寄存器不只这些，尤其是 CPU 支持多级流水以及乱序发射之后，有很多内部的寄存器被流水线电路使用，但是这些寄存器不是软件可见的，所以对开发者是透明的，指令集 ISA 决定编译器可以看到的寄存器。

  从 X86 到 X64 转换的时候，不光寄存器的位数增加了，寄存器的个数也增加了，后面加了 8 个通用寄存器；而且还有指令集的扩展比如 SSE, SSE2 等也会引入一些新的寄存器。

## 1. 通用寄存器 (General Register)

8086CPU 有 4 个通用寄存器：AX、BX、CX、DX，通常用来存放一般性数据：
- AX：累加寄存器
- BX：基址寄存器
- CX：计数寄存器
- DX：数据寄存器

![image](http://img.cdn.firejq.com/jpg/2019/2/15/bb12d4ce5af36bc3ff603a5600cbba93.jpg)

由于 8086CPU 的上一代 CPU 中寄存器都是 8 位的，因此为保证兼容，8086CPU 的通用寄存器都可以拆分为 2 个可独立使用的 8 位寄存器：
- AX 可分为 AH 和 AL。AX 的低 8 位构成了 AL 寄存器，高 8 位构成来 AH 寄存器。
- BX 可分为 BH 和 BL。BX 的低 8 位构成了 BL 寄存器，高 8 位构成来 BH 寄存器。
- CX 可分为 CH 和 CL。CX 的低 8 位构成了 CL 寄存器，高 8 位构成来 CH 寄存器。
- DX 可分为 DH 和 DL。DX 的低 8 位构成了 DL 寄存器，高 8 位构成来 DH 寄存器。

i.e.

![image](http://img.cdn.firejq.com/jpg/2019/2/15/f6a92003f0fdc8b5dacebb6ed039a27e.jpg)

## 2. 段寄存器 (Segment Register)

8086CPU 在访问内存时需要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。那么，什么部件提供段地址呢？

8086CPU 中有 4 个段地址寄存器：CS、DS、SS、ES，当 CPU 访问内存时，就由这 4 个段寄存器提供内存单元的段地址：
- CS: 代码段寄存器。

- DS: 数据段寄存器。

  CPU 读写一个内存单元时，必须先给出这个内存单元的物理地址。i.e.
  ```asm
  mov al, [xxx]
  ```
  指令执行时，8086CPU 自动读取 DS 的数据作为段地址，并以 xxx 为偏移地址，组成内存单元的物理地址，然后将内存单元中的内容送入 AL 寄存器中保存。

- ES: 附加段寄存器。

- SS: 堆栈段寄存器。

  8086CPU 提供了以栈的方式访问一段内存的机制。任意时刻，栈顶的段地址存放在 SS 中，栈顶的偏移地址存放在 SP 中，SS:SP 指向栈顶元素。

NOTE:
- 8086CPU 不支持直接使用数据为段寄存器赋值的操作，即 `mov ds,1000H` 这样的指令是非法的。因此，需要使用一个通用寄存器来做中转：
  ```
  mov bx, 1000H
  mov ds, bx
  ```

## 3. 指令寄存器 (Instruction Register)

段寄存器 CS 和指令寄存器 IP 时 8086CPU 中两个最关键的寄存器，它们指示了 CPU 当前要读取并执行的下一条指令的地址，CS 提供段地址，IP 提供偏移地址。

任意时刻，设 CS 内容为 M，IP 内容为 N，则 8086CPU 将从内存 M*15+N 位置的内存单元开始，读取一条指令并执行。也就是说，任意时刻 8086CPU 将 CS:IP 指向的内容当作指令执行。

在 8086CPU 加电启动或复位后，CS 和 IP 会被设置为 `CS=FFFFH, IP=0000H`，即 8086PC 刚启动时，CPU 会从内存 FFFF0H 的单元中读取指令并开始执行，FFFF0H 单元中的指令是 8086CPU 开机后执行的第一条指令。

## 4. 地址寄存器 (Index Register)

- SI: 源变址寄存器。

- DI: 目的变址寄存器。

- SP: 堆栈指针寄存器。

  任意时刻，栈顶的段地址存放在 SS 中，栈顶的偏移地址存放在 SP 中，SS:SP 指向栈顶元素。

- BP: 基址指针寄存器。

## 5. 标志寄存器 (Status Register)

标志寄存器 FLAG 是一种特殊的寄存器，它具有以下作用：
- 用来存储相关指令的某些执行结果。
- 用来为 CPU 执行相关指令提供行为证据。
- 用来控制 CPU 的相关工作方式。

8086CPU 的标志寄存器有 16 位，其中存储的信息通常被称为程序状态字 (PSW)。不同于其它寄存器只具有一个含义，FLAG 寄存器按位起作用，每一位都有专门的含义，记录特定的信息。

8086CPU 的 FLAG 寄存器结构如下：

![image](http://img.cdn.firejq.com/jpg/2019/2/16/ba6094e501e90f83b4a5daa7b78c69fb.jpg)

其中，第 1、3、5、12、13、14、15 位在 8086CPU 中没有使用，不具有任何含义，而 0、2、4、6、7、8、9、10、11 位都各自具有特殊的含义：
- ZF 标志：FLAG 第 6 位为零标志位。它记录相关指令执行后，其结果是否为 0。如果结果为 0，则 ZF=1；如果结果不为 0，则 ZF=0。
- PF 标志：FLAG 第 2 位为奇偶标志位。它记录相关指令执行后，其结果的所有 bit 位中 1 的个数是否为偶数。如果 1 的个数为偶数，则 PF=1；如果 1 的个数不为偶数，则 PF=0。
- SF 标志：FLAG 第 7 位为符号标志位。它记录相关指令执行后，其结果是否为负数。如果结果为负数，则 SF=1；如果结果不为负数，则 SF=0。
- CF 标志：FLAG 第 0 位为进位标志位。它记录无符号数运算时，其结果是否拥有进位值。
- OF 标志：FLAG 第 11 位为溢出标志位。它记录有符号数运算时，其结果是否发生了溢出。
- DF 标志：FLAG 第 10 位为方向标志位。在串处理指令 (i.e. movsb、movsw) 中，控制每次操作后 SI、DI 的增减。如果 DF=0，则每次操作后 SI、DI 递增；如果 DF=1，则每次操作后 SI、DI 递减。

## 6. Refer Links
