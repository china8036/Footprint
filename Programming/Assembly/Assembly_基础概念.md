- [汇编语言：基础概念](#汇编语言基础概念)
  - [1. 基本概念](#1-基本概念)
    - [1.1. 发展由来](#11-发展由来)
    - [1.2. 应用意义](#12-应用意义)
    - [1.3. 优缺点](#13-优缺点)
  - [2. 汇编源程序](#2-汇编源程序)
    - [2.1. 汇编指令](#21-汇编指令)
    - [2.2. 伪指令](#22-伪指令)
      - [2.2.1. segment & ends](#221-segment--ends)
      - [2.2.2. end](#222-end)
      - [2.2.3. assume](#223-assume)
      - [2.2.4. db & dw & dd](#224-db--dw--dd)
      - [2.2.5. dup](#225-dup)
      - [offset](#offset)
      - [2.2.6. 标号](#226-标号)
    - [2.3. 其它符号](#23-其它符号)
  - [3. 语法格式](#3-语法格式)
    - [3.1. Intel 汇编格式](#31-intel-汇编格式)
    - [3.2. AT&T / GAS 汇编格式](#32-att--gas-汇编格式)
    - [3.3. 语法格式区别](#33-语法格式区别)
  - [4. 开发形式](#4-开发形式)
    - [4.1. 完全汇编](#41-完全汇编)
    - [4.2. 内联汇编](#42-内联汇编)
  - [5. 汇编工具](#5-汇编工具)
    - [5.1. 汇编器](#51-汇编器)
    - [5.2. 连接器](#52-连接器)
    - [5.3. 调试器](#53-调试器)
  - [6. Refer Links](#6-refer-links)

# 汇编语言：基础概念

## 1. 基本概念

### 1.1. 发展由来

机器指令是一个处理器可以正确执行的命令，电子计算机的机器指令是一列二进制数字，计算机将其转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算。

最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。

为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。

这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。**汇编语言的主体是汇编指令。汇编指令和机器指令和差别在于指令的表示方式上，汇编指令是机器指令便于记忆的书写格式**。

i.e. 寄存器 BX 的内容送到 AX 中：
- 机器指令：`1000100111011000`
- 汇编指令：`mov ax, bx`

每一种微处理器，由于硬件设计和内部结构的不同，就需要不同的电平脉冲来控制工作，因此，**每一种 CPU 的机器指令都是不一样的，对应的汇编语言也不一样**。

### 1.2. 应用意义

![image](http://img.cdn.firejq.com/jpg/2019/2/15/c5dc5159750f4d8d0f874304ade9e03b.jpg)

作为最基本的编程语言之一，汇编语言虽然应用的范围不算很广，但重要性却勿庸置疑，因为它能够完成许多其它语言所无法完成的功能。就拿 Linux 内核来讲，虽然绝大部分代码是用 C 语言编写的，但仍然不可避免地在某些关键地方使用了汇编代码，其中主要是在 Linux 的启动部分。由于这部分代码与硬件的关系非常密切，即使是 C 语言也会有些力不从心，而汇编语言则能够很好扬长避短，最大限度地发挥硬件的性能。

大多数情况下 Linux 程序员不需要使用汇编语言，因为即便是硬件驱动这样的底层程序在 Linux 操作系统中也可以用完全用 C 语言来实现，再加上 GCC 这一优秀的编译器目前已经能够对最终生成的代码进行很好的优化，的确有足够的理由让我们可以暂时将汇编语言抛在一边了。但实现情况是 Linux 程序员有时还是需要使用汇编，或者不得不使用汇编，理由很简单：精简、高效和 libc 无关性。假设要移植 Linux 到某一特定的嵌入式硬件环境下，首先必然面临如何减少系统大小、提高执行效率等问题，此时或许只有汇编语言能帮上忙了。

### 1.3. 优缺点

- 汇编语言直接同计算机的底层软件甚至硬件进行交互，它具有如下优点：

  - 能够直接访问与硬件相关的存储器或 I/O 端口。
  - 能够不受编译器的限制，对生成的二进制代码进行完全的控制。
  - 能够对关键代码进行更准确的控制，避免因线程共同访问或者硬件设备共享引起的死锁。
  - 能够根据特定的应用对代码做最佳的优化，提高运行速度。
  - 能够最大限度地发挥硬件的功能。

- 汇编语言是一种层次非常低的语言，它仅仅高于直接手工编写二进制的机器指令码，因此不可避免地存在一些缺点：

  - 编写的代码非常难懂，不好维护。
  - 很容易产生 bug，难于调试。
  - 只能针对特定的体系结构和处理器进行优化。
  - 开发效率很低，时间长且单调。

## 2. 汇编源程序

随着汇编语言的发展，主要由以下 3 类指令组成：

### 2.1. 汇编指令

机器码的助记符，每一个汇编指令都有对应的机器码。**汇编语言的核心是汇编指令，它决定了汇编语言的特性**。

### 2.2. 伪指令

没有对应的机器码，由编译器执行，编译器会根据伪指令进行相关的编译工作。

#### 2.2.1. segment & ends

segment 和 ends 是一对成对使用的伪指令，其作用是定义一个代码段：
```
segment_name segment
  ...
segment_name ends
```

一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。

#### 2.2.2. end

end 是汇编程序结束的结束标记，当编译器遇到了 end 指令时，就停止了对源程序的编译。

#### 2.2.3. assume

assume 指令假设某一段寄存器和程序中的某一个段相关联。通过 assumen 伪指令说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。

#### 2.2.4. db & dw & dd

db (define byte) 用于在编译期间开辟字节空间并定义字节型数据；dw (define word) 用于在编译期间开辟字空间并定义字型数据；dd (define double word) 用于在编译期间开辟双字空间并定义双字型数据。

i.e.
```asm
assume cs:code
code segment
  dw 0123h,0456h,0789h,0abch,0defh,0cbah,0987h
  mov bx,0
  mov ax,0

  mov cx,8
s:add ax,cs:[bx]
  add bx,2
  loop s

  mov ax,4c00h
  int 21h

code ends
end
```
- 程序中使用 dw 定义了 8 个字型数据，它们所占的内存空间的大小为 16 Bytes。
- 程序运行时 CS 中存放了代码段的段地址，因此可以通过 CS 得到这 8 个数据的段地址。且由于 dw 定义的数据位于代码段的最开始，所以偏移地址为 0，这 8 个数据就在代码段的偏移 0、2、4、6、8、A、C、E 处。程序运行时，它们的地址就是 CS:0、CS:2、CS:4、CS:6、CS:8、CS:A、CS:C、CS:E。
- 程序中通过 loop 循环对这 8 个数据进行了累加。

#### 2.2.5. dup

dup 双和 db、dw、dd 等数据定义伪指令相配合使用的，用于进行数据的重复定义。

i.e.
- 定义 3 个字节，值都为 0:
  ```
  dp 3 dup (0)
  ```
  相当于：
  ```
  db 0,0,0
  ```
- 定义 9 个字节，值为 0、1、2、0、1、2、0、1、2:
  ```
  dp 3 dup (0,1,2)
  ```
  相当于：
  ```
  db 0,1,2,0,1,2,0,1,2
  ```

#### offset

offset的功能是取得标号的偏移地址。

i.e.
```
start:mov ax,offset start
    s:mov ax,offset s
```

#### 2.2.6. 标号

汇编源程序中，有一些可以用来指代地址的标号。

i.e.
```asm
assume cs:codesg

codesg segment
  mov ax,0123H
  mov bx,0456H
  int 21H
codesg ends

end
```
`codesg` 作为一个段的标号，最终将被编译、连接程序处理为一个段的地址。

### 2.3. 其它符号

没有对应的机器码，由编译器识别，如 `+` / `-` / `*` 等。

在汇编程序中，用 `'...'` 的方式指明数据是以字符形式给出的，**编译器将把它们转换为相应的 ASCII 码**。

## 3. 语法格式

**在汇编语言中，汇编指令或寄存器名称都不区分大小写。如：`mov ax,18` 和 `MOV AX,18` 的含义相同**。

由于汇编语言和具体的微处理器相绑定，每个处理器平台甚至同一平台的不同汇编器所支持的“汇编语言”也都不一样。以实际硬件的机器语言 / 汇编为目标，具体的语法细节都需要参照各自的手册（ISA 手册 / 汇编器手册）。

常见的汇编语法格式有以下 2 种：

### 3.1. Intel 汇编格式

在 DOS/Windows 系统中的汇编语言都是 Intel 风格的。

### 3.2. AT&T / GAS 汇编格式

在 Unix/Linux 系统中的汇编语言通常是 AT&T 风格的，但在新的汇编器版本中也支持了 Intel 风格，但更多采用的还是 AT&T 格式。

由于在 Unix/Linux 系统中通常使用的是 GNU 汇编器（GCC 后端），AT&T 汇编格式也称为 GAS(GNU ASembler) 汇编格式。

### 3.3. 语法格式区别

- 在 AT&T 汇编格式中，寄存器名要加上 '%' 作为前缀；而在 Intel 汇编格式中，寄存器名不需要加前缀。
- 在 AT&T 汇编格式中，用 '$' 前缀表示一个立即操作数；而在 Intel 汇编格式中，立即数的表示不用带任何前缀。
- 在 Intel 汇编格式中，目标操作数在源操作数的左边；而在 AT&T 汇编格式中，目标操作数在源操作数的右边。
- 在 AT&T 汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀'b'、'w'、'l'分别表示操作数为字节（byte，8 比特）、字（word，16 比特）和长字（long，32 比特）；而在 Intel 汇编格式中，操作数的字长是用 "byte ptr" 和 "word ptr" 等前缀来表示的。
- 在 AT&T 汇编格式中，绝对转移和调用指令（jump/call）的操作数前要加上'*'作为前缀，而在 Intel 格式中则不需要。
- 远程转移指令和远程子调用指令的操作码，在 AT&T 汇编格式中为 "ljump" 和 "lcall"，而在 Intel 汇编格式中则为 "jmp far" 和 "call far"。
- 在 AT&T 汇编格式中，内存操作数的寻址方式是 `section:disp(base, index, scale)`；而在 Intel 汇编格式中，内存操作数的寻址方式为 `section:[base + index*scale + disp]`。

i.e.
- AT&T 格式
  ```asm
  #hello.s
  .data                    # 数据段声明
          msg : .string "Hello, world!\\n" # 要输出的字符串
          len = . - msg                   # 字串长度
  .text                    # 代码段声明
  .global _start           # 指定入口函数

  _start:                  # 在屏幕上显示一个字符串
          movl $len, %edx  # 参数三：字符串长度
          movl $msg, %ecx  # 参数二：要显示的字符串
          movl $1, %ebx    # 参数一：文件描述符 (stdout)
          movl $4, %eax    # 系统调用号 (sys_write)
          int  $0x80       # 调用内核功能

                          # 退出程序
          movl $0,%ebx     # 参数一：退出代码
          movl $1,%eax     # 系统调用号 (sys_exit)
          int  $0x80       # 调用内核功能
  ```

- Intel 格式
  ```asm
  ; hello.asm
  section .data            ; 数据段声明
          msg db "Hello, world!", 0xA     ; 要输出的字符串
          len equ $ - msg                 ; 字串长度
  section .text            ; 代码段声明
  global _start            ; 指定入口函数
  _start:                  ; 在屏幕上显示一个字符串
          mov edx, len     ; 参数三：字符串长度
          mov ecx, msg     ; 参数二：要显示的字符串
          mov ebx, 1       ; 参数一：文件描述符 (stdout)
          mov eax, 4       ; 系统调用号 (sys_write)
          int 0x80         ; 调用内核功能
                          ; 退出程序
          mov ebx, 0       ; 参数一：退出代码
          mov eax, 1       ; 系统调用号 (sys_exit)
          int 0x80         ; 调用内核功能
  ```

## 4. 开发形式

使用汇编语言进行开发通常具有 2 种不同的形式：

### 4.1. 完全汇编

整个程序全部用汇编语言编写。尽管是完全的汇编代码，Linux 平台下的汇编工具也吸收了 C 语言的长处，使得程序员可以使用 #include、#ifdef 等预处理指令，并能够通过宏定义来简化代码。

### 4.2. 内联汇编

TODO:

C 语言简洁易读，容易组织规模较大的代码，而汇编效率高，而且写一些特殊指令必须用汇编。为了兼顾这两方面的好处，虽然 ANSI 的 C 语言标准中没有关于内嵌汇编代码的相应规定，但大多数 C 编译器（如 GCC）都提供了一种扩展语法，可以在 C 代码中使用内联汇编 (Inline Assembly)。

但一般来讲，在 C 代码中嵌入汇编语句要比"纯粹"的汇编语言代码复杂得多，因为需要解决如何分配寄存器，以及如何与 C 代码中的变量相结合等问题。

i.e.
```c
/* inline.c */
int main()
{
    int a = 10, b = 0;
    __asm__ __volatile__("movl %1, %%eax;\\n\\r"
                         "movl %%eax, %0;"
                         :"=r"(b)      /* 输出 */
                         :"r"(a)       /* 输入 */
                         :"%eax");     /* 不受影响的寄存器 */

    printf("Result: %d, %d\\n", a, b);
}
```
上面的程序完成将变量 a 的值赋予变量 b，有几点需要说明：
- 变量 b 是输出操作数，通过 %0 来引用，而变量 a 是输入操作数，通过 %1 来引用。
- 输入操作数和输出操作数都使用 r 进行约束，表示将变量 a 和变量 b 存储在寄存器中。输入约束和输出约束的不同点在于输出约束多一个约束修饰符'='。
- 在内联汇编语句中使用寄存器 eax 时，寄存器名前应该加两个'%'，即 %%eax。内联汇编中使用 %0、%1 等来标识变量，任何只带一个'%'的标识符都看成是操作数，而不是寄存器。
- 内联汇编语句的最后一个部分告诉 GCC 它将改变寄存器 eax 中的值，GCC 在处理时不应使用该寄存器来存储任何其它的值。
- 由于变量 b 被指定成输出操作数，当内联汇编语句执行完毕后，它所保存的值将被更新。

## 5. 汇编工具

汇编工具虽然种类很多，其中最基本的是汇编器、连接器和调试器。

### 5.1. 汇编器

汇编器（assembler）的作用是将用汇编语言编写的源程序转换成二进制形式的目标代码。

- Windows 平台

- Linux 平台

  - GAS

    Linux 平台的标准汇编器是 GAS，它是 GCC 所依赖的后台汇编工具，通常包含在 binutils 软件包中。GAS 使用标准的 AT&T 汇编语法，可以用来汇编用 AT&T 格式编写的程序：
    ```
    $ as -o hello.o hello.s
    ```

  - NASM

    Linux 平台上另一个经常用到的汇编器是 NASM，它提供了很好的宏指令功能，并能够支持相当多的目标代码格式，包括 bin、a.out、coff、elf、rdf 等。NASM 采用的是人工编写的语法分析器，因而执行速度要比 GAS 快很多，更重要的是它使用的是 Intel 汇编语法，可以用来编译用 Intel 语法格式编写的汇编程序：
    ```
    $ nasm -f elf hello.asm
    ```

### 5.2. 连接器

由汇编器产生的目标代码是不能直接在计算机上运行的，它必须经过链接器的处理才能生成可执行代码。链接器通常用来将多个目标代码连接成一个可执行代码，这样可以先将整个程序分成几个模块来单独开发，然后才将它们组合（链接）成一个应用程序。

- Windows 平台

- Linux 平台

  Linux 使用 ld 作为标准的链接程序，它同样也包含在 binutils 软件包中。汇编程序在成功通过 GAS 或 NASM 的编译并生成目标代码后，就可以使用 ld 将其链接成可执行程序了：
  ```
  $ ld -s -o hello hello.o
  ```

### 5.3. 调试器

有人说程序不是编出来而是调出来的，足见调试在软件开发中的重要作用，在用汇编语言编写程序时尤其如此。

- Windows 平台

- Linux 平台

  Linux 下调试汇编代码既可以用 GDB、DDD 这类通用的调试器，也可以使用短小精悍的专门用来调试汇编代码的 ALD(Assembly Language Debugger)。

## 6. Refer Links

[Linux 汇编语言开发指南](https://www.ibm.com/developerworks/cn/linux/l-assembly/index.html)

[阮一峰：汇编语言入门教程](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)
