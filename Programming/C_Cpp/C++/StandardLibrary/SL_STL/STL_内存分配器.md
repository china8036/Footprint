- [STL 内存分配器](#stl- 内存分配器)
  - [3. Refer Links](#3-refer-links)

# STL 内存分配器

关于内存管理的话题，大致有两类侧重点：
- 一类是内存的正确使用，例如 C++ 中 new 和 delete 应该成对出现，用 RAII 技巧管理内存资源，auto_ptr 等方面，很多 C/C++ 书籍中都使用技巧的介绍。
- 另一类是内存管理的实现，如 linux 内核的 slab 分配器，STL 中的 allocator 实现，以及一些特定于某种对象的内存管理等。 

STL 的默认内存分配器：
 
STL 默认的 allocator 是一个由两级分配器构成的内存管理器：
- 如果申请的内存大小大于 128byte 时，就启动第一级分配器通过 malloc 直接向系统的堆空间分配。
- 如果申请的内存大小小于 128byte 时，就启动第二级分配器，从一个预先分配好的内存池中取一块内存交付给用户。这个内存池由 16 个不同大小（8 的倍数，8~128byte）的空闲列表组成，allocator 会根据申请内存的大小（将这个大小 round up 成 8 的倍数）从对应的空闲块列表取表头块给用户。 

这种做法有两个优点： 
- 小对象的快速分配。小对象是从内存池分配的，这个内存池是系统调用一次 malloc 分配一块足够大的区域给程序备用，当内存池耗尽时再向系统申请一块新的区域，整个过程类似于批发和零售，起先是由 allocator 向总经商批发一定量的货物，然后零售给用户，与每次都总经商要一个货物再零售给用户的过程相比，显然是快捷了。当然，这里的一个问题时，内存池会带来一些内存的浪费，比如当只需分配一个小对象时，为了这个小对象可能要申请一大块的内存池，但这个浪费还是值得的，况且这种情况在实际应用中也并不多见。 
- 避免了内存碎片的生成。程序中的小对象的分配极易造成内存碎片，给操作系统的内存管理带来了很大压力，系统中碎片的增多不但会影响内存分配的速度，而且会极大地降低内存的利用率。以内存池组织小对象的内存，从系统的角度看，只是一大块内存池，看不到小对象内存的分配和释放。 

## 3. Refer Links

[STL 中的内存分配器原理](https://blog.csdn.net/effective_coder/article/details/8873513)