- [C++ Core Language：基本语法](#c-core-language基本语法)
  - [1. 变量](#1-变量)
    - [1.1. 标识符](#11-标识符)
    - [1.2. 声明 & 定义](#12-声明--定义)
    - [1.3. 作用域](#13-作用域)
    - [1.4. 常量](#14-常量)
  - [2. 数据类型](#2-数据类型)
    - [2.1. 基本类型（内置类型）](#21-基本类型内置类型)
    - [2.2. 复合类型](#22-复合类型)
      - [2.2.1. 引用类型](#221-引用类型)
      - [2.2.2. 指针类型](#222-指针类型)
    - [2.3. 类型转换](#23-类型转换)
      - [2.3.1. 隐式类型转换](#231-隐式类型转换)
      - [2.3.2. 强制类型转换](#232-强制类型转换)
        - [2.3.2.1. C 风格](#2321-c-风格)
        - [2.3.2.2. C++ API](#2322-c-api)
  - [3. 字面值常量](#3-字面值常量)
  - [4. 表达式](#4-表达式)
    - [4.1. 运算符](#41-运算符)
    - [4.2. 算术表达式](#42-算术表达式)
    - [4.3. 逻辑表达式](#43-逻辑表达式)
    - [4.4. 赋值表达式](#44-赋值表达式)
    - [4.5. 条件表达式](#45-条件表达式)
    - [4.6. 逗号表达式](#46-逗号表达式)
  - [5. 流程控制](#5-流程控制)
    - [5.1. 选择控制](#51-选择控制)
      - [5.1.1. if](#511-if)
      - [5.1.2. switch](#512-switch)
    - [5.2. 循环控制](#52-循环控制)
      - [5.2.1. while](#521-while)
      - [5.2.2. for](#522-for)
    - [5.3. 转向控制](#53-转向控制)
  - [6. Refer Links](#6-refer-links)

# C++ Core Language：基本语法

<!-- TODO:

先把 C++Primer 中的第一章的内容看完，看的过程中对要摘抄记录的部分划笔记。
再根据大一的时候的那个课本，进行知识点的归纳和梳理，C++Primer 里边的部分作为补充归纳到笔记里。
再看 C++Primer 的后边章节，归纳梳理“标准库”的笔记，和 STL 的笔记，结合一些网上的博客。 -->

## 1. 变量

### 1.1. 标识符

### 1.2. 声明 & 定义

### 1.3. 作用域

### 1.4. 常量

## 2. 数据类型

C++ 中每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围以及该变量能参与的运算。

### 2.1. 基本类型（内置类型）

下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。

注意：不同系统会有所差异。

TODO:

| 类型               | 位            | 范围                                                    |
| :----------------- | :------------ | :------------------------------------------------------ |
| char               | 1 个字节      | -128 到 127 或者 0 到 255                               |
| unsigned char      | 1 个字节      | 0 到 255                                                |
| signed char        | 1 个字节      | -128 到 127                                             |
| int                | 4 个字节      | -2147483648 到 2147483647                               |
| unsigned int       | 4 个字节      | 0 到 4294967295                                         |
| signed int         | 4 个字节      | -2147483648 到 2147483647                               |
| short int          | 2 个字节      | -32768 到 32767                                         |
| unsigned short int | 2 个字节      | 0 到 65,535                                             |
| signed short int   | 2 个字节      | -32768 到 32767                                         |
| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |
| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |
| unsigned long int  | 8 个字节      | 0 to 18,446,744,073,709,551,615                         |
| float              | 4 个字节      | +/- 3.4e +/- 38 (~7 个数字)                             |
| double             | 8 个字节      | +/- 1.7e +/- 308 (~15 个数字)                           |
| long double        | 16 个字节     | +/- 1.7e +/- 308 (~15 个数字)                           |
| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                              |

### 2.2. 复合类型

#### 2.2.1. 引用类型

#### 2.2.2. 指针类型

### 2.3. 类型转换

[c++ 四种强制类型转换介绍](https://blog.csdn.net/ydar95/article/details/69822540)

P.S. TODO:
- [在 C++ 中，0 是一个八进制数](http://justjavac.com/other/2013/03/03/is-0-a-decimal-literal-or-an-octal-literal.html).

  根据 C++ 标准：
  ```
  2.14.2 整数 [lex.icon]
  integer-literal:
      decimal-literal integer-suffixopt
      octal-literal integer-suffixopt
      hexadecimal-literal integer-suffixopt
  decimal-literal:
      nonzero-digit
      decimal-literal digit
  octal-literal:
      0                    <-------------------- 这里规定了 0 属于八进制数
      octal-literal octal-digit
  ```
- 若一个二进制数有 n 个二进制位，则这个数的最大值是 2^n-1，最高位的 1 是 2^(n-1)。

#### 2.3.1. 隐式类型转换

#### 2.3.2. 强制类型转换

##### 2.3.2.1. C 风格

```c
TypeName b = (TypeName)a;
```
C++ 支持 C 风格的强制转换，但 C 风格的强制转换可能带来一些隐患，让一些问题难以察觉。

##### 2.3.2.2. C++ API

为解决 C 风格的类型强制转换存在的问题，C++ 提供了一组可以用在不同场合的强制转换的函数

- **const_cast**

  const_cast 一般用于修改指针，如 const char *p 形式：
  - 常量指针被转化成非常量的指针，并且仍然指向原来的对象。
  - 常量引用被转换成非常量的引用，并且仍然指向原来的对象。

  ```cpp
  int main() {
      // 原始数组
      int ary[4] = { 1,2,3,4 };

      // 常量化数组指针
      const int*c_ptr = ary;
      //c_ptr[1] = 233;   //error

      // 通过 const_cast<Ty> 去常量
      int *ptr = const_cast<int*>(c_ptr);

      // 修改数据
      for (int i = 0; i < 4; i++)
          ptr[i] += 1;    //pass

      return 0;
  }
  ```

- **static_cast**

  > 事实上，C++ 的任何的隐式转换都是使用 static_cast 来实现的。
  - static_cast 作用和 C 语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和 C 语言风格的强制转换都有安全隐患。
  - 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
  - 用于基本数据类型之间的转换，如把 int 转换成 char，把 int 转换成 enum。这种转换的安全性需要开发者来维护。
  - static_cast 不能转换掉原有类型的 const、volatile、或者 __unaligned 属性（前两种可以使用 const_cast 来去除）。

  ```cpp
  /* 常规的使用方法 */
  float f_pi=3.141592f
  int   i_pi=static_cast<int>(f_pi); /// i_pi 的值为 3

  /* class 的上下行转换 */
  class Base{
      // something
  };
  class Sub:public Base{
      // something
  }

  // 上行 Sub -> Base
  // 编译通过，安全
  Sub sub;
  Base *base_ptr = static_cast<Base*>(&sub);

  // 下行 Base -> Sub
  // 编译通过，不安全
  Base base;
  Sub *sub_ptr = static_cast<Sub*>(&base);
  ```

- **dynamic_cast**

  dynamic_cast 强制转换，应该是这四种中最特殊的一个，因为他涉及到面向对象的多态性和程序运行时的状态，也与编译器的属性设置有关。所以不能完全使用 C 语言的强制转换替代，它也是最常有用的，最不可缺少的一种强制转换。

- **reinterpret_cast**

  reinterpret_cast 为操作数的位模式提供较低层次的重新解释，但是他仅仅是重新解释了给出的对象的比特模型，并没有进行二进制的转换。

  reinterpret_cast 通常用于：
  - 任意的指针之间的转换
  - 引用之间的转换
  - 指针和足够大的 int 型之间的转换
  - 整数到指针的转换

## 3. 字面值常量

## 4. 表达式

### 4.1. 运算符

| 优先权 | 运算符       | 说明                                      | 结合性   |
| ------ | ------------ | ----------------------------------------- | -------- |
| 1      | ()           | 括号                                      | 由左至右 |
| 2      | !、-、++、-- | 逻辑运算子 NOT、算术运算子负号、递增、递减 | 由右至左 |
| 3      | *、/、%      | 算术运算子的乘法、除法、馀数              | 由左至右 |
| 4      | +、-         | 算术运算子加法、减法                      | 由左至右 |
| 5      | <<、>>、>>>  | 位元运算子左移、右移、无符号右移          | 由左至右 |
| 6      | >、>=、<、<= | 关系运算子大于、大于等于、小于、小于等于  | 由左至右 |
| 7      | ==、!=       | 关系运算子等于、不等于                    | 由左至右 |
| 8      | &            | 位元运算子 AND                             | 由左至右 |
| 9      | ^            | 位元运算子 XOR                             | 由左至右 |
| 10     | ｜           | 位元运算子 OR                              | 由左至右 |
| 11     | &&           | 逻辑运算子 AND                             | 由左至右 |
| 12     | ｜｜         | 逻辑运算子 OR                              | 由左至右 |
| 13     | ?:           | 条件控制运算子                            | 由右至左 |
| 14     | =、op=       | 指定运算子                                | 由右至左 |

### 4.2. 算术表达式

### 4.3. 逻辑表达式

### 4.4. 赋值表达式

### 4.5. 条件表达式

### 4.6. 逗号表达式

## 5. 流程控制

### 5.1. 选择控制

#### 5.1.1. if

#### 5.1.2. switch

### 5.2. 循环控制

#### 5.2.1. while

#### 5.2.2. for

### 5.3. 转向控制

## 6. Refer Links