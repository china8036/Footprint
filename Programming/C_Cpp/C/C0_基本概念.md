- [C 语言：基础概念](#c-语言基础概念)
  - [1. 基础概念](#1-基础概念)
  - [2. 发展历史](#2-发展历史)
  - [3. C 编译器](#3-c-编译器)
  - [4. C 运行库](#4-c-运行库)
  - [5. 语言特点](#5-语言特点)
  - [6. 内存管理](#6-内存管理)
  - [7. Refer Links](#7-refer-links)

# C 语言：基础概念

## 1. 基础概念

C 语言作为一门应用途广泛、功能强大、使用灵活的面向过程的通用程序设计语言，广泛用于系统软件与应用软件的开发，数据库管理系统 MySQL、C 编译器、当今最流行的 Linux 操作系统以及几乎所有的 UNIX 应用程序都是使用 C 语言编写的。

C 语言不是一门很高级的语言，并且不专门用于某一个特定的领域，但 C 语言**限制少、通用性强，不受限于任何特定的机器或系统**，使用它可以很容易地编写出不经修改就可以运行在所有支持 C 语言的机器上的程序，这使得它比一些公认为功能强大的语言使用更加方便、效率更高，**被称为“系统编程语言”**。

世界上所有重要的的系统中，都必然有 C 语言的身影，如操作系统内核、高级语言底层等。为什么 C 最适合担任系统核心？主要原因可能是 C 语言具有和汇编语言的对应性，一条 C 语言代码，对有经验的人来说，可以转换为一条或多条汇编代码，也就是说编译结果具有可预测性。C 代码不会在被编译时被加上奇奇怪怪的修饰，也不会在二进制兼容性方面带来大问题。这种稳稳当当的语言，一切都在掌握之中，**一切荣耀归属于 coder，一切错误也归罪于 coder**：

![image](http://img.cdn.firejq.com/jpg/2018/12/3/9f31e499a514e0b20d83c83ba7ec79bf.jpg)

## 2. 发展历史

- 起初，贝尔实验室的 Ken Thonpson 用汇编语言写了第一版 UNIX 操作系统。后来（1972 年），**为了移植 UNIX 操作系统**，贝尔实验室的丹尼斯·里奇 (Dennis Ritchie) 以 B 语言为基础设计开发了 C 语言，并和 Ken Thonpson 一起用 C 语言为主要编程语言编写开发了第二版 UNIX 操作系统。

- **C89**：1989 年，为了避免各开发厂商用的 C 语言语法产生差异，由美国国家标准局 (ANSI) 为 C 语言订定了一套完整的国际标准语法（编号为 ANSI X3.159-1989），称为 **ANSI C**，作为 C 语言的标准，即 C89。至今的有关的 C 程序开发工具，一般都符合 **ANSI C** 的语法。
  - 对大部分程序员来说，新标准最重要的变化是函数声明和函数定义的新语法。
  - 新标准的第二个重要贡献是为 C 语言定义了一个**标准函数库**，并确保使用这个函数库与宿主系统进行交互的程序之间具有兼容的行为。
  - ANSI 标准明确提出了可移植性问题，并预设了一个常量的集合，借以描述运行程序的机器的特性。

- **C90**：1990 年，国际标准化组织 (ISO) 成立 ISO/IEC JTC1/SC22/WG14 工作组，来规定国际标准的 C 语言，通过对 ANSI 标准的少量修改，最终制定了 ISO 9899:1990，又称为 C90。随后，ANSI 亦接受国际标准 C，并不再发展新的 C 标准。

- **C99**：1999 年，ISO 9899:1999 发表，其修正了一些 C89 标准中的细节并增加更多更广的国际字符集支持，C99 被 ANSI 于 2000 年 3 月采用。

- **C11**：2011 年，ISO 正式发布了新的 C 语言的新标准 C11，之前被称为 C1X，官方名称为 ISO/IEC 9899:2011。新的标准提高了对 C++ 的兼容性，并增加了一些新的特性（包括泛型巨集、多执行绪、带边界检查的函式、匿名结构等），但直到现在仍未有编译器完整的支持。

## 3. C 编译器

编译器能够识别代码中的词汇、句子以及各种特定的格式，并将他们转换成计算机能够识别的二进制形式，这个过程称为编译（Compile）。

C 语言的编译器有很多种，不同的平台下有不同的编译器，例如：
- Windows 下常用的是微软开发的 cl.exe，它被集成在 Visual Studio 或 Visual C++ 中，一般不单独使用。
- Linux 下常用的是 GUN 组织开发的 GCC，很多 Linux 发行版都自带 GCC。
- Mac 下常用的是 LLVM/Clang，它被集成在 Xcode 中（Xcode 以前集成的是 GCC，后来由于 GCC 的不配合才改为 LLVM/Clang，LLVM/Clang 的性能比 GCC 更加强大）。

你的代码语法正确与否，编译器说了才算，我们学习 C 语言，从某种意义上说就是学习如何使用编译器，让编译器生成可执行程序（例如 Windows 下的 .exe 程序）。

编译器可以 100% 保证你的代码从语法上讲是正确的，因为哪怕有一点小小的错误，编译也不能通过，编译器会告诉你哪里错了，便于你的更改。

## 4. C 运行库

根据 ANSI C 标准，在不同的机器平台下一般有不同的 C 运行库 (C library / libc)，且这些 C 运行库大都根据自身环境对 ANSI C 标准进行了部分扩展：

- **glibc**(GNU C Library)

  > Any Unix-like operating system needs a C library: the library which defines the ``system calls'' and other basic facilities such as open, malloc, printf, exit... The GNU C Library is used as the C library in the GNU systems and most systems with the Linux kernel.
  >
  > The GNU C Library is primarily designed to be a portable and high performance C library. It follows all relevant standards including ISO C11 and POSIX.1-2008. It is also internationalized and has one of the most complete internationalization interfaces known.
  >
  > The history of Unix and various standards determine much of the interface of the C library. In general the GNU C Library supports the ISO C and POSIX standards. We also try to support the features of popular Unix variants (including BSD and System V) when those do not conflict with the standards. Different compatibility modes (selectable when you compile an application) allow the peaceful coexistence of compatibility support for different varieties of Unix.

  glibc 是 GNU 组织对 libc 的实现，它是 UNIX/LINUX 的根基之一。glibc 是 Linux 系统中最底层的 API，几乎其它任何运行库都会依赖于 glibc，除了封装 linux 操作系统所提供的系统服务外，它本身也提供了许多其它一些必要功能服务的实现。

  glibc 提供了一组头文件和一组库文件，最基本、最常用的 C 标准库函数和系统函数在 libc.so 库文件中，几乎所有 C 程序的运行都依赖于 libc.so，有些做数学计算的 C 程序依赖于 libm.so，以后我们还会看到多线程的 C 程序依赖于 libpthread.so。

  P.S.
  - glibc 并不是 Linux 平台唯一的基础 C 函数库，也有别的 C 函数库，比如适用于嵌入式系统的 uClibc。

  - **GNU C 标准**

    GNU 项目的发起人 Richard Stallman 在编写 UNIX LIKED 系统过程中自己制作了一个标准，即 GNU C 标准。**GNU C 对标准 C (ANSI C) 进行了进一步扩展，以增强标准 C 的功能，其运行库为 glibc(GNU C Library)。所有 Linux 系统内核的代码，都是以 GNU C 标准而非 ANSI C 标准编写的**。

    在使用 GCC 编译器时：
    - 通过 `gcc a.c` 命令进行编译默认使用的是 GNU C 标准
    - 通过 `gcc -std=c99 -pedantic-errors` 命令进行编译使用的是 ANSI C 标准中的 C99 标准

- **msvcrt**

  msvcrt 是 Microsoft 对 libc 的实现。msvcrt.dll 是微软在 windows 操作系统中提供的 C 语言运行库执行文件（Microsoft Visual C Runtime Library)，其中提供了 printf,malloc,strcpy 等 C 语言库函数的具体运行实现，并且为使用 C/C++(Vc) 编译的程序提供了初始化（如获取命令行参数）以及退出等功能。

- **uClibc**(C library for embedded Linux)

  uClibc 是一个面向嵌入式 Linux 系统的小型的 C 标准库。

- **Bionic libc**

- **klibc**

- **eglibc**

## 5. 语言特点

- C 语言是一种相对低级的语言，它可以处理大部分计算机能够处理的对象，如字符、数字和地址。
- 所有高层机制需要由显式调用的函数提供，C 语言的大部分实现已合理地包含了这些函数地标准集合。
  - C 语言不提供直接处理复合对象（如字符串、集合、列表或数组等）的操作。
  - C 语言没有定义任何存储器分配工具，也不提供堆和无用内存的回收工具。
  - C 语言本身没有提供输入 / 输出功能，没有 READ 或 WRITE 语句，也没有内置的文件访问方法。
  - C 语言只提供简单的单线程控制流，不提供多道程序设计、并行操作、同步和协程。
- C 语言不是一门强类型的语言，但随着其发展，其类型检查机制已经得到了很大程度的加强。

## 6. 内存管理

C 语言的特色之一是：程序员必须亲自处理内存的分配细节。

基本上 C 程序的元素存储在内存的时候有 3 种分配策略：
- 静态分配

	如果一个变量声明为全局变量或者是函数的静态变量，这个变量的存储将使用静态分配方式。静态分配的内存一般会被编译器放在数据段或代码段来存储，具体取决于实现。这样做的前提是，在编译时就必须确定变量的大小。 以 IA32 的 x86 平台及 gcc 编译器为例，全局及静态变量放在数据段的低端；全局及静态常量放在代码段的高端。

- 自动分配

	函数的自动局部变量应该随着函数的返回会自动释放（失效），这个要求在一般的体系中都是利用栈（Stack）来满足的。相比于静态分配，这时候，就不必绝对要求这个变量在编译时就必须确定变量的大小，运行时才决定也不迟，但是 C89 仍然要求在编译时就要确定，而 C99 放松了这个限制。但无论是 C89 还是 C99，都不允许一个已经分配的自动变量运行时改变大小。

	所以说 C 函数永远不应该返回一个局部变量的地址。

	要指出的是，自动分配也属于动态分配，甚至可以用 alloca 函数来像分配堆（Heap）一样进行分配，而且释放是自动的。

- 动态分配

	还有一种更加特殊的情况，变量的大小在运行时有可能改变，或者虽然单个变量大小不变，变量的数目却有很大弹性，不能静态分配或者自动分配，这时候可以使用堆（Heap）来满足要求。ANSI C 定义的堆操作函数是 malloc、calloc、realloc 和 free。

	使用堆（Heap）内存将带来额外的开销和风险。

## 7. Refer Links

[如何学习 C 语言？](https://www.zhihu.com/question/19668080)

[What is the difference between C, C99, ANSI C and GNU C?](https://stackoverflow.com/questions/17206568/what-is-the-difference-between-c-c99-ansi-c-and-gnu-c)

[GNU C 、ANSI C、标准 C、标准 c++ 区别和联系](https://www.cnblogs.com/balaamwe/archive/2012/01/07/2316076.html)

[在哪里可以找到 C 语言标准库的实现源代码？](https://www.zhihu.com/question/20956554)

[c/c++ 程序里面用了很多标准库和 api，假设这些函数和 api 多年以后被废除了，或者不支持了怎么办？](https://www.zhihu.com/question/265613872)

[C 语言编译器，神奇的魔法师](http://c.biancheng.net/cpp/html/3440.html)

[GCC 编译器简明教程（Linux 下 C 语言开发环境的搭建）](http://c.biancheng.net/cpp/html/3418.html)
