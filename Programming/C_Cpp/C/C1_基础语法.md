- [C 基础语法](#c-基础语法)
  - [1. 标识符](#1-标识符)
  - [2. 注释](#2-注释)
  - [3. 数据类型](#3-数据类型)
    - [3.1. 基本概念](#31-基本概念)
    - [3.2. 整型类型](#32-整型类型)
    - [3.3. 浮点类型](#33-浮点类型)
    - [3.4. void 类型](#34-void-类型)
    - [3.5. 类型转换](#35-类型转换)
      - [3.5.1. 自动类型转换](#351-自动类型转换)
      - [3.5.2. 强制类型转换](#352-强制类型转换)
  - [4. 常量](#4-常量)
    - [4.1. 整型常量](#41-整型常量)
    - [4.2. 字符常量](#42-字符常量)
    - [4.3. 浮点常量](#43-浮点常量)
    - [4.4. 字符串字面量](#44-字符串字面量)
    - [4.5. 枚举常量](#45-枚举常量)
  - [5. 变量](#5-变量)
    - [5.1. 变量定义](#51-变量定义)
    - [5.2. 变量声明](#52-变量声明)
    - [5.3. 存储类](#53-存储类)
    - [5.4. 内存结构](#54-内存结构)
      - [5.4.1. 局部变量](#541-局部变量)
      - [5.4.2. 全局变量](#542-全局变量)
  - [6. 运算符](#6-运算符)
    - [6.1. 赋值运算符](#61-赋值运算符)
    - [6.2. 算术运算符](#62-算术运算符)
    - [6.3. 关系运算符](#63-关系运算符)
    - [6.4. 逻辑运算符](#64-逻辑运算符)
    - [6.5. 位运算符](#65-位运算符)
    - [6.6. 其它运算符](#66-其它运算符)
    - [6.7. sizeof 运算符](#67-sizeof-运算符)
      - [6.7.1. 指针类型](#671-指针类型)
      - [6.7.2. 结构类型](#672-结构类型)
    - [6.8. delete 操作符](#68-delete-操作符)
  - [7. 控制流](#7-控制流)
    - [7.1. 条件控制](#71-条件控制)
      - [7.1.1. if else](#711-if-else)
      - [7.1.2. switch](#712-switch)
    - [7.2. 循环控制](#72-循环控制)
      - [7.2.1. for](#721-for)
      - [7.2.2. while](#722-while)
      - [7.2.3. break / continue / goto](#723-break--continue--goto)
  - [8. 函数](#8-函数)
    - [8.1. 变长参数表](#81-变长参数表)
    - [8.2. 命令行参数](#82-命令行参数)
    - [8.3. 函数调用原理](#83-函数调用原理)
      - [8.3.1. 普通函数调用](#831-普通函数调用)
      - [8.3.2. 递归函数调用](#832-递归函数调用)
  - [9. 数组](#9-数组)
    - [9.1. 声明](#91-声明)
    - [9.2. 初始化](#92-初始化)
    - [9.3. 元素访问](#93-元素访问)
    - [9.4. 多维数组](#94-多维数组)
    - [9.5. 内存结构](#95-内存结构)
  - [10. 枚举](#10-枚举)
  - [11. 类型定义](#11-类型定义)
  - [12. Refer Links](#12-refer-links)

# C 基础语法

## 1. 标识符

- 标识符是由字母和数字构成的序列，且第一个字符必须是字母或下划线 `_`。
- 大小写敏感。
- 标识符可以为任意长度。
  - 对于内部标识符（包括预处理器的宏名和其它所有没有外部连接的命名），至少钱 31 个字母是有效的，在某些实现中可能更多。
  - 对于外部连接的标识符，限制比较严格，有些实现只认为前 6 个字符是有效的。
- 标识符不能与关键字冲突。

i.e.
```
mohd       zara    abc   move_name  a_123
myname50   _temp   j     a23b9      retVal
```

## 2. 注释

C 语言有两种注释方式：
- 以 `//` 开始的单行注释，这种注释可以单独占一行
- `/* */` 这种格式的注释可以单行或多行

## 3. 数据类型

TODO: [浅析为什么 char 类型的范围是 —128~+127](https://blog.csdn.net/daiyutage/article/details/8575248)

### 3.1. 基本概念

我们知道，诸如数字、文字、符号、图形、音频、视频等数据都是以二进制形式存储在内存中的，它们并没有本质上的区别，那么，00010000 该理解为数字 16 呢，还是图像中某个像素的颜色呢，还是要发出某个声音呢？如果没有特别指明，我们并不知道。

**也就是说，内存中的数据有多种解释方式，因此使用之前必须要确定其数据类型。数据类型用来说明数据的类型，确定了数据的解释方式，让计算机和程序员不会产生歧义**。数据类型只在定义变量时指明，而且必须指明；使用变量时无需再指明，因为此时的数据类型已经确定了。

- 基本数据类型

  C 语言只提供了以下 4 种基本数据类型：
  - char: 字符型，占用 1 字节，可存放本地字符集中的一个字符
  - int: 整型，通常反映了本地机器整数的最自然长度
  - float: 单精度浮点型
  - double: 双精度浮点型

  在不同编译环境下，基本数据类型会占用不同大小的空间：

  ![image](http://img.cdn.firejq.com/jpg/2018/8/8/3f940c68f3b0ab91173e18626d0bb2f5.jpg)

  为了得到某个类型或某个变量在特定平台上的准确大小，可以使用 `sizeof` 运算符得到对象或类型的实际存储字节大小。

- 限定符

  可以在基本数据类型的前边加上一些限定符，从而形成复合数据类型。限定符有以下几种：
  - short / long: 用于限定整型和双精度浮点型，限定 int 时关键字 int 可省略。该限定符为我们提供满足实际需要的不同长度的整型数。
    - `short int`: 至少为 16 位
    - `long int`: 至少位 32 位
    - `long double`: 表示高精度浮点数，长度由具体实现决定

    i.e.
    ```c
    short int a;
    long int b;
    short c;
    long d;
    ```

  - signed / unsigned: 用于限定 char 类型或任何整型。unsigned 类型的数总是正值或 0，并遵守模 2^n 定律，其中 n 是该类型占用的位数；signed char 类型变量的取值范围为 -128~127. **不带限定符的 char 类型对象是否带符号取决于具体的机器实现**。

### 3.2. 整型类型

| 类型           | 存储大小    | 值范围                                               |
| -------------- | ----------- | ---------------------------------------------------- |
| char           | 1 字节      | -128 到 127 或 0 到 255                              |
| unsigned char  | 1 字节      | 0 到 255                                             |
| signed char    | 1 字节      | -128 到 127                                          |
| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节      | -32,768 到 32,767                                    |
| unsigned short | 2 字节      | 0 到 65,535                                          |
| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4 字节      | 0 到 4,294,967,295                                   |

NOTE: 各种类型的存储大小与系统位数有关。

### 3.3. 浮点类型

| 类型        | 存储大小 | 值范围                 | 精度      |
| ----------- | -------- | ---------------------- | --------- |
| float       | 4 字节   | 1.2E-38 到 3.4E+38     | 6 位小数  |
| double      | 8 字节   | 2.3E-308 到 1.7E+308   | 15 位小数 |
| long double | 16 字节  | 3.4E-4932 到 1.1E+4932 | 19 位小数 |

头文件 `<float.h>` 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。

### 3.4. void 类型

void 类型指定没有可用的值。它通常用于以下三种情况下：
- 函数返回为空：C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 `void exit (int status);`.
- 函数参数为空：C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 `int rand(void);`。
- 指针指向 void：类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 `void *malloc( size_t size );` 返回指向 void 的指针，可以转换为任何数据类型。

### 3.5. 类型转换

NOTE: 无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，**转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值**。

#### 3.5.1. 自动类型转换

自动类型转换就是编译器默默地、隐式地、偷偷地进行的数据类型转换，这种转换不需要程序员干预，会自动发生。

一般来说，**自动转换是把“比较窄的”操作数转换为“比较宽的”操作数，并且不丢失信息的转换**：

- 如果赋值运算符的两个操作数具有不同的类型，那么**赋值运算符右边的值需要转换为左边变量的类型，并且赋值表达式结果的类型为左边变量的类型**。

  i.e.
  ```c
  float f = 100; // 100 是 int 类型的数据，需要先转换为 float 类型才能赋值给变量 f
  int n = f; // f 是 float 类型的数据，需要先转换为 int 类型才能赋值给变量 n
  ```

  发生自动类型转换时，可能会导致数据失真，或者精度降低，因此并不一定是安全的。对于不安全的类型转换，编译器一般会给出警告。

- 如果二元运算符的两个操作数具有不同的类型，那么**在进行运算之前要先把“较低”的类型提升了“较高”的类型，并且运算结果为“较高”的类型**。具体转换的规则如下：
  - **转换按数据长度增加的方向进行**，以保证数值不失真，或者精度不降低。例如，int 和 long 参与运算时，先把 int 类型的数据转成 long 类型后再进行运算。
  - **所有的浮点运算都是以双精度进行的**，即使运算中只有 float 类型，也要先转换为 double 类型，才能进行运算。
  - **char 和 short 参与运算时，必须先转换成 int 类型**。
  - **当表达式中包含 unsigned 类型的操作数时，转换规则要取决于机器中不同整数类型的大小**。例如，假定 int 占 16 位，long 占 32 位，那么 `-1L < 1U`，因为 unsigned int 类型的 `1U` 将被提升为 `signed long` 类型；但 `-1L > 1UL`，因为 `-1L` 将被提升为 `unsigned long` 类型，因而成为一个比较大的正数。

  ![image](http://img.cdn.firejq.com/jpg/2018/12/7/61361b4043659f4b093350cae0d0549e.jpg)

  i.e.
  ```c
  #include <stdio.h>
  int main() {
      float PI = 3.14159;
      int s1, r = 5;
      double s2;
      s1 = r * r * PI;
      s2 = r * r * PI;
      printf("s1=%d, s2=%f\n", s1, s2);
      return 0;
  }
  ```
  输出
  ```
  s1=78, s2=78.539749
  ```
  在计算表达式 `r*r*PI` 时，r 和 PI 都被转换成 double 类型，表达式的结果也是 double 类型。但由于 s1 为整型，所以赋值运算的结果仍为整型，舍去了小数部分，导致数据失真。

#### 3.5.2. 强制类型转换

自动类型转换是编译器根据代码的上下文环境自行判断的结果，有时候并不是那么“智能”，不能满足所有的需求。因此，C 语言也支持程序员自己在代码中明确地提出要进行类型转换，即强制类型转换。

强制类型转换格式：
```
(type_name) expression
```
其中，type_name 为新类型名称，expression 为表达式。

通常情况下，参数是通过函数原型声明的，这样当函数被调用时，声明将对参数进行自动强制转换。

## 4. 常量

常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。

常量表达式是仅仅包含常量的表达式，这种表达式在编译时求值，而不在运行时求值。

### 4.1. 整型常量

整型常量的前缀指定表示的数制基数：`0x` 或 `0X` 表示十六进制，`0` 表示八进制，不带前缀则默认表示十进制。

整型常量的后缀可以是 U 和 L 的组合：`U` 表示无符号整数（unsigned），`L` 表示长整数（long）。后缀可以是大写，也可以是小写，`U` 和 `L` 的顺序任意。

整型常量的数据类型由它的形式、值和后缀决定。

i.e.
```
85         /* 十进制 */
0213       /* 八进制 */
0xFeeL     /* 十六进制 */
30         /* 整数 */
30u        /* 无符号整数 */
30l        /* 长整数 */
30ul       /* 无符号长整数 */
078        /* 非法的：8 不是八进制的数字 */
032UU      /* 非法的：不能重复后缀 */
```

### 4.2. 字符常量

字符常量是用单引号括起来的一个或多个字符构成的序列，如 `'x'`。单字符常量的值是执行时机器字符集中此字符对应的数值，多字符常量的值由具体的实现定义。

字符常量可以是一个普通的字符（例如 `'x'`）、一个转义序列（例如 `'\t'`）、一个通用的字符（例如 `'\u02C0'`）。

常见转义字符序列：
```
\\	\ 字符
\'	' 字符
\"	" 字符
\?	? 字符
\a	警报铃声
\b	退格键
\f	换页符
\n	换行符
\r	回车
\t	水平制表符
\v	垂直制表符
\ooo	一到三位的八进制数
\xhh  一个或多个数字的十六进制数
```

### 4.3. 浮点常量

浮点常量由整数部分、小数点、小数部分、指数部分（一个 e 或 E 和一个可选的带符号整型类型的指数）和一个可选的表示类型的后缀（即 f、F、l 或 L 之一）组成。

浮点常量可以使用小数形式或者指数形式来表示浮点常量：
- 当使用小数形式表示时，必须至少包含整数部分或小数部分两者之一，也可以同时包含两者。
- 当使用指数形式表示时，必须至少包含小数点或指数部分两者之一，也可以同时包含两者。

浮点常量的类型由后缀确定：
- 没有后缀：double 类型
- f 或 F: float 类型
- l 或 L: long double 类型

i.e.
```
3.14159       /* 合法的 */
314159E-5L    /* 合法的 */
510E          /* 非法的：不完整的指数 */
210f          /* 非法的：没有小数或指数 */
.e55          /* 非法的：缺少整数或分数 */
```

### 4.4. 字符串字面量

字符串字面值也称为字符串常量，是括在双引号 `""` 中的一个字符序列。

字符串的类型为**字符数组**，存储类为 static，它使用给定的字符进行初始化，对相同的字符串字面值是否进行区分取决于具体的实现。如果程序试图修改字符串字面量，该行为是未定义的。

与字符常量一样，扩展字符集中的字符串字面量也以前导符 L 表示，如 `L"..."`。宽字符字符串字面值的类型为 `wchar_t` 类型的数组，将普通字符串字面值和宽字符字符串字面值进行连接的行为是未定义的。

**从技术角度看，字符串常量就是字符串数组**。字符串的内部表示使用一个空字符 `'\0'` 作为串的结尾，因此，存储字符串的物理存储单元数比括在双引号种的字符数多一个。这种表示方法也说明，C 语言对字符串的长度没有限制，但程序必须扫描完整个字符串后才能确定字符串的长度。标准库中的 `strlen(s)` 可返回字符串参数 s 的长度，但该长度不包括末尾的 `'\0'`。

**需要注意，`'x'` 和 `"x"` 是不同的：前者是一个整数，其值是字母 x 在机器字符集中的对应的数值（内部表示值）；后者是一个包含一个字符以及一个结束符 `'\0'` 的字符数组**。

### 4.5. 枚举常量

枚举常量是一个整型常量值的列表。

在没有显式说明的情况下，enum 中第一个枚举名的值为 0，第二个为 1，以此类推。如果只指定了部分枚举名的值，那么未指定的枚举名的值将依着最后一个指定值向后递增。

不同枚举中的名字必须互不相同，同一枚举中不同的名字可以具有相同的值。

相对于 `#define` 语句来说，枚举的优势在于常量值可以自动生成，而且枚举变量提供对有效值的检查。

## 5. 变量

### 5.1. 变量定义

变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表。

i.e.
```c
int    i, j, k;
char   c, ch;
float  f, salary;
double d;
```

变量可以在声明的时候被初始化（指定一个初始值），**外部变量或静态变量会被隐式初始化为 0（所有字节的值都是 0），而自动变量和寄存器变量的初始值是未定义的**。

i.e.
```c
extern int d = 3, f = 5;    // d 和 f 的声明与初始化
int d = 3, f = 5;           // 定义并初始化 d 和 f
byte z = 22;                // 定义并初始化 z
char x = 'x';               // 变量 x 的值为 'x'
```

任何变量的定义都可以使用 const 关键字限定，该关键字指定变量的值不能被修改，对数组而言，const 关键字限定数组所有元素的值都不能被修改。

### 5.2. 变量声明

变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。

变量的声明有两种情况：
- **一种是需要建立存储空间的，此时变量的声明就相当于变量的定义**。例如：`int a` 在声明的时候就已经建立了存储空间。
- **另一种是不需要建立存储空间的，通过使用 `extern` 关键字声明变量名而不定义它**。例如：`extern int a` 其中变量 a 可以在别的文件中定义。

因此，除非有 `extern` 关键字，否则都是变量的定义。也可以说，**变量的定义一定会引起内存分配，但变量的声明不一定会引起内存分配**。

### 5.3. 存储类

**存储类定义了 C 语言程序中变量 / 函数的范围（作用域）和生命周期**，这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：
- auto
- register
- static
- extern

- auto 存储类

  auto 存储类是所有局部变量默认的存储类。auto 只能用在函数内，即 **auto 只能修饰局部变量**。

- register 存储类

  register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且**不能对它应用一元的 '&' 运算符（因为它没有内存位置）**。

  寄存器只用于需要快速访问的变量，比如计数器。

  需要注意的是，**定义 `register` 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制**。

- static 存储类

  - static 修饰符**可以用于局部变量，指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁**。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

  - static 修饰符也**可以应用于全局变量或函数，使变量或函数的作用域限制在声明它的文件内，从而达到隐藏外部文件的目的**。全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。

- extern 存储类

  extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

  当项目中有多个文件且在某个文件中定义了一个需要在其他文件使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。

  在一个程序的所有源文件中，一个外部变量只能在某个文件中被定义一次，而其它文件可以通过 extern 声明来访问它。**外部变量的定义中必须指定数组的长度，但 extern 声明则不一定要指定数组的长度**。

### 5.4. 内存结构

#### 5.4.1. 局部变量

i.e.
```cpp
int main(int argc, const char * argv[]) {
    int a = 1;
    int b = 2;
    printf("%p\n",&a);  //0x7fff5fbff79b
    printf("%p\n",&b);  //0x7fff5fbff797
    return 0;
}
```

![image](http://img.cdn.firejq.com/jpg/2018/8/8/d2c8cbbde8b3ee30984395125f883c13.jpg)

由于是 a、b 是临时变量，因此他们的内存空间分配在栈上，栈中内存寻址由高到低，所以 a 变量的地址比 b 变量的地址要大，其次由于是在 64 位编译环境中，int 型变量占据 4 个字节的空间，每一个字节由低到高依次对应着 8 位二进制数，四个 8 位二进制数就是十进制中的 1 或 2，而变量 a、b 的地址就是四个字节中最小值的内存地址。

#### 5.4.2. 全局变量

TODO:

## 6. 运算符

### 6.1. 赋值运算符

- `=`: 简单的赋值运算符，把右边操作数的值赋给左边操作数	C = A + B 将把 A + B 的值赋给 C。
- `+=`: 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数	C += A 相当于 C = C + A。
- `-=`: 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数	C -= A 相当于 C = C - A。
- `*=`: 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数	C *= A 相当于 C = C * A。
- `/=`: 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数	C /= A 相当于 C = C / A。
- `%=`: 求模且赋值运算符，求两个操作数的模赋值给左边操作数	C %= A 相当于 C = C % A。
- `<<=`: 左移且赋值运算符	C <<= 2 等同于 C = C << 2。
- `>>=`: 右移且赋值运算符	C >>= 2 等同于 C = C >> 2。
- `&=`: 按位与且赋值运算符	C &= 2 等同于 C = C & 2。
- `^=`: 按位异或且赋值运算符	C ^= 2 等同于 C = C ^ 2。
- `|=`: 按位或且赋值运算符	C |= 2 等同于 C = C | 2。

### 6.2. 算术运算符

- `+`: 把两个操作数相加	A + B 将得到 30。
- `-`: 从第一个操作数中减去第二个操作数	A - B 将得到 -10。
- `*`: 把两个操作数相乘	A * B 将得到 200。
- `/`: 分子除以分母	B / A 将得到 2。
- `%`: 取模运算符，整除后的余数	B % A 将得到 0。**`%` 不能用于 float 或 double 类型，在有负操作数的情况下，整数除法截取的方向以及取模运算结果的符号取决于具体机器的实现**。
- `++`: 自增运算符，整数值增加 1	A++ 将得到 11。
- `--`: 自减运算符，整数值减少 1。

### 6.3. 关系运算符

- `==`: 检查两个操作数的值是否相等，如果相等则条件为真。	(A == B) 不为真。
- `!=`: 检查两个操作数的值是否相等，如果不相等则条件为真。	(A != B) 为真。
- `>`: 检查左操作数的值是否大于右操作数的值，如果是则条件为真。	(A > B) 不为真。
- `<`: 检查左操作数的值是否小于右操作数的值，如果是则条件为真。	(A < B) 为真。
- `>=`: 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。	(A >= B) 不为真。
- `<=`: 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。	(A <= B) 为真。

### 6.4. 逻辑运算符

- `&&`: 称为逻辑与运算符。如果两个操作数都非零，则条件为真。	(A && B) 为假。
- `||`: 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。	(A || B) 为真。
- `!`: 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。	!(A && B) 为真。

### 6.5. 位运算符

C 语言提供了 6 个位运算符，这些运算符只能用于整型操作数，即**只能作用于带符号或无符号的 char、short、int 与 long 类型**：

- `&`: 按位与操作，按二进制位进行"与"运算。
- `|`: 按位或运算符，按二进制位进行"或"运算。
- `^`: 异或运算符，按二进制位进行"异或"运算。
- `~`: 取反运算符，按二进制位进行"取反"运算。
- `<<`: 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补 0）。
- `>>`: 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。

### 6.6. 其它运算符

以下列出了 C 语言支持的其他一些重要的运算符：
- `&`: 返回变量的地址。`&a;` 将给出变量的实际地址。
- `*`: 指向一个变量。`*a;` 将指向一个变量。
- `?`: 条件表达式	如果条件为真 ? 则值为 X : 否则值为 Y。

### 6.7. sizeof 运算符

https://zh.cppreference.com/w/cpp/language/sizeof

http://blog.51cto.com/lemonmilk/107155

http://www.cppblog.com/w57w57w57/archive/2011/08/09/152845.html

sizeof 一般形式为：sizeof（object），也可以 sizeof var_char，通常习惯用 sizeof()。

sizeof 是单目运算符，其运算符的含义是：求出对象在计算机内存中所占用的字节数。对象可以是表达式或者数据类型名，当对象是表达式时，括号可省略。

#### 6.7.1. 指针类型

对于指针，要特别区分，指针指向什么数据，它在内存占的字节数才是它的结果。如：指针指向一个字符串，就是字符串的长度，因为一个字符在内存中占一个字节。若指针指向一个数据结构，则结果应该是结构型数据的内存字节数。

#### 6.7.2. 结构类型

```c
struct str{
    double d;
    char ch;
    int data;
}str_wu;
struct str1{
    char ch;
    double d;
    int data;
}str_wu1;
```

两个不同的结构，但是内部的元素是相同的，都是 double，int，char，只是顺序不一样，就结果不一样。why？

这时因为 VC 存储数据的时候要对其，具体的情况如下：

类型：对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量）
- Char: 偏移量必须为 sizeof(char) 即 1 的倍数
- int: 偏移量必须为 sizeof(int) 即 4 的倍数
- float: 偏移量必须为 sizeof(float) 即 4 的倍数
- double: 偏移量必须为 sizeof(double) 即 8 的倍数
- Short: 偏移量必须为 sizeof(short) 即 2 的倍数

比如：str_wu，为上面的结构分配空间的时候，VC 根据成员变量出现的顺序和对齐方式，先为第一个成员 dda1 分配空间，其起始地址跟结构的起始地址相同（刚好偏移量 0 刚好为 sizeof(double) 的倍数），该成员变量占用 sizeof(double)=8 个字节；接下来为第二个成员 dda 分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为 8，是 sizeof(char) 的倍数，所以把 dda 存放在偏移量为 8 的地方满足对齐方式，该成员变量占用 sizeof(char)=1 个字节；接下来为第三个成员 type 分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为 9，不是 sizeof(int)=4 的倍数，为了满足对齐方式对偏移量的约束问题，VC 自动填充 3 个字节（这三个字节没有放什么东西），这时下一个可以分配的地址对于结构的起始地址的偏移量为 12，刚好是 sizeof(int)=4 的倍数，所以把 type 存放在偏移量为 12 的地方，该成员变量占用 sizeof(int)=4 个字节；这时整个结构的成员变量已经都分配了空间，总的占用的空间大小为：8+1+3+4=16，刚好为结构的字节边界数（即结构中占用最大空间的类型所占用的字节数 sizeof(double)=8）的倍数，所以没有空缺的字节需要填充。所以整个结构的大小为：sizeof(str_wu) = 8 + 1 + 3 + 4 = 16，其中有 3 个字节是 VC 自动填充的，没有放任何有意义的东西。

而 str_wu1，同样的道理：如下：sizeof(char)=1, 而 1 不是 8 的倍数，因而增加到 8，sizeof（double）＝8，现在开始地址是 16，16 是 sizeof（int) 的倍数，可以存入。因而总的地址数：sizeof（char）＋7＋sizeof（double）＋sizeof（int）＝20，而 20 不是 8 的倍数（sizeof(double)=8), 所以需要在增加 4 个地址，即总共 24。

### 6.8. delete 操作符

https://www.nowcoder.com/questionTerminal/9fb652d48bee45bcb47771b2e3c6f690

## 7. 控制流

### 7.1. 条件控制

#### 7.1.1. if else

```c
if (boolean_expression)
{
   /* 如果布尔表达式为真将执行的语句 */
}
else
{
   /* 如果布尔表达式为假将执行的语句 */
}
```

#### 7.1.2. switch

```c
switch(expression) {
    case constant-expression:
       statement(s);
       break; /* 可选的 */
    case constant-expression:
       statement(s);
       break; /* 可选的 */

    /* 您可以有任意数量的 case 语句 */
    default: /* 可选的 */
       statement(s);
}
```

NOTE
- switch 语句中的 expression 是一个常量表达式，必须是一个整型或枚举类型。
- 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。
- case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。
- 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。
- 一个 switch 语句可以有一个可选的 default case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 break 语句不是必需的。

### 7.2. 循环控制

#### 7.2.1. for

```c
for ( init; condition; increment )
{
   statement(s);
}
```

#### 7.2.2. while

```c
while(condition)
{
   statement(s);
}
```

#### 7.2.3. break / continue / goto

- `break`: 终止**当前一层循环**或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。
- `continue`: 告诉**当前一层循环体**立刻停止本次循环迭代，重新开始下次循环迭代。
- `goto`: 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。

## 8. 函数

函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。

ANSI 标准对 C 语言所做的最明显的修改就是函数声明与函数定义这 2 个方面：
- 函数声明告诉编译器函数的名称、返回类型和参数。如果函数声明中省略了返回值类型，则默认为 int 类型。
- 函数定义提供了函数的实际主体。

C 标准库提供了大量的程序可以调用的内置函数。例如，函数 `strcat()` 用来连接两个字符串，函数 `memcpy()` 用来复制内存到另一个位置。

### 8.1. 变长参数表

在函数参数声明中，支持使用省略号表示参数表中参数的数量和类型是可变的。省略号只能出现在参数表的尾部。

i.e.
- `int printf(const char *format, ...)`
- `int scanf(const char *format, ...)`

在 `<stdarg.h>` 中包含了一组宏定义，它们对如何遍历变长参数表进行了定义。虽然该头文件的实现因不同的机器而不同，但提供的接口是一致的。具体步骤如下：
1. 定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。
1. 在函数定义中创建一个 `va_list` 类型变量，该类型是在 `<stdarg.h>` 头文件中定义的。
1. 使用 int 参数和 `va_start` 宏来初始化 `va_list` 变量为一个参数列表。宏 `va_start` 是在 `<stdarg.h>` 头文件中定义的。
1. 使用 `va_arg` 宏和 `va_list` 变量来访问参数列表中的每个项。
1. 使用宏 `va_end` 来清理赋予 `va_list` 变量的内存。

i.e.
```c
#include <stdio.h>
#include <stdarg.h>

double average(int num,...)
{

    va_list valist;
    double sum = 0.0;
    int i;

    /* 为 num 个参数初始化 valist */
    va_start(valist, num);

    /* 访问所有赋给 valist 的参数 */
    for (i = 0; i < num; i++)
    {
       sum += va_arg(valist, int);
    }
    /* 清理为 valist 保留的内存 */
    va_end(valist);

    return sum/num;
}

int main()
{
   printf("Average of 2, 3, 4, 5 = %f\n", average(4, 2,3,4,5));
   printf("Average of 5, 10, 15 = %f\n", average(3, 5,10,15));
}
```

### 8.2. 命令行参数

在支持 C 语言的环境中，可以在程序开始执行时将命令行参数传递给程序，调用主函数 main 时，可带有 2 个参数：
- `int argc`: 表示运行程序时命令行中参数的数量。
- `cahr *argv[]`: 表示一个指向参数字符串数组的指针数组，通常用多级指针处理这些字符串。按照约定，`argv[0]` 表示启动该程序的程序名，因此 argc 的值至少为 1。另外，ANSI C 要求 `argv[argc]` 的值必须为一个空指针。

i.e.
```c
int main(int argc, char *argv[]) {
  for (int i = 0; i < argc; i++) {
    printf("%s%s", argv[i], (i < argc - 1) ? " " : "");
  }
  printf("\n");
  return 0;
}
```

### 8.3. 函数调用原理

函数作为编程中实现功能的重要手段，深入理解函数的调用过程对提升开发能力有很大的帮助。

#### 8.3.1. 普通函数调用

与汇编程序设计中主程序和子程序之间的链接及信息交换类似，在高级语言编写的程序中（比如 C 语言），调用函数与被调用函数之间的链接及信息交换需要通过栈来进行，即系统将整个程序运行所需的数据空间安排在一个栈中，每当调用一个函数就为它在栈顶分配一个存储区，每当从一个函数退出时，就释放它的存储区，当前正在运行的函数存储区必在栈顶。

函数运行期间调用另外一个函数，在运行被调用函数之前，系统需要先完成 3 件事情：
1. 将所有的实参、返回地址等信息传递给被调用函数保存
1. 为被调用函数局部变量在栈上分配内存
1. 将控制转移到被调用函数入口

被调用函数返回调用函数之前，系统也需要相应的完成 3 件事情：
1. 在栈中保存被调用函数的计算结果（返回值）
1. 释放在栈中为被调用函数分配的数据区
1. 依照被调用函数保存的返回地址将控制转移到调用函数

栈帧也称为过程活动记录，是编译器用来实现过程 / 函数调用的一种数据结构。**每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数形参、返回地址、局部变量等信息，简而言之栈帧就是一个函数执行的环境**。有时候函数嵌套调用，栈中会有多个函数的信息，每个函数占用一个连续的区域。

被调用函数的形参，在未出现函数调用时不占用内存空间，发生函数调用时，形参按照确定的类型在该函数帧中被分配指定大小的空间。并且由调用函数的实参传递给被调用函数的形参保存。

函数具体调用过程：
1. 为被调用函数在栈顶分配空间，为被调用函数的形参分配空间
1. 将实参的值传递给形参
1. 被调用函数利用形参（如果存在）进行运算
1. 通过 return 语句将返回值带回调用函数
1. 调用结束，释放被调用函数空间，释放其形参分配空间

i.e.
```c
int add(int num1, int num2) {
		int tempSum = num1 + num2;
		return tempSum;
}
int main(int argc, const char * argv[]) {
		int a = 10;
		int b = 20;
		int sum = add(a, b);
		printf("%i\n",sum); //   sum = 30
		return 0;
}
```
上面的 `main()`、`add()` 函数之间调用的过程及参数传递在内存的示意图如下：

![image](http://img.cdn.firejq.com/jpg/2018/8/8/ee22807cc1f012cd0a236aa30e178918.jpg)

1. 首先执行 main() 函数，系统为 main() 函数在栈顶分配一定大小的空间，其次为 a、b 局部变量分配空间；
1. 调用 add() 函数，main() 函数压入栈底，栈顶指针上移，系统为 add() 函数在栈顶分配一定大小的空间，其次为 num1、num2 局部变量分配空间；
1. 执行两个整数的加法运算，在 add() 函数帧中新开辟一块空间存放计算后的结果 tempSum；
1. 最后 add() 函数返回，在 main() 函数帧中开辟一块新的空间存放 add() 函数的返回值 sum，
1. add() 函数帧调用结束出栈，系统释放其空间并且栈顶指针下移，main() 函数重新回到栈顶。

注意：当前正在运行的函数存储区必在栈顶。

#### 8.3.2. 递归函数调用

一个递归函数的运行过程类似于多个函数之间的嵌套调用，只是调用函数和被调用函数是同一个函数，因此，和每次调用相关的一个重要概念是递归函数运行的“层数”。

为了保证递归函数正确执行，系统建立一个“递归工作栈”作为整个递归函数运行期间使用的数据存储区，每一层递归所需信息构成一个“工作记录”，其中包括所有的实参、局部变量以及上一层的返回地址。每进入一层递归，就产生一个新的工作记录压入栈顶。每退出一层递归，就从栈顶弹出一个工作记录。当前活动的工作记录成为“活动记录”，并称活动记录的栈顶指针为“当前环境指针”。

假设调用该递归函数的主函数为第 0 层，主函数调用递归函数进入第一层；从第 i 层调用本函数为进入第 i+1 层，反之，退出第 i 层递归则应返回至第 i - 1 层。

i.e.
```c
int getAge(int n) {
		if (n == 1) {
				return 10;
		} else {
				return getAge(n-1) + 2;
		}
}
int main(int argc, const char * argv[]) {
		printf("NO.5.age: %d\n",getAge(5));
		return 0;
}
```

![image](http://img.cdn.firejq.com/jpg/2018/8/8/eb24c7028dbf2ae50cdfe62f1dab9361.jpg)

一个递归问题可以分为“递推”和“回溯”两个阶段，要经历若干步才能求出最后的结果。但是其原理和一般函数的调用没有本质区别。递归函数调用次数越多，在栈上为其分配的空间就越大，所以我们应该避免调用次数过多的递归函数，因为该操作很可能会使栈的容量“溢出”。

## 9. 数组

C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。

所有的数组都是由连续的内存位置组成，最低的地址对应第一个元素，最高的地址对应最后一个元素：

![image](http://img.cdn.firejq.com/jpg/2018/12/8/4015e311ab23099ef5200e89b125be67.jpg)

### 9.1. 声明

在 C 中要声明一个数组，需要指定元素的类型和元素的数量。

例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明如下：`double balance[10];`。

### 9.2. 初始化

数组的初始化可以对数组元素逐个进行初始化，也可以在声明的后面紧跟一个初始化表达式列表，初始化表达式列表用花括号 `{}` 括起来，各初始化表达式之间通过逗号分隔。当省略数组长度时，编译器将把花括号中初始化表达式的个数作为数组的长度。

- 如果初始化表达式的个数比数组声明中的元素数少，那么没有初始化的表达式将被初始化为 0。

- 如果初始化表达式的个数比数组声明中的元素数多，那么将会出现编译错误。

- **字符数组的初始化比较特殊，可以通过一个字符串来代替使用花括号括起来并用逗号分隔的初始化表达式序列**。

### 9.3. 元素访问

数组元素可以通过数组名称加索引进行访问，元素的索引是放在方括号内，跟在数组名称的后边。

i.e.
```c
#include <stdio.h>

int main ()
{
   int n[ 10 ]; /* n 是一个包含 10 个整数的数组 */
   int i,j;

   /* 初始化数组元素 */
   for ( i = 0; i < 10; i++ )
   {
      n[ i ] = i + 100; /* 设置元素 i 为 i + 100 */
   }

   /* 输出数组中每个元素的值 */
   for (j = 0; j < 10; j++ )
   {
      printf("Element[%d] = %d\n", j, n[j] );
   }

   return 0;
}
```

### 9.4. 多维数组

在 C 语言中，二维数组实际上是一种特殊的一维数组，它的每个元素也是一个一维数组。

一般来说，**除了数组的第一维可以不指定大小外，其余各维都必须明确指定大小**。

### 9.5. 内存结构

C 语言中数组的存储和普通的变量不太一样，**数值中存储的元素，是从所占用的低地址开始存储的**。

i.e.
```cpp
int main(int argc, const char * argv[]) {
    char chars[4] = {'l','o','v','e'};
    printf("chars[0] = %p\n",&chars[0]); //0x7fff5fbff79b
    printf("chars[1] = %p\n",&chars[1]); //0x7fff5fbff79c
    printf("chars[2] = %p\n",&chars[2]); //0x7fff5fbff79d
    printf("chars[3] = %p\n",&chars[3]); //0x7fff5fbff79e
    return 0;
}
```

![image](http://img.cdn.firejq.com/jpg/2018/8/8/9e1074382e6dbb6b24ab9925e7dca0da.jpg)

i.e.
```cpp
int main(int argc, const char * argv[]) {
    int nums[2] = {5, 6};
    printf("nums[0] = %p\n",&nums[0]); // 0x7fff5fbff7a0
    printf("nums[1] = %p\n",&nums[1]); // 0x7fff5fbff7a4
    return 0;
}
```

![image](http://img.cdn.firejq.com/jpg/2018/12/14/66c80fcdc5966bbb5e24bb2e6f983dd4.jpg)

**数组中的元素按照存放顺序依次从低地址到高地址存放，但是每个元素中的内容又是按高地址向低地址方向存储**。

## 10. 枚举

枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。枚举语法定义格式为：
```
enum　枚举名　{枚举元素 1, 枚举元素 2,……};
```
第一个枚举成员的默认值为整型的 0，**后续枚举成员的值在前一个成员上加 1**。

i.e.
```c
#define MON  1
#define TUE  2
#define WED  3
#define THU  4
#define FRI  5
#define SAT  6
#define SUN  7
```
这个看起来代码量就比较多，如果使用枚举的方式：
```c
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
```

## 11. 类型定义

C 语言提供了 `typedef` 关键字，用于建立新的数据类型名。

i.e.
- `typedef int Length;` 将 Length 定义为与 int 具有同等意义的类型名。
- `typedef int (*PFI)(char *, char *);` 将 PFI 定义为一个指向函数的指针，该函数具有 2 个 `char *` 类型的参数且返回值为 `int` 类型。

实际上，`typedef` 声明并没有创建一个新类型，它只是为某个已存在的类型增加了一个新的名称而已，通过这种方式声明的变量与通过普通方式声明的变量具有完全相同的属性。从这个角度上看，`typedef` 类似于 `#define` 语句，但由于 `typedef` 是由编译器解释的，因此它的文本替换功能要强于预处理器。

使用 `typedef` 有以下意义：
- 使程序参数化，提高程序的可移植性。如果 typedef 声明的数据类型同具体机器实现有关系，那么当程序移植到其它机器上时，只需要改变 typedef 类型定义就可以了。例如标准库中的 `size_t` 和 `ptrdiff_t` 等。
- 为程序提供更好的可读性，表达更加简洁。

## 12. Refer Links

[C Language Reference](https://en.cppreference.com/w/c/language)

[如何学习 C 语言？](https://www.zhihu.com/question/19668080)

[大话 C 语言变量和数据类型](http://c.biancheng.net/cpp/html/2891.html)

[C 语言数据类型转换](http://c.biancheng.net/cpp/html/24.html)

[菜鸟教程：C enum（枚举)](http://www.runoob.com/cprogramming/c-enum.html)

[C 语言 - 内存管理基础](https://www.jianshu.com/p/b2380e47d005)

[C 语言 - 内存管理深入](https://www.jianshu.com/p/ccb337572498)
