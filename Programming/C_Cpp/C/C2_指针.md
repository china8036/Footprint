- [C 语言：指针](#c-语言指针)
  - [1. 基本概念](#1-基本概念)
    - [1.1. 指针的类型](#11-指针的类型)
    - [1.2. 指针所指向的类型](#12-指针所指向的类型)
    - [1.3. 指针的值（指针所指向的内存区地址）](#13-指针的值指针所指向的内存区地址)
    - [1.4. 指针本身所占据的内存区](#14-指针本身所占据的内存区)
  - [2. 指针运算](#2-指针运算)
    - [2.1. 取值和取址运算](#21-取值和取址运算)
    - [2.2. 算术运算](#22-算术运算)
    - [2.3. 指针表达式](#23-指针表达式)
  - [3. 指针类型转换](#3-指针类型转换)
  - [4. 数组和指针](#4-数组和指针)
  - [5. 结构和指针](#5-结构和指针)
  - [6. 函数和指针](#6-函数和指针)
  - [7. 字符串和指针](#7-字符串和指针)
  - [8. Refer Links](#8-refer-links)

# C 语言：指针

## 1. 基本概念

指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。在 C 语言中，指针的使用非常广泛，因为它常常是表达某个计算的唯一途径，且同其他方法比较起来，使用指针通常可以生成更高效、更紧凑的代码。

要搞清一个指针需要搞清指针的四方面的内容：
- 指针的类型
- 指针所指向的类型
- 指针的值（指针所指向的内存区地址）
- 指针本身所占的内存区

### 1.1. 指针的类型

从语法的角度看，只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。

eg:
- `int *ptr;`: 指针的类型是 `int *`。
- `char *ptr;`: 指针的类型是 `char *`。
- `int **ptr;`: 指针的类型是 `int **`。
- `int (*ptr)[3];`: 指针的类型是 `int (*)[3]`。
- `int *(*ptr)[4];`: 指针的类型是 `int *(*)[4]`。

- 指针多多少少会出现一些比较复杂的类型，要理解复杂类型其实很简单，一个类型里会出现很多运算符，他们也像普通的表达式一样有优先级，因此原则：**从变量名处起，根据运算符优先级结合，一步一步分析**。

  i.e.
  - `int p;`: 这是一个普通的整型变量。
  - `int *p;`: 首先从 P 处开始，**先与 `*` 结合，所以说明 P 是一个指针**，然后再与 int 结合，说明指针所指向的内容的类型为 int 型。所以 P 是一个返回整型数据的指针。
  - `int p[3];`: 首先从 P 处开始，**先与 `[]` 结合，说明 P 是一个数组**，然后与 int 结合，说明数组里的元素是整型的，所以 P 是一个由整型数据组成的数组。
  - `int *p[3];`: 首先从 P 处开始，**先与 `[]` 结合，因为其优先级比 `*` 高，所以 P 是一个数组**，然后再与`*`结合，说明数组里的元素是指针类型，然后再与 int 结合，说明指针所指向的内容的类型是整型的，所以 P 是一个由返回整型数据的指针所组成的数组。
  - `int (*p)[3];`: 首先从 P 处开始，**先与 `*` 结合，说明 P 是一个指针**。然后再与 `[]` 结合，说明指针所指向的内容是一个数组，然后再与 int 结合，说明数组里的元素是整型的。所以 P 是一个指向由整型数据组成的数组的指针。
  - `int **p;`: 首先从 P 开始，**先与 `*` 结合，说是 P 是一个指针**，然后再与`*`结合，说明指针所指向的元素是指针，然后再与 int 结合，说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中，所以后面更复杂的类型我们就不考虑多级指针了，最多只考虑一级指针。

  - `int p(int);`: 首先从 P 处开始，**先与 `()` 结合，说明 P 是一个函数**，然后进入 `()` 里分析，说明该函数有一个整型变量的参数，然后再与外面的 int 结合，说明函数的返回值是一个整型数据。
  - `int (*p)(int);`: 首先从 P 处开始，**先与指针结合，说明 P 是一个指针**，然后与 `()` 结合，说明指针指向的是一个函数，然后再与 `()` 里的 int 结合，说明函数有一个 int 型的参数，再与最外层的 int 结合，说明函数的返回类型是整型，所以 P 是一个指向有一个整型参数且返回类型为整型的函数的指针。
  - `int *(*p(int))[3];`: 首先从 P 处开始，**先与 `()` 结合，说明 P 是一个函数**，然后进入 `()` 里面，与 int 结合，说明函数有一个整型变量参数，然后再与外面的 `*` 结合，说明函数返回的是一个指针，然后到最外面一层，先与 `[]` 结合，说明返回的指针指向的是一个数组，然后再与 `*` 结合，说明数组里的元素是指针，然后再与 int 结合，说明指针指向的内容是整型数据。所以 P 是一个参数为一个整型数据且返回一个指向由整型指针变量组成的数组的指针变量的函数。

  NOTE：**实际开发中一般不会用太复杂的类型，那样会大大减小程序的可读性**。

- void 指针

  在 C99 标准中，允许使用基类型为 void 的指针类型，可以定义一个基类型为 void 的指针变量，它不指向任何类型的数据。

  NOTE: **不要把 “指向 void 类型” 理解为能指向 “任何的类型” 的数据，而应该理解为 “指向空类型” 或者 “不指向确定” 的类型的数据**。在将它的值赋给另一个指针变量时由系统对它进行类型转换，使之适合被赋值变量的类型。

### 1.2. 指针所指向的类型

指针只能指向某种特定类型的对象（一个特例是 void 类型的指针可以存放指向任何类型的指针但不能间接引用自身），当通过指针来访问指针所指向的内存区时，**指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待，在指针的算术运算中，指针所指向的类型有很大的作用**。

从语法上看，只须把指针声明语句中的指针名字和名字左边的指针声明符 `*` 去掉，剩下的就是指针所指向的类型。

i.e.
- `int *ptr;`: 指针所指向的类型是 `int`。
- `char *ptr;`: 指针所指向的的类型是 `char`。
- `int **ptr;`: 指针所指向的的类型是 `int*`。
- `int (*ptr)[3];`: 指针所指向的的类型是 `int()[3]`。
- `int *(*ptr)[4];`: 指针所指向的的类型是 `int*()[4]`。

### 1.3. 指针的值（指针所指向的内存区地址）

指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值，其**长度取决于具体的机器实现**（在 32 位程序里，所有类型的指针的值都是一个 32 位整数，因为 32 位程序里内存地址全都是 32 位长）。**指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为 s`izeof( 指针所指向的类型 )` 的一片内存区**。

C 语言定义中，保证了 0 永远不是一个有效的数据地址，因此，返回值 0 可用来表示发生了异常事件。

我们说一个指针的值是 XX，就相当于说该指针指向了以 XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。若指针还未初始化，那么它所指向的内存区是不存在的，或者说是无意义的。

### 1.4. 指针本身所占据的内存区

指针本身占的内存可以通过 `sizeof( 指针的类型 )` 来获取，在 32 位平台中，由于地址是 32 位即 4 字节，因此指针本身占据了 4 个字节的长度。

指针本身占据的内存在判断一个指针表达式是否是左值时很有用。

## 2. 指针运算

### 2.1. 取值和取址运算

一元运算符 `&` 可用于取一个对象的地址。`&` 只能用于内存中的对象，即变量与数组元素，而不能用于表达式、常量或 register 变量。

一元运算符 `*` 可用于间接寻址或间接引用，当作用于指针时，将会返回指针所指向的对象。

i.e.
```c
int a=12;
int b;
int *p;
int **ptr;
```

- `p=&a;`: `&a` 的结果是一个指针，类型是 `int*`，指向的类型是 `int`，指向的地址是 a 的地址。
- `*p=24;`: `*p` 的结果，在这里它的类型是 `int`，它所占用的地址是 p 所指向的地址，显然，*p 就是变量 a。
- `ptr=&p;`: `&p` 的结果是个指针，该指针的类型是 p 的类型加个 `*`，在这里是 `int **`。该指针所指向的类型是 p 的类型，这里是 `int*`。该指针所指向的地址就是指针 p 自己的地址。
- `*ptr=&b;`: `*ptr` 是个指针，`&b` 的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以用 `&b` 来给 `*ptr` 赋值就是毫无问题的了。
- `**ptr=34;`: `*ptr` 的结果是 ptr 所指向的东西，在这里是一个指针，对这个指针再做一次 `*` 运算，结果是一个 `int` 类型的变量。

### 2.2. 算术运算

C 语言中**指针算术运算的意义和通常的数值的加减运算的意义并不一样，但指针的算术运算也是一致且有规律的**，将指针、数组和地址的算术运算集成在一起也是 C 语言最大的优点之一。

有效的指针算术运算通常包括：
- 相同类型指针之间的赋值运算
- 指针与整数之间的加法或剑法运算
- 指向相同数组中元素的两个指针间的减法或比较运算
- 将指针赋值为 0 或指针与 0 之间的比较运算

NOTE
- 所有的指针算术运算都会自动考虑它所指向的对象的长度。
- **指针可以加上或减去一个整数。**
- **两个指针不能进行加法运算，这是非法操作**，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。
- **两个指针可以进行减法操作，但必须类型相同**，一般用在数组操作。

i.e.
```c
char a[20];
int *ptr=(int *)a; // 强制类型转换并不会改变 a 的类型
ptr++;
```
指针 ptr 的类型是 `int*`, 它指向的类型是 int，它被初始化为指向整型变量 a。接下来的第 3 句中，指针 ptr 被加了 1，编译器是这样处理的：它把指针 ptr 的值加上了 sizeof(int)，在 32 位程序中，是被加上了 4，因为在 32 位程序中，int 占 4 个字节。由于地址是用字节做单位的，故 ptr 所指向的地址由原来的变量 a 的地址向高地址方向增加了 4 个字节。由于 char 类型的长度是一个字节，所以，原来 ptr 是指向数组 a 的第 0 号单元开始的四个字节，此时指向了数组 a 中从第 4 号单元开始的四个字节。

i.e.
```c
int main() {
  char a[20] = "You_are_a_girl";
  char *p = a;
  char **ptr = &p;
  printf("**ptr=%c\n", **ptr);
  ptr++;
  printf("**ptr=%c\n", **ptr);
}
```
ptr 的类型是`char **`，指向的类型是一个`char *`类型，该指向的地址就是 p 的地址`&p`，当执行`ptr++;`时，会使指针加一个`sizeof(char*)`，即`&p+4;`，所以最后的输出*(&p+4) 会是一个随机的值，或许是一个非法操作。

### 2.3. 指针表达式

一个表达式的结果如果是一个指针，那么这个表达式就叫指针表达式。

由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。

i.e.
```cpp
int a,b;
int array[10];
int *pa;
pa=&a; //&a 是一个指针表达式
Int **ptr=&pa; //&pa 也是一个指针表达式
*ptr=&b; //*ptr 和 &b 都是指针表达式
pa=array;
pa++; // 这也是指针表达式

char *arr[20];
char **parr=arr; // 如果把 arr 看作指针的话，arr 也是指针表达式
char *str;
str=*parr; // *parr 是指针表达式
str=*(parr+1); // *(parr+1) 是指针表达式
str=*(parr+2); // *(parr+2) 是指针表达式
```

## 3. 指针类型转换

当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在绝大多数情况下，指针的类型和指针表达式的类型是一样的；但如果指针的类型和指针表达式的类型不一样，就无法直接赋值，而需要先进行指针的强制类型转换：
```
(TYPE *)p；
```

这样**强制类型转换的结果是创建一个新指针，该新指针的类型是 `TYPE *`，它指向的类型是 `TYPE`，它指向的地址就是原指针指向的地址，而原来的指针 p 的一切属性都没有被修改**。

NOTE
- 在进行指针类型转换时，很容易出现安全问题，在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。

  i.e.
  ```c
  char s='a';
  int *ptr;
  ptr=(int *)&s;
  *ptr=1298；
  ```
  指针 ptr 是一个 `int *` 类型的指针，它指向的类型是 int。它指向的地址就是 s 的首地址。在 32 位程序中，s 占一个字节，int 类型占四个字节。最后一条语句不但改变了 s 所占的一个字节，还把和 s 相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。

  i.e.
  ```c
  char a;
  int *ptr=&a;
  ptr++;
  *ptr=115;
  ```
  第 3 句对指针 ptr 进行自加 1 运算后，ptr 指向了和整形变量 a 相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。

- 一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，必须保证类型一致，否则需要强制转换。

## 4. 数组和指针

在 C 语言中，指针与数组之间的关系非常密切。**通过数组下标所能完成的任何操作都可以通过指针来实现，且通常通过指针实现的程序比用数组下标实现的程序执行速度更快**，但用指针实现的程序理解起来会少位困难一些。

i.e.
```c
int array[10]={0,1,2,3,4,5,6,7,8,9},value;
value=array[0]; // 也可写成：value=*array;
value=array[3]; // 也可写成：value=*(array+3);
value=array[4]; // 也可写成：value=*(array+4);
```
类型是 `int[10]`，但如果把 array 看做指针的话，它指向数组的第 0 个单元，类型是 `int*` 所指向的类型是数组单元的类型即 `int`。因此 `*array` 等于 0；同理，`array+3` 是一个指向数组第 3 个单元的指针，所以 `*(array+3)` 等于 3；其它依此类推。

在表达式`*array` 中，array 扮演的是指针，因此这个表达式的结果就是数组第 0 号单元的值。`sizeof(*array)` 测出的是数组单元的大小。

表达式 `array+n`（其中 n=0，1，2，.....）中，array 扮演的是指针，故 array+n 的结果是一个指针，它的类型是 `TYPE *`，它指向的类型是 TYPE，它指向数组第 n 号单元。故 `sizeof(array+n)` 测出的是指针类型的大小。在 32 位程序中结果是 4。

NOTE:
- 数组名和指针之间有一个不同之处：指针是一个变量，因此 `parray=array` 和 `parray++` 都是合法的；但**数组名不是变量，因此不能对数组名进行赋值操作**，`array=parray` 或 `array++` 形式的语句都是非法的。

- `sizeof（指针名称)` 测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？答案是**指针自身类型的大小**。例如：
  ```c
  int(*ptr)[10];
  则在 32 位程序中，有：
  sizeof(int(*)[10])==4
  sizeof(int[10])==40
  sizeof(ptr)==4
  ```
  也就是说，**`sizeof（对象)` 测出的都是对象自身的类型的大小，而不是别的什么类型的大小**。

## 5. 结构和指针

i.e.
```c
struct MyStruct
{
    int a;
    int b;
    int c;
};
struct MyStruct ss = {20,30,40}; // 声明了结构对象 ss，并把 ss 的成员初始化为 20，30 和 40
struct MyStruct *ptr = &ss; // 声明了一个指向结构对象 ss 的指针，它的类型是 MyStruct *, 它指向的类型是 MyStruct
int *pstr = (int*)&ss; // 声明了一个指向结构对象 ss 的指针，但是 pstr 和它被指向的类型 ptr 是不同的
```

- 通过指针 ptr 来访问 ss 的三个成员变量
  ```c
  ptr->a;  // 指向运算符，或者可以这们 (*ptr).a, 建议使用前者
  ptr->b;
  ptr->c;
  ```

- 通过指针 pstr 来访问 ss 的三个成员变量
  ```c
  *pstr；     // 访问了 ss 的成员 a
  *(pstr+1);  // 访问了 ss 的成员 b
  *(pstr+2)   // 访问了 ss 的成员 c
  ```
  但**这样使用 pstr 来访问结构成员是不正规的**。所有的 C/C++ 编译器总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙；但在存放结构对象的各个成员时，在某种编译环境下可能会需要字对齐或双字对齐，需要在相邻两个成员之间加若干个"填充字节"，这就导致各个成员之间可能会有若干个字节的空隙。也就是说，**即使 `*pstr` 访问到了结构对象 ss 的第一个成员变量 a，也不能保证 `*(pstr+1)` 就一定能访问到结构成员 b**。

## 6. 函数和指针

在 C 语言中，函数本身不是变量，但可以定义指向函数的指针，从而使得函数可以被赋值、存放在数组中、传递给函数或作为函数的返回值等。对于函数指针 `int (*comp)(void *, void *)`，可以通过 `(*comp)(v[i], v[j])` 对该参数进行调用。其中，圆括号是必须的，这样才能保证其中各个部分正确结合。

i.e.
```c
int fun1(char *,int);
int (*pfun1)(char *,int);
pfun1=fun1;
int a=(*pfun1)("abcdefg",7); // 通过函数指针调用函数
```

## 7. 字符串和指针

C 语言中由于指针的灵活性，导致指针能代替数组使用，或者混合使用，这些导致了许多指针和数组的迷惑。
- 数组是多个元素的集合，在内存中分布在地址相连的单元中，所以可以通过其下标访问不同单元的元素。
- 指针也是一种变量，只不过它的内存单元中保存的是一个标识其他位置的地址，由于地址也是整数，在 32 位平台下，指针默认为 32 位。

i.e.
```c
char *s = "China";
```
为什么可以把一个字符串赋给一个指针变量？不是类型不一致吗？

在 C 语言中，编译器会给字符串常量在 `.rodata` 段内存中分配地址，因此字符串常量的本质表示其实是它第一个字符的地址，**C 语言中操作字符串就是通过它在内存中的存储单元的首地址进行的**。例如：
- 对于字符串常量 `"China"`, 存储在内存中的 `0x3000 0x3001 0x3002 0x3003 0x3004 0x3005`，其中 `0x3005` 存储的是字符串末尾标志 `\0`，而赋值给指针 s 的值正是该字符串常量的首地址 `0x3000`。
- 对于 printf() 中的 `%s`，它的原理其实也是通过字符串首地址输出字符串，`printf("%s", s);` 传给它的其实是 s 所保存的字符串的地址。

i.e.
```c
char s1[] = "aaa";
s1[0] = 'm'; // normal

char *s2 = "bbb";
s2[0] = 'm'; //segment fault
```
- 对于 `char s1[] = "aaa";`：是在运行时赋值的，`"aaa"` 是在栈上分配内存，使用 mov 指令直接将值写入栈上对应内存。
- 对于 `char *s2 = "bbb";`：是在编译时就确定的，`"bbb"` 是一个字符串字面量，编译器会将字符串字面量当作常量数据处理，存放在 `.rodata` 段，这样一来，s2 将指向 `.rodata` 段中的某处内存，因此对该段内存的修改会引起段错误。

## 8. Refer Links

[让你不再害怕指针——C 指针详解 ( 经典，非常详细 )](https://blog.csdn.net/soonfly/article/details/51131141)

[void 及 void 指针含义的深刻解析](https://blog.csdn.net/geekcome/article/details/6249151)

[指针的那些事 ----- 初窥指针的强制转换](https://my.oschina.net/alphajay/blog/60893)

[C 语言指针类型 - 强制转换](https://www.cnblogs.com/ArtsCrafts/p/C%E6%8C%87%E9%92%88.html)

[深入 char * , char ** 内核](https://blog.csdn.net/daiyutage/article/details/8604720)

[char 指针和 char 数组内存分配的区别](https://blog.csdn.net/gsyzhu/article/details/8241188)

