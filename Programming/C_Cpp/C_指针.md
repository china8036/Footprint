- [C 指针](#c-指针)
  - [1. 基本概念](#1-基本概念)
    - [1.1. 指针的类型](#11-指针的类型)
    - [1.2. 指针所指向的类型](#12-指针所指向的类型)
    - [1.3. 指针的值（指针所指向的内存区地址）](#13-指针的值指针所指向的内存区地址)
    - [1.4. 指针本身所占据的内存区](#14-指针本身所占据的内存区)
  - [2. 指针运算](#2-指针运算)
    - [2.1. 算术运算](#21-算术运算)
    - [2.2. 取值和取址运算](#22-取值和取址运算)
  - [3. 指针表达式](#3-指针表达式)
  - [4. 数组和指针](#4-数组和指针)
  - [5. 结构和指针](#5-结构和指针)
  - [6. 函数和指针](#6-函数和指针)
  - [7. 字符串和指针](#7-字符串和指针)
  - [8. void 指针](#8-void-指针)
  - [9. 指针类型转换](#9-指针类型转换)
  - [10. Refer Links](#10-refer-links)

# C 指针

## 1. 基本概念

指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。

要搞清一个指针需要搞清指针的四方面的内容：

### 1.1. 指针的类型

从语法的角度看，只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。

eg:
- `int*ptr;`: 指针的类型是`int*`
- `char*ptr;`: 指针的类型是`char*`
- `int**ptr;`: 指针的类型是`int**`
- `int(*ptr)[3];`: 指针的类型是`int(*)[3]`
- `int*(*ptr)[4];`: 指针的类型是`int*(*)[4]`

辨析：

指针多多少少会出现一些比较复杂的类型，要理解复杂类型其实很简单，一个类型里会出现很多运算符，他们也像普通的表达式一样有优先级，因此原则：**从变量名处起，根据运算符优先级结合，一步一步分析**。
- `int p;`: 这是一个普通的整型变量。
- `int *p;`: 首先从 P 处开始，先与 `*` 结合，所以说明 P 是一个指针，然后再与 int 结合，说明指针所指向的内容的类型为 int 型。所以 P 是一个返回整型数据的指针。
- `int p[3];`: 首先从 P 处开始，先与 [] 结合，说明 P 是一个数组，然后与 int 结合，说明数组里的元素是整型的，所以 P 是一个由整型数据组成的数组。
- `int *p[3];`: 首先从 P 处开始，先与 [] 结合，因为其优先级比`*`高，所以 P 是一个数组，然后再与`*`结合，说明数组里的元素是指针类型，然后再与 int 结合，说明指针所指向的内容的类型是整型的，所以 P 是一个由返回整型数据的指针所组成的数组。
- `int (*p)[3];`: 首先从 P 处开始，先与`*`结合，说明 P 是一个指针。然后再与 [] 结合（与"()"这步可以忽略，只是为了改变优先级）, 说明指针所指向的内容是一个数组，然后再与 int 结合，说明数组里的元素是整型的。所以 P 是一个指向由整型数据组成的数组的指针。
- `int **p;`: 首先从 P 开始，先与`*`结合，说是 P 是一个指针，然后再与`*`结合，说明指针所指向的元素是指针，然后再与 int 结合，说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中，所以后面更复杂的类型我们就不考虑多级指针了，最多只考虑一级指针。
- `int p(int);`: 首先从 P 处开始，先与 () 结合，说明 P 是一个函数，然后进入 () 里分析，说明该函数有一个整型变量的参数，然后再与外面的 int 结合，说明函数的返回值是一个整型数据。
- `int (*p)(int);`: 首先从 P 处开始，先与指针结合，说明 P 是一个指针，然后与 () 结合，说明指针指向的是一个函数，然后再与 () 里的 int 结合，说明函数有一个 int 型的参数，再与最外层的 int 结合，说明函数的返回类型是整型，所以 P 是一个指向有一个整型参数且返回类型为整型的函数的指针。
- `int *(*p(int))[3];`: 首先从 P 处开始，先与 () 结合，说明 P 是一个函数，然后进入 () 里面，与 int 结合，说明函数有一个整型变量参数，然后再与外面的`*`结合，说明函数返回的是一个指针，然后到最外面一层，先与 [] 结合，说明返回的指针指向的是一个数组，然后再与`*`结合，说明数组里的元素是指针，然后再与 int 结合，说明指针指向的内容是整型数据。所以 P 是一个参数为一个整型数据且返回一个指向由整型指针变量组成的数组的指针变量的函数。

NOTE：实际开发中一般不会用太复杂的类型，那样会大大减小程序的可读性。

### 1.2. 指针所指向的类型

当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待，在指针的算术运算中，指针所指向的类型有很大的作用。

从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。

eg:
- `int*ptr;`: 指针所指向的类型是`int`
- `char*ptr;`: 指针所指向的的类型是`char`
- `int**ptr;`: 指针所指向的的类型是`int*`
- `int(*ptr)[3];`: 指针所指向的的类型是`int()[3]`
- `int*(*ptr)[4];`: 指针所指向的的类型是`int*()[4]`

### 1.3. 指针的值（指针所指向的内存区地址）

指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在 32 位程序里，所有类型的指针的值都是一个 32 位整数，因为 32 位程序里内存地址全都是 32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为 sizeof( 指针所指向的类型 ) 的一片内存区。

我们说一个指针的值是 XX，就相当于说该指针指向了以 XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。若指针还未初始化，那么它所指向的内存区是不存在的，或者说是无意义的。

### 1.4. 指针本身所占据的内存区

指针本身占的内存可以通过 sizeof( 指针的类型 ) 来获取，在 32 位平台中，由于地址是 32 位即 4 字节，因此指针本身占据了 4 个字节的长度。

指针本身占据的内存在判断一个指针表达式是否是左值时很有用。

## 2. 指针运算

### 2.1. 算术运算

指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。

两个指针不能进行加法运算，这是非法操作，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。两个指针可以进行减法操作，但必须类型相同，一般用在数组操作。

eg:
```c
char a[20];
int *ptr=(int *)a; // 强制类型转换并不会改变 a 的类型
ptr++;
```
指针 ptr 的类型是 int*, 它指向的类型是 int，它被初始化为指向整型变量 a。接下来的第 3 句中，指针 ptr 被加了 1，编译器是这样处理的：它把指针 ptr 的值加上了 sizeof(int)，在 32 位程序中，是被加上了 4，因为在 32 位程序中，int 占 4 个字节。由于地址是用字节做单位的，故 ptr 所指向的地址由原来的变量 a 的地址向高地址方向增加了 4 个字节。由于 char 类型的长度是一个字节，所以，原来 ptr 是指向数组 a 的第 0 号单元开始的四个字节，此时指向了数组 a 中从第 4 号单元开始的四个字节。

eg:
```c
char a[20]=" You_are_a_girl";
char *p=a;
char **ptr=&p;
printf("**ptr=%c\n",**ptr);
ptr++;
printf("**ptr=%c\n",**ptr);
```
ptr 的类型是`char **`，指向的类型是一个`char *`类型，该指向的地址就是 p 的地址`&p`，当执行`ptr++;`时，会使指针加一个`sizeof(char*)`，即`&p+4;`，所以最后的输出*(&p+4) 会是一个随机的值，或许是一个非法操作。

### 2.2. 取值和取址运算

eg:
```c
int a=12; 
int b; 
int *p; 
int **ptr;
```
- `p=&a;`: `&a` 的结果是一个指针，类型是 int*，指向的类型是 int，指向的地址是 a 的地址。
- `*p=24;`: `*p` 的结果，在这里它的类型是 int，它所占用的地址是 p 所指向的地址，显然，*p 就是变量 a。
- `ptr=&p;`: `&p` 的结果是个指针，该指针的类型是 p 的类型加个*，在这里是 int **。该指针所指向的类型是 p 的类型，这里是 int*。该指针所指向的地址就是指针 p 自己的地址。
- `*ptr=&b;`: `*ptr` 是个指针，&b 的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以用 &b 来给*ptr 赋值就是毫无问题的了。
- `**ptr=34;`: `*ptr` 的结果是 ptr 所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果是一个 int 类型的变量。

## 3. 指针表达式

一个表达式的结果如果是一个指针，那么这个表达式就叫指针表达式。

由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。

eg:
```cpp
int a,b;
int array[10];
int *pa;
pa=&a; //&a 是一个指针表达式
Int **ptr=&pa; //&pa 也是一个指针表达式
*ptr=&b; //*ptr 和 &b 都是指针表达式
pa=array;
pa++; // 这也是指针表达式

char *arr[20];
char **parr=arr; // 如果把 arr 看作指针的话，arr 也是指针表达式
char *str;
str=*parr; // *parr 是指针表达式
str=*(parr+1); // *(parr+1) 是指针表达式
str=*(parr+2); // *(parr+2) 是指针表达式
```

## 4. 数组和指针

一般而言数组名 array 代表数组本身，类型是 int[10]，但如果把 array 看做指针的话，它指向数组的第 0 个单元，类型是 int* 所指向的类型是数组单元的类型即 int。

eg:
```cpp
int array[10]={0,1,2,3,4,5,6,7,8,9},value;
value=array[0]; // 也可写成：value=*array;
value=array[3]; // 也可写成：value=*(array+3);
value=array[4]; // 也可写成：value=*(array+4);
```
TODO:

在表达式`*array` 中，array 扮演的是指针，因此这个表达式的结果就是数组第 0 号单元的值。`sizeof(*array)` 测出的是数组单元的大小。

表达式 `array+n`（其中 n=0，1，2，.....）中，array 扮演的是指针，故 array+n 的结果是一个指针，它的类型是 `TYPE *`，它指向的类型是 TYPE，它指向数组第 n 号单元。故 `sizeof(array+n)` 测出的是指针类型的大小。在 32 位程序中结果是 4。

sizeof（指针名称) 测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？

答案是前者。例如：
```cpp
int(*ptr)[10];
则在 32 位程序中，有：
sizeof(int(*)[10])==4
sizeof(int[10])==40
sizeof(ptr)==4
```
实际上，sizeof（对象) 测出的都是对象自身的类型的大小，而不是别的什么类型的大小。

## 5. 结构和指针

TODO:







## 6. 函数和指针

## 7. 字符串和指针

『深入 char * ,char ** ,char a[ ] ,char *a[] 内核』(https://blog.csdn.net/daiyutage/article/details/8604720)

C 语言中由于指针的灵活性，导致指针能代替数组使用，或者混合使用，这些导致了许多指针和数组的迷惑。

数组是多个元素的集合，在内存中分布在地址相连的单元中，所以可以通过其下标访问不同单元的元素。

指针也是一种变量，只不过它的内存单元中保存的是一个标识其他位置的地址，由于地址也是整数，在 32 位平台下，指针默认为 32 位。

在 C 语言中字符串常量的本质表示其实是一个地址，这是许多初学者比较难理解的问题。

举例：
```cpp
char *s;
s = "China";
```

为什么可以把一个字符串赋给一个指针变量。

这不是类型不一致吗？这就是上面提到的关键。

C 语言中编译器会给字符串常量分配地址，如果 "China", 存储在内存中的 0x3000 0x3001 0x3002 0x3003 0x3004 0x3005，**C 语言中操作字符串就是通过它在内存中的存储单元的首地址进行的**。

s = "China" ，意思是什么，对了，地址。

其实真正的意义是 s ="China" = 0x3000;

看清楚了吧 ，你把 China 看作是字符串，但是编译器把它看作是地址 0x3000，即字符串常量的本质表现是代表它的第一个字符的地址。

s = 0x3000

这样写似乎更符合直观的意思。

搞清楚这个问题，那么 %s ，它的原理其实也是通过字符串首地址输出字符串，printf("%s ", s);   传给它的其实是 s 所保存的字符串的地址。

https://blog.csdn.net/gsyzhu/article/details/8241188

```c
char s1[] = "aaaaaaaaaaaaaaa";  
char *s2 = "bbbbbbbbbbbbbbbbb";  
```
aaaaaaaaaaa 是在运行时刻赋值的，而 bbbbbbbbbbb 是在编译时就确定的；  

## 8. void 指针

https://blog.csdn.net/geekcome/article/details/6249151

C99（C 语言的官方标准第二版）允许使用基类型为 void 的指针类型，可以定义一个基类型为 void 的指针变量，它不指向任何类型的数据。请注意：不要把 “指向 void 类型” 理解为能指向 “任何的类型” 的数据，而应该理解为 “指向空类型” 或者 “不指向确定” 的类型的数据。在将它的值赋给另一个指针变量时由系统对它进行类型转换，使之适合被赋值变量的类型。

## 9. 指针类型转换

https://my.oschina.net/alphajay/blog/60893

https://www.cnblogs.com/ArtsCrafts/p/C%E6%8C%87%E9%92%88.html

## 10. Refer Links

TODO:

[让你不再害怕指针——C 指针详解 ( 经典，非常详细 )](https://blog.csdn.net/soonfly/article/details/51131141)