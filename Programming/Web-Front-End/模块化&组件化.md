- [模块化 & 组件化](#%E6%A8%A1%E5%9D%97%E5%8C%96-%E7%BB%84%E4%BB%B6%E5%8C%96)
  - [模块化](#%E6%A8%A1%E5%9D%97%E5%8C%96)
  - [组件化](#%E7%BB%84%E4%BB%B6%E5%8C%96)
  - [比较 & 协同工作](#%E6%AF%94%E8%BE%83-%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C)
  - [Refer Links](#refer-links)

# 模块化 & 组件化

> 前端是一种技术问题较少、工程问题较多的软件开发领域。

当我们要开发一款完整的 Web 应用时，前端将面临更多的工程问题，比如：
- 大体量：多功能、多页面、多状态、多系统；
- 大规模：多人甚至多团队合作开发；
- 高性能：CDN 部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步 / 异步加载、移动端首屏 CSS 内嵌、HTTP 2.0 服务端资源推送。

## 模块化

- JavaScript 模块化：

  - 模块化实现思路：

    使用"立即执行函数"（IIFE），返回一个要对外暴露的对象，不"污染"了全局变量，紧密联系模块内成员，同时可以达到不暴露私有成员的目的。并将使用到的其它模块作为参数传入 IIFE，从而保证模块的独立性，还使得模块之间的依赖关系变得明显。
    
    例：
    ```javascript
    var module1 = (function ($, YAHOO) {
    var _count = 0;
    var m1 = function() {
      //...
    };
    var m2 = function(){
      //...
    };
    return {
    　　m1 : m1,
    　　m2 : m2
    };
    //...
    　})(jQuery, YAHOO);
    ```

  - 模块化规范：AMD/CommonJS/UMD/ES6 Module

- CSS 模块化：

  基本都是在 less、sass、stylus 等预处理器的 import/mixin 特性支持下实现的

## 组件化

前端作为一种 GUI 软件，光有 JS/CSS 的模块化还不够，对于 UI 组件的分治也有着同样迫切的需求：

前端组件化开发理念：
- 页面上的每个 独立的 可视 / 可交互区域视为一个组件；
- 每个组件对应一个工程目录，组件所需的各种资源都在这个目录下就近维护；
- 由于组件具有独立性，因此组件与组件之间可以 自由组合；
- 页面只不过是组件的容器，负责组合组件形成功能完整的界面；
- 当不需要某个组件，或者想要替换组件时，可以整个目录删除 / 替换。

一份真正成熟可靠的组件化方案，需要具备的能力：
- “资源高内聚”—— 组件资源内部高内聚，组件资源由自身加载控制
- “作用域独立”—— 内部结构密封，不与全局或其他组件产生影响 
- “自定义标签”—— 定义组件的使用方式
- “可相互组合”—— 组件正在强大的地方，组件间组装整合
- “接口规范化”—— 组件接口有统一规范，或者是生命周期的管理

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2017/12/1/d64dff04a02240630a1c5f20638dca9d.jpg)

组件化开发具有较高的通用性，无论是前端渲染的单页面应用，还是后端模板渲染的多页面应用，组件化开发的概念都能适用。组件 HTML 部分根据业务选型的不同，可以是静态的 HTML 文件，可以是前端模板，也可以是后端模板，**不同的技术选型决定了不同的组件封装和调用策略**：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2017/12/1/1d80630af01c46f72086b95c66683bb6.jpg)

基于这样的工程理念，我们很容易将系统以独立的组件为单元进行分工划分：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2017/12/1/179df05157cff345323d8c6b7738b48b.jpg)

由于系统功能被分治到独立的模块或组件中，粒度比较精细，组织形式松散，开发者之间不会产生开发时序的依赖，大幅提升并行的开发效率，理论上允许随时加入新成员认领组件开发或维护工作，也更容易支持多个团队共同维护一个大型站点的开发。

## 比较 & 协同工作

- 模块化和组件化都是基于分而治之的思想。

- 模块化解决了将复杂系统解耦的问题，偏代码层面，类似 java 里一个个 class，把业务代码切分开

- 组件化解决了代码复用的问题，偏视图层面，把界面划分成一块块

- 两者都是可以复用，以及协同工作的。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2017/12/1/11e30bb93ebfa3c13abfa556a83eb20d.jpg)

组件化结合模块化开发，整个前端项目可以划分为这么几种开发概念：

| 名称    | 说明                      | 举例                                       |
| ----- | ----------------------- | ---------------------------------------- |
| JS 模块  | 独立的算法和数据单元              | 浏览器环境检测 (detect)，网络请求 (ajax)，应用配置 (config)，DOM 操作 (dom)，工具函数 (utils)，以及组件里的 JS 单元 |
| CSS 模块 | 独立的功能性样式单元              | 栅格系统 (grid)，字体图标 (icon-fonts)，动画样式 (animate)，以及组件里的 CSS 单元 |
| UI 组件  | 独立的可视 / 可交互功能单元           | 页头 (header)，页尾 (footer)，导航栏 (nav)，搜索框 (search) |
| 页面    | 前端这种 GUI 软件的界面状态，是 UI 组件的容器 | 首页 (index)，列表页 (list)，用户管理 (user)           |
| 应用    | 整个项目或整个站点被称之为应用，由多个页面组成 |                                          |

基于这些理念，前端开发就成了这个样子：
- 整个 Web 应用由页面组成
- 页面由组件组成
- 一个组件一个目录，资源就近维护
- 组件可组合，组件的 JS 可依赖其他 JS 模块，CSS 可依赖其他 CSS 单元

因此对于一般中小规模的项目，大致可以规划出这样的源码目录结构：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2017/12/1/97b84f662c2dd347e2643f0956bec57f.jpg)

以上架构设计历经许多不同公司不同业务场景的前端团队验证，收获了不错的口碑，是行之有效的前端工程分治方案。

## Refer Links

[前端工程——基础篇](https://github.com/fouber/blog/issues/10)

[前端开发的模块化和组件化的定义，以及两者的关系？](https://www.zhihu.com/question/37649318)

[AlloyTeam: 致我们终将组件化的 web](http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/)

[W3C 组件化规范](https://www.w3.org/wiki/WebComponents/)