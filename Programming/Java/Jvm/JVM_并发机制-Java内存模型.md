- [JVM 并发机制 - Java 内存模型](#jvm-%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6---java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)
  - [1. 基本概念](#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [1.1. CPU 缓存](#11-cpu-%E7%BC%93%E5%AD%98)
    - [1.2. CPU 乱序执行优化](#12-cpu-%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%BC%98%E5%8C%96)
    - [1.3. 内存模型](#13-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)
  - [2. JMM 结构：主内存与工作内存](#2-jmm-%E7%BB%93%E6%9E%84%EF%BC%9A%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98)
  - [3. JMM 交互操作](#3-jmm-%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C)
  - [4. JMM 操作规则](#4-jmm-%E6%93%8D%E4%BD%9C%E8%A7%84%E5%88%99)
    - [4.1. 基本规则](#41-%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99)
    - [4.2. volatile 的特殊规则](#42-volatile-%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99)
    - [4.3. long 和 double 的特殊规则](#43-long-%E5%92%8C-double-%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99)
  - [5. JMM 并发特性](#5-jmm-%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7)
    - [5.1. 原子性 (Atomicity)](#51-%E5%8E%9F%E5%AD%90%E6%80%A7-atomicity)
      - [5.1.1. 定义](#511-%E5%AE%9A%E4%B9%89)
      - [5.1.2. JMM 实现](#512-jmm-%E5%AE%9E%E7%8E%B0)
        - [5.1.2.1. 基础数据类型的原子性](#5121-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7)
        - [5.1.2.2. 更大范围的原子性](#5122-%E6%9B%B4%E5%A4%A7%E8%8C%83%E5%9B%B4%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7)
    - [5.2. 可见性 (Visibility)](#52-%E5%8F%AF%E8%A7%81%E6%80%A7-visibility)
      - [5.2.1. 定义](#521-%E5%AE%9A%E4%B9%89)
      - [5.2.2. JMM 实现](#522-jmm-%E5%AE%9E%E7%8E%B0)
        - [5.2.2.1. volatile](#5221-volatile)
        - [5.2.2.2. synchronized 和 final](#5222-synchronized-%E5%92%8C-final)
    - [5.3. 有序性 (Ordering)](#53-%E6%9C%89%E5%BA%8F%E6%80%A7-ordering)
      - [5.3.1. 定义](#531-%E5%AE%9A%E4%B9%89)
      - [5.3.2. JMM 实现](#532-jmm-%E5%AE%9E%E7%8E%B0)
        - [5.3.2.1. volatile 和 synchronized](#5321-volatile-%E5%92%8C-synchronized)
        - [5.3.2.2. 先行发生原则](#5322-%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99)
  - [6. Refer Links](#6-refer-links)

# JVM 并发机制 - Java 内存模型

## 1. 基本概念

### 1.1. CPU 缓存

由于计算机的存储设备与处理器的运算速度有几个数量级的差距，因此现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速 CPU 缓存 (CPU Cache) 来作为内存与处理器之间的缓冲：将运算需要的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/30/092d6d064361f55fe7e967bf0122717e.jpg)

基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但也引入了一个新的问题：缓存一致性 (Cache Coherence)。在多处理器系统中，每个处理器都有自己的 Cache，但它们共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的数据不一致。为解决 Cache Coherence 问题，需要各个处理器在访问缓存时都遵循一些协议，按照这些协议来进行缓存的读写操作。

### 1.2. CPU 乱序执行优化

为了使得处理器内部的运算单元能够尽量被充分利用，处理器可能会对输入代码进行乱序执行 (Out-Of-Order Execution) 优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。**与处理器的乱序执行优化类型，Java 虚拟机的即时编译器中也有类似的指令重排序 (Instruction Reorder) 优化**。

### 1.3. 内存模型

**内存模型可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象，是一组内存访问的规则，不同架构的物理机器可以拥有不一样的内存模式。**

主流程序语言（如 C/C++ 等）大多都直接使用物理机器和操作系统的内存模式，因此会由于不同平台上内存模型的差异，导致程序在不同平台上的表现结果存在较大差异。

因此，**Java 虚拟机规范中试图定义一种 Java 内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致性的内存访问效果。**经过长时间的验证和修补，在 **JDK1.5（实现了 JSR-133）**发布后，**Java 内存模型 (Java Memory Model, JMM)** 已经成熟和完善起来了。

**Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量值这样的底层细节。**此处的变量 (Variable) 与 Java 编译中所说的变量略有区别，它包括了实例字段，静态字段和构成数组对象的元素，但是不包括局部变量与方法 Java 内存模型与线程参数，因为后者是线程私有的，不会被共享，自然就不存在竞争的问题。

为了获得比较好的执行效率，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器调整代码执行顺序这类权限。

## 2. JMM 结构：主内存与工作内存

Java 内存模型规定了所有的变量都存储在主内存 (Main Memory) 中，每个线程还有自己的工作内存 (Working Memory)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝。

**线程对变量的所有操作（读取，赋值等) 都必须是工作内存中进行，而不能直接读写主内存中的变量。**不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

需要注意的是，对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存 （线程私有数据区域) 和主内存 （堆内存) 之分，也就是说 **JMM 对内存的划分对硬件内存并没有任何影响，JMM 只是一种抽象的概念，是一组规则，并不实际存在**，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存或 CPU 缓存、寄存器中。由于程序运行时主要访问和读写的是工作内存而不是主内存，因此 **JVM 会偏向于将主内存直接存放于物理内存之中，而优先将主内存存放在寄存器或者 CPU 高速缓存块之中**。

线程、主内存、工作内存三者的交互关系如下图：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/30/a0d0a99e86bc68e93b7b39e07f2d64f1.jpg)

其中，主内存和工作内存实际上与 JVM 内存区域没有实质上的关系，但若一定要勉强对应起来，则主内存对应于 Java 堆中的对象实例部分，而工作内存对应于 Java 虚拟机栈中的部分区域。

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/30/8aa3835b09eb368ac8412e39021a57b7.jpg)

## 3. JMM 交互操作

关于主内存于工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节问题，JMM 中定义了以下 8 种操作来完成，且要求 JVM 的具体实现必须保证以下 8 种操作的原子性：
- lock（锁定)：作用于主内存变量，它把一个变量标识为一条线程独占的状态。
- unlock（解锁)：作用于主内存变量，它把一个处理锁定的状态的变量释放出来，释放后的变量才可以被其它线程锁定，unlock 之前必须将变量值同步回主内存。

- read（读取)：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。
- load（载入)：作用于工作内存变量，它把 read 操作从主内存中得到的值放入工作内存的变量副本中。
- use（使用)：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的字节码指令时将会执行这个操作。

- assign（赋值)：作用于工作内存变量，它把一个从执行引擎接到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store（存储)：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以 Java 内存模型与线程便随后的 write 操作使用。
- write（写入)：作用于主内存的变量，它把 store 操作从工作内存中得到的值放入主内存的变量中。

如果要把一个变量从主内存复制到工作内存，那就要顺序地执行 read 和 load 操作，如果要把变量从工作内存同步回主内存，就要顺序地执行 store 和 write 操作。**Java 内存模型只是要求上述两个操作必须按顺序执行，而没有保证必须是连续执行。**也就是说 read 与 load 之间、store 与 write 之间是可以插入其它指令的，如果对主在内中的变量 a,b 进行访问时，一种可能出现的顺序是 read a、readb、loadb、load a。

## 4. JMM 操作规则

### 4.1. 基本规则

Java 内存模型还规定了执行上述 8 种基础操作时必须满足如下规则：
- 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写但主内存不接受的情况出现。

- 不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变（为工作内存变量赋值) 了之后必须把该变化同步回主内存。

- 一个新变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化 (load 和 assign) 的变量，换话说就是一个变量在实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。

- 一个变量再同一个时刻只允许一个线程对其进行 lock 操作，但 lock 操作可以被同一个线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。

- 如果堆一个变量执行 lock，那么将会清空工作内存中此变量的值，在执行引擎使用这个变量之前，需要重写执行 load 或 assign 操作初始化变量的值。

- 如果一个变量事先没有被 load 操作锁定，则不允许对它执行 unlock 操作：也不允许去 unlock 一个被其它线程锁定的变量。

- 对一个变量执行 unloack 之前，必须把此变量同步回主内存中（执行 store 和 write 操作)。

### 4.2. volatile 的特殊规则

除此之外，JMM 中对 volatile 变量还定义了了一些特殊规则，假设 T 表示一个线程，V 和 W 分别表示两个 volatile 变量，那么在进行 read、load、use、assign、store 和 write 操作时需要满足以下规则：
- 线程 T 对变量 V 的 load、use、read 动作必须连续一起出现。从而保证在工作内存中，**每次使用 V 前都必须从主内存刷新最新的值，使得当前线程能看见其它线程对变量 V 所做的修改后的值**。

- 线程 T 对变量 V 的 store、assign、write 动作必须连续一起出现。从而保证在工作内存中，**每次修改 V 后都必须立刻同步回主内存中，使得其它线程可以看到自己对变量 V 所做的修改**。

- 要求**volatile 修饰的变量不会被指令重排序优化**，保证代码的执行顺序与程序的顺序相同。

### 4.3. long 和 double 的特殊规则

JMM 要求 8 个基本操作都必须具备原子性，但对于 64 位的数据类型（long 和 double），在模型中特别定义了一条相对宽松的规定：**允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行**，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这一项规定称为**long 和 double 的非原子性协定**。

由于在 32 位平台上，对 64 位的数据类型的操作需要分两步来进行而不能保证原子性，因此若有多个线程共享一个未声明为 volatile 的 64 位变量，且同时对该变量进行读取和修改操作，那么某些线程可能回读取到一个既非原值，也不是其它线程修改值得代表了“半个变量”的数值。

但这种“半个变量”的情况实际上非常罕见。JMM 虽不要求 JVM 实现保证 long 和 double 变量的原子性，但 JMM 的描述中“强烈建议”JVM 实现这么做。因此，在实际开发中，各种平台下的商用虚拟机几乎都选择把 64 位数据的读写操作作为原子操作来对待，因此**我们在编码时一般不需要把用到的 long 和 double 变量专门声明为 volatile**。

**这些内存访问操作的规则限定，完全确定了 Java 程序中哪些内存访问操作在并发下是安全的**。

## 5. JMM 并发特性

在并发编程中我们经常会遇到三个问题：原子性问题、可见性问题和有序性问题。要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。因此，**原子性、可见性和有序性也称为并发编程的三大特性**。

实际上，**JMM 的设计就是围绕着原子性、可见性、有序性这三个特征在并发过程中如何实现来建立的**，下面是这三个特性的实现原理。

### 5.1. 原子性 (Atomicity)

#### 5.1.1. 定义

原子性指的是，一个操作或者多个操作的执行，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

#### 5.1.2. JMM 实现

##### 5.1.2.1. 基础数据类型的原子性

由 Java 内存模型来直接保证的原子性变量操作包括 read、load、use、assign、store 和 write 共 6 个，因此，可以认为**在 Java 中，对基础数据类型变量的读取和赋值操作都是具备原子性的**。

例：原子操作分析
```java
x = 10;        // 原子操作，直接将数值 10 赋值给 x，也就是说线程执行这个语句的会直接将数值 10 写入到工作内存中
y = x;         // 非原子操作，实际上包含 2 个操作，它先要去读取 x 的值，再将 x 的值写入工作内存
x++;           // 非原子操作，包括 3 个操作：读取 x 的值，进行加 1 操作，写入新的值
x = x + 1;     // 非原子操作，等同于 x++
```

因此，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。

##### 5.1.2.2. 更大范围的原子性

Java 内存模型只保证了基本读取和赋值是原子性操作，但如果应用场景需要一个更大范围的原子性保证，Java 内存模型还提供了 lock 和 unlock 操作来满足这种需求。

尽管虚拟机未把 lock 与 unlock 操作直接开放给用户级别使用，但提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐匿地使用这两个操作，这两个字节码指令反映到 Java 代码中就是 synchronized 关键字或 Lock 接口，因此在 synchronized 修饰块或 Lock.lock() 和 Lock.unlock() 之间的操作也具备原子性。

### 5.2. 可见性 (Visibility)

#### 5.2.1. 定义

可见性指的是，当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

#### 5.2.2. JMM 实现

要在 Java 内存模型中实现可见性，需要在变量修改后将新值同步回主内存，并在变量读取前从主内存刷新变量值。

普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

##### 5.2.2.1. volatile

Java 专门提供了 volatile 关键字来保证可见性。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

##### 5.2.2.2. synchronized 和 final

除了 volatile 之外，Java 还有两个关键字能实现可见性：synchronized 和 final。
- synchronized 同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store 和 write 操作)”这条规则获得的。
- final 关键字的可见性是指：被 final 修饰的字段是构造器一旦初始化完成，并且构造器没有把“this”引用传递出去，那么在其它线程中就能看见 final 字段的值。

### 5.3. 有序性 (Ordering)

#### 5.3.1. 定义

有序性指的是，程序指令执行的顺序完全按照代码的先后顺序来执行。

#### 5.3.2. JMM 实现

在 Java 内存模型中，允许编译器和处理器对指令进行重排序优化，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

Java 程序中的有序性可总结为：
- **如果在本线程内观察，所有操作都是有序的。**这是指“单线程内表现为串行语义” (Within-Thread As-If-Serial Semantics)，即不管怎么重排序，单线程下的执行结果不能被改变，编译器、runtime 和处理器都必须遵守 as-if-serial 语义。
- **如果在一个线程中观察另一个线程，所有操作都是无序的。**这是指多线程环境下的“指令重排序”现象和“工作内存与主内存同步延迟”现象。

##### 5.3.2.1. volatile 和 synchronized

Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性：
- volatile 关键字本身就包含了禁止指令重排序的语义。
- synchronized 则是由“一个变量在同一时刻只允许一条线程对其进行 lock 操作”这条规则来获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。

##### 5.3.2.2. 先行发生原则

如果 Java 内存模型中所有的有序性都只靠 volatile 和 synchronized 来完成，那么有一些操作将会变得很啰嗦，但是我们在编写 Java 并发代码的时候并没有感觉到这一点，这是因为 Java 语言中有一个“先行发生”(Happen-Before) 的原则。

JMM 定义的一系列的规则限定相当严谨，但实际实践起来却非常困难，因此判断一个访问在并发环境下是否安全时，通常会使用等效判断原则即先行发生原则，它是判断数据是否存在竞争，线程是否安全的主要依赖原则。

先行发生原则是指 Java 内存模型中定义的两项操作之间的偏序关系，如果说“操作 A 先行发生于操作 B”，其实就是说“发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到”（“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等）。如果两个操作的执行次序无法从 happens-before 原则推导出来，那么虚拟机就可以随意地对它们进行重排序，因此不能保证它们的有序性。

例：
```java
// 线程 A 中执行
i = 1;
// 线程 B 中执行
j = i;
// 线程 C 中执行
i = 2;
```
- 若给出条件 “A 的操作先行于 B 的操作”，则可以确定线程 B 操作结束后，变量 j 的值一定等于 1。
- 若给出条件 “A 的操作先行于 B 的操作，C 出现在 A 和 B 的操作之间，但 C 和 B 没有先行发生关系”，则无法确定 j 的值，此时线程 B 无法保证有序性，也就不具备线程安全性。

Java 内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性。
- 程序次序规则 (Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。

- 管程锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。

- volatile 变量规则 (Volatile Variable Rule)：对一个 volatile 变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。

- 线程启动规则 (Thread Start Rule)：Thread 对象的 start() 方法先行发生于此线程的每一个动作。

- 线程终止规则 (Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.join() 方法结束，Thread.isAlive() 的返回值等作段检测到线程已经终止执行。

- 线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测是否有中断发 Java 内存模型与线程生。

- 对象终结规则 (Finalizer Rule)：一个对象初始化完成（构造方法执行完成) 先行发生于它的 finalize() 方法的开始。

- 传递性 (Transitivity)：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。

NOTE: 一个操作”时间上的先发生“不代表这个操作会是”先行发生“，那如果一个操作”先行发生“是否就能推导出这个操作必定是”时间上的先发生“呢？也是不成立的，一个典型的例子就是指令重排序。所以**时间上的先后顺序与先生发生原则之间基本没有什么关系，所以衡量并发安全问题一切必须以先行发生原则为准**。

## 6. Refer Links

《深入理解 Java 虚拟机》 周志明 著

[全面理解 Java 内存模型](https://blog.csdn.net/suifeng3051/article/details/52611310)

[全面理解 Java 内存模型 (JMM) 及 volatile 关键字](https://blog.csdn.net/javazejian/article/details/72772461)

[你真的了解 volatile 关键字吗？](https://www.jianshu.com/p/7798161d7472)
