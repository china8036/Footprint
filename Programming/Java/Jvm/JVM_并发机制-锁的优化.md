- [	JVM 并发机制 - 锁的优化](#jvm-%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6---%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96)
  - [1. 锁优化操作](#1-%E9%94%81%E4%BC%98%E5%8C%96%E6%93%8D%E4%BD%9C)
    - [1.1. 锁自旋 (Spinning)](#11-%E9%94%81%E8%87%AA%E6%97%8B-spinning)
      - [1.1.1. 自旋锁](#111-%E8%87%AA%E6%97%8B%E9%94%81)
      - [1.1.2. 自适应自旋锁](#112-%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81)
      - [1.1.3. 适用场景](#113-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF)
    - [1.2. 锁消除 (Lock Elimination)](#12-%E9%94%81%E6%B6%88%E9%99%A4-lock-elimination)
    - [1.3. 锁粗化 / 膨胀 (Lock Coarsening)](#13-%E9%94%81%E7%B2%97%E5%8C%96-%E8%86%A8%E8%83%80-lock-coarsening)
  - [2. 新型锁](#2-%E6%96%B0%E5%9E%8B%E9%94%81)
    - [2.1. 轻量级锁 (Lightweight Locking)](#21-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-lightweight-locking)
      - [2.1.1. 加锁过程](#211-%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B)
      - [2.1.2. 解锁过程](#212-%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B)
      - [2.1.3. 适用场景](#213-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF)
    - [2.2. 偏向锁 (Biased Locking)](#22-%E5%81%8F%E5%90%91%E9%94%81-biased-locking)
    - [2.3. 总结](#23-%E6%80%BB%E7%BB%93)
  - [3. Refer Links](#3-refer-links)

# JVM 并发机制 - 锁的优化

从 JDK1.5 到 JDK1.6，HotSpot 虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，这些技术都是为了在线程之间更高效地共享数据，解决竞争问题，从而提高程序的执行效率。

## 1. 锁优化操作

### 1.1. 锁自旋 (Spinning)

#### 1.1.1. 自旋锁

在许多应用上，**共享数据的锁定状态只会持续很短的一段时间，而挂起线程和恢复线程都需要转入内核态中完成，给并发性能带来了很大的压力**。

如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的**自旋锁**。

自旋锁从 JDK1.4.2 开始引入，**在 JDK 1.6 中默认开启**。

性能：自旋等待本身虽避免了线程切换的开销，但还是要占用 CPU 时间的，因此
- 如果锁被占用的时间很短，自旋等待的效果就会非常好；
- 反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。

因此，**自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。**自旋次数的默认值是 10 次，用户可以使用参数`-XX：PreBlockSpin`来更改。

#### 1.1.2. 自适应自旋锁

在 JDK1.6 中引入了自适应自旋锁。**自适应自旋锁的自旋时间不是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定**。
- 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。
- 如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。

#### 1.1.3. 适用场景

互斥量是一种阻塞锁，当某线程无法获取互斥量时，该线程会被直接挂起，不再消耗 CPU 时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程，让其投入运行。

自旋锁 (spin lock) 是一种非阻塞锁，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗 CPU 的时间，不停的试图获取自旋锁。

适用场景：
- 如果是多核处理器：
  - 若预计线程等待锁的时间很短，短到比线程两次上下文切换时间要少的情况下，使用自旋锁是划算的。 
  - 若预计线程等待锁的时间较长，至少比两次线程上下文切换的时间要长，建议使用互斥量。 

- 如果是单核处理器：
  - 一般建议不要使用自旋锁。
  
    单核处理器在同一时间只有一个线程是处在运行状态，如果运行线程发现无法获取锁，只能等待解锁，但因为自身不挂起，所以那个获取到锁的线程没有办法进入运行状态，只能等到运行线程把操作系统分给它的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。 

### 1.2. 锁消除 (Lock Elimination)

锁消除指的是 JVM 即时编译器在运行时，对一些代码上要求同步但实际被检测到不可能存在共享数据竞争的锁进行自动消除的锁优化技术。

锁消除的主要判断依据来源于逃逸分析的数据支持。**如果判断在一段代码中，堆上的所有数据都不会逃逸出去被其它线程访问到，那么这些数据就相当于栈中的线程私有数据，就可以判定不可能存在共享数据竞争，同步加锁自然无须进行**。

实际上，有许多同步措施并不是程序员设置的，而是由 Javac 编译器自动添加的。

例：
```Java
public String concatString(String s1，String s2，String s3) {
    return s1 + s2 + s3;
}
```
javac 编译器会将上边的代码转化为：
```java
public String concatString(String s1，String s2，String s3) {
    StringBuffer sb = new StringBuffer()；
    sb.append(s1)；
    sb.append(s2)；
    sb.append(s3)；
    return sb.toString()；
}
```
其中，每个 StringBuffer.append() 方法中都有一个同步块，锁就是 StringBuffer 实例对象。一旦 JVM 检测到变量 sb 的动态作用域被限制在 concatString() 方法内部，引用永远不会逃逸，就会在即时编译中，消除所有的同步直接执行。

### 1.3. 锁粗化 / 膨胀 (Lock Coarsening)

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。

但是某些情况下，如果系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那么即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

当 JVM 检测到有系列的连续操作都堆同一个对象加锁，将会自动把加锁同步的范围扩展（粗化）到整个操作序列的外部，从而减少同步的次数和开销。

例：
```java
public String concatString(String s1，String s2，String s3) {
    StringBuffer sb=new StringBuffer()；
    sb.append(s1)；
    sb.append(s2)；
    sb.append(s3)；
    return sb.toString()；
}
```
上述代码中，JVM 会将同步扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。

## 2. 新型锁

### 2.1. 轻量级锁 (Lightweight Locking)

- 重量级锁
  
  **synchronized 关键字同步是通过对象内部的一个叫做监视器锁（monitor）来实现的，而监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的**。操作系统实现线程之间的切换需要从用户态转换到核心态，状态之间的转换需要相对比较长的时间，成本非常高。因此**，这种依赖于操作系统 Mutex Lock 所实现的锁称为重量级锁**。

- 轻量级锁

  为了减少获得锁和释放锁所带来的性能消耗，提高性能，**在 JDK1.6 中引入了一种新型锁机制：轻量级锁**。

  轻量级锁并不是用来代替重量级锁的，它的本意是**在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗**。

#### 2.1.1. 加锁过程

在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word）。然后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针。

- 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位（Mark Word 的最后 2bit）将转变为“00”，即表示此对象处于轻量级锁定状态。

- 如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。**如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态**。

#### 2.1.2. 解锁过程

轻量级锁的解锁过程也是通过 CAS 操作来进行的，如果对象的 Mark Word 仍然指向着线程的锁记录，那就用 CAS 操作把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来。
- 如果替换成功，整个同步过程就完成了。
- 如果替换失败（锁的状态值发生了变化），说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。

#### 2.1.3. 适用场景

根据经验“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”：
- **如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销，因此在没有竞争的情况下，轻量级锁优化了同步的性能。**
- **如果存在锁竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。**

### 2.2. 偏向锁 (Biased Locking)

偏向锁也是 JDK1.6 引入的用于锁优化的新型锁，它的目的是**在轻量级锁的基础上，消除数据在无竞争情况下的同步原语，从而进一步提高程序的运行性能。**

偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。**如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了。**

- 处理过程
  
  当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如 Locking、Unlocking 及对 Mark Word 的 Update 等）。

  **当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束**。根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就如轻量级锁那样执行。

偏向锁、轻量级锁的状态转化及对象 Mark Word 的关系如图：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/31/9ff4650d3bb4fabdff3c78cde27412c2.jpg)

偏向锁可以提高**带有同步但无竞争**的程序性能，但它同样是一个带有效益权衡（Trade Off）性质的优化。如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题分析的前提下，可使用参数`-XX：-UseBiasedLocking` 来禁用偏向锁（**JDK 1.6 中默认是开启偏向锁和轻量级锁的**）。

### 2.3. 总结

**从 JDK1.6 开始，锁的类型总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁**。随着锁的竞争情况增强，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。但**锁的升级是单向的，也就是说不会出现锁的降级**。

轻量级锁和偏向锁是对重量级锁的不同层次的优化，但在不合适的场景下，反而会降低程序的运行效率。因此需要具体问题具体分析，在新型锁不适用的时候可以使用参数`-XX：-UseBiasedLocking` 来禁用新型锁的优化，禁用轻量级锁和偏向锁。

| 锁    | 优点                                | 缺点                       | 适用场景               |
| ---- | --------------------------------- | ------------------------ | ------------------ |
| 偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 | 适用于只有一个线程访问同步块的场景。 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度。             | 如果始终得不到锁竞争的线程使用自旋会消耗 CPU。 | 追求响应时间。同步块执行速度非常快。 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗 CPU。                | 线程阻塞，响应时间缓慢。             | 追求吞吐量。同步块执行的速度较长。  |

## 3. Refer Links

《深入理解 Java 虚拟机》 周志明 著

[JVM——锁优化](https://blog.csdn.net/qqqqq1993qqqqq/article/details/76467995)

[Java 并发编程：Synchronized 底层优化（偏向锁、轻量级锁）](https://www.cnblogs.com/paddix/p/5405678.html)