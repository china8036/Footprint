- [Java 本地接口 (Java Native Interface)](#java-%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3-java-native-interface)
  - [1. 基本概念](#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [1.1. 使用目的](#11-%E4%BD%BF%E7%94%A8%E7%9B%AE%E7%9A%84)
    - [1.2. native 关键字](#12-native-%E5%85%B3%E9%94%AE%E5%AD%97)
    - [1.3. 加载过程](#13-%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B)
  - [2. JNI 开发](#2-jni-%E5%BC%80%E5%8F%91)
    - [2.1. 限制](#21-%E9%99%90%E5%88%B6)
    - [2.2. 步骤](#22-%E6%AD%A5%E9%AA%A4)
    - [2.3. 实例](#23-%E5%AE%9E%E4%BE%8B)
  - [3. Refer Links](#3-refer-links)

# Java 本地接口 (Java Native Interface)

## 1. 基本概念

Java 本地接口，即 JNI (Java Native Interface)，是一种编程框架，使得 Java 虚拟机中的 Java 程序可以调用本地应用 / 或库，也可以被其他程序调用。本地程序一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序。

### 1.1. 使用目的

java 使用起来非常方便，然而有些层次的任务用 java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。

- 与 java 环境外交互：

  有时 java 应用需要与 java 外面的环境交互。这是本地方法存在的主要原因，你可以想想 java 需要与一些底层系统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解 java 应用之外的繁琐的细节。

- 与操作系统交互：

  JVM 支持着 java 语言本身和运行时库，它是 java 程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath 在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用 java 实现了 jre 的与底层系统的交互，甚至 JVM 的一些部分就是用 C 写的，还有，如果我们要使用一些 java 语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。

- Sun's Java
  
  Sun 的解释器是用 C 实现的，这使得它能像一些普通的 C 一样与外部交互。jre 大部分是用 java 实现的，它也通过一些本地方法与外界交互。例如：类 java.lang.Thread 的 setPriority() 方法是用 java 实现的，但是它实现调用的是该类里的本地方法 setPriority0()。这个本地方法是用 C 实现的，并被植入 JVM 内部，在 Windows95 的平台上，这个本地方法最终将调用 Win32 SetPriority() API。这是一个本地方法的具体实现由 JVM 直接提供，更多的情况是本地方法由外部的动态链接库（external dynamiclink library）提供，然后被 JVM 调用。
  
### 1.2. native 关键字

使用 native 关键字说明这个方法是原生函数，也就是这个方法是用 C/C++ 语言实现的，并且被编译成了 DLL，由 java 去调用。 这些函数的实现体在 DLL 中，JDK 的源代码中并不包含。对于不同的平台它们也是不同的。这也是 java 的底层机制，实际上 java 就是在不同的平台上调用不同的 native 方法实现对操作系统的访问的。

java 是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而 java 要实现对底层的控制，就需要一些其他语言的帮助，这个就是 native 的作用了。

JNI 框架允许 Native 方法调用 Java 对象，就像 Java 程序访问 Native 对象一样方便。Native 方法可以创建 Java 对象，读取这些对象，并调用 Java 对象执行某些方法。当然 Native 方法也可以读取由 Java 程序自身创建的对象，并调用这些对象的方法。

### 1.3. 加载过程

JVM 是怎样加载 Native Method 的？

我们知道，当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会回载一次。在这个被加载的字节码的入口维持着一个该类所有方法描述符的 list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public 之类）等等。

如果一个方法描述符内有 native，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些 DLL 文件内，但是它们会被操作系统加载到 java 程序的地址空间。当一个带有本地方法的类被加载时，其相关的 DLL 并未被加载，因此指向方法实现的指针并不会被设置。当本地方法被调用之前，这些 DLL 才会被加载，这是通过调用 java.system.loadLibrary() 实现的。

那么，JVM 是通过什么方式，能正确的找到动态库中 C/C++ 实现的那个 native 函数呢？

JVM 查找 native 方法有两种方式：
- 按照 JNI 规范的命名规则。
- 调用 JNI 提供的 RegisterNatives 函数，将本地函数注册到 JVM 中。

## 2. JNI 开发

由于 JVM 规范中的一部分，因此可以将我们写的 JNI 程序在任何实现了 JNI 规范的 JVM 中运行。

### 2.1. 限制

开发 JNI 程序会受到系统环境的限制，因为用 C/C++ 语言写出来的代码或模块，编译过程当中要依赖当前操作系统环境所提供的一些库函数，并和本地库链接在一起。而且编译后生成的二进制代码只能在本地操作系统环境下运行，因为不同的操作系统环境，有自己的本地库和 CPU 指令集，而且各个平台对标准 C/C++ 的规范和标准库函数实现方式也有所区别。这就造成使用了 JNI 接口的 JAVA 程序，不再像以前那样自由的跨平台。如果要实现跨平台，就必须将本地代码在不同的操作系统平台下编译出相应的动态库。

### 2.2. 步骤

JNI 开发流程主要分为以下 6 步：
1. 编写声明了 native 方法的 Java 类。
1. 将 Java 源代码编译成 class 字节码文件。
1. 用 `javah -jni` 命令生成 `.h` 头文件（`javah` 是 jdk 自带的一个命令，`-jni` 参数表示将 class 中用 native 声明的函数生成符合 jni 规则的函数）。
1. 为 `.h` 头文件中的函数创建本地代码的实现。
1. 将本地代码编译成动态库（windows：*.dll，linux/unix：*.so，mac os x：*.jnilib）。
1. 拷贝动态库至 java.library.path 本地库搜索目录下，并运行 Java 程序。

### 2.3. 实例

以下实例基于 Windows 系统。

1. 编写带有 native 声明的方法的 java 类：HelloWorld.java
    ```java
    public class HelloWorld {  
        public native void displayHelloWorld();// java native 方法申明  
      
        static {  
            System.loadLibrary("HelloWorldImpl");// 装入动态链接库，"HelloWorldImpl"是要装入的动态链接库名称。  
        }  
      
        public static void main(String[] args) {  
            // TODO Auto-generated method stub  
            HelloWorld helloWorld = new HelloWorld();  
            helloWorld.displayHelloWorld();  
        }  
    }  
    ```

1. 使用 javac 命令编译所编写的 java 类，生成 class 文件
    ```java
    javac HelloWorld.java  
    ```
1. 使用 javah -jni java 类名生成扩展名为 h 的头文件
    ```java
    javah -jni HelloWorld  
    ```
    执行完上述命令以后生成 HelloWorld.h 文件：
    ```cpp
    /* DO NOT EDIT THIS FILE - it is machine generated */
    #include <jni.h>
    /* Header for class HelloWorld */

    #ifndef _Included_HelloWorld
    #define _Included_HelloWorld
    #ifdef __cplusplus
    extern "C" {
    #endif
    /*
    * Class:     HelloWorld
    * Method:    displayHelloWorld
    * Signature: ()V
    */
    JNIEXPORT void JNICALL Java_HelloWorld_displayHelloWorld
      (JNIEnv *, jobject);

    #ifdef __cplusplus
    }
    #endif
    ```
1. 使用 C/C++ 实现本地方法
    
    创建 HelloWorldImpl.cpp:
    ```java
    #include "HelloWorld.h"  
    #include <stdio.h>  
    #include <jni.h>  
    /* 
    * Class:     HelloWorld 
    * Method:    displayHelloWorld 
    * Signature: ()V 
    */  
    JNIEXPORT void JNICALL Java_HelloWorld_displayHelloWorld  
      (JNIEnv *, jobject)  
    {  
        printf("Hello World!\n");  
        return;  
    }  
    ```
1. 将 C/C++ 编写的文件生成动态连接库
    
    将 JAVA_HOME\include\jni.h 和将 JAVA_HOME\include\win32\jni_md.h 这两个文件拷贝到 HelloWorldImpl.cpp 目录下，打开 Visual Studio 命令行，执行：
    ```java
    cl/LD HelloWorldImpl.cpp
    ```
    得到 HelloWorldImpl.dll、HelloWorldImpl.exp、HelloWorldImpl.lib、HelloWorldImpl.obj 共 4 个文件，保留 HelloWorldImpl.dll 文件。

1. 执行 class 得到结果
    ```java
    java HelloWorld  
    ```

## 3. Refer Links

[维基百科：Java 本地接口](https://zh.wikipedia.org/wiki/Java%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3)

[Java native 方法详解](https://blog.csdn.net/wangaiheng/article/details/78350687###;)

[JNI/NDK 开发指南系列文章](https://blog.csdn.net/xyang81/article/details/41759643)

[一起来学习用 JNI 加固你的 Java 代码](https://juejin.im/entry/59bcdbf76fb9a00a5b1a91e9)

[java native方法及JNI实例](https://blog.csdn.net/xw13106209/article/details/6989415)