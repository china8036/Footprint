- [Java IO: Java IO 模型](#java-io--java-io)
  - [1. BIO: 同步阻塞式 IO + 多线程 / 线程池](#1-bio---io)
  - [2. NIO: 同步非阻塞式 IO / IO 多路复用](#2-nio---io---io)
  - [3. AIO: 异步非阻塞 IO](#3-aio---io)
  - [4. 比较](#4)
  - [5. Refer Links](#5-refer-links)

# Java IO: Java IO 模型

I/O 问题是任何编程语言都无法回避的问题，它是整个人机交互的核心问题，很多时候也是程序的性能瓶颈所在。

在 UNIX 中，有 5 种可用的 IO 模型：
- 同步阻塞式 IO (Blocking IO)
- 同步非阻塞式 IO / 轮询 (Non-blocking IO)
- 同步非阻塞式 IO / IO 多路复用 (IO Multiplexing) 
- 异步非阻塞式 IO / 异步 IO (Asynchronous IO) 
- 信号驱动式 IO (Signal Driven IO) 

**Java 在 IO 包中实现了除信号驱动 IO 外的其他四种 IO 模型**，在 I/O 上也一直在做持续的优化。
- Java 中传统的阻塞式输入输出（Blocking I/O， BIO）。
- JDK1.4 引入了同步非阻塞式输入输出 NIO（New I/O 或 Non-blocking I/O），提升了 I/O 的性能。
- JDK7 又在 java.nio 及其子包下提供了全新的 API -- 异步非阻塞式的输入输出（AIO，也称为 NIO2），使得程序的输入输出操作更加高效。

## 1. BIO: 同步阻塞式 IO + 多线程 / 线程池

在最开始的时候，IO 操作都是阻塞式 IO，也就是说当你调用 read 时，如果没有数据收到，那么线程或者进程就会被挂起，直到收到数据。因此，为了实现一个服务器可以支持多个客户端连接，人们想出了 fork/thread 等办法，当一个连接来到的时候，就 fork/thread 一个独立的进程 / 线程去专门接收并且处理这个连接请求。

这样，当服务器需要处理 1000 个连接的的时候，而且只有很少连接忙碌的，那么会需要 1000 个线程或进程来处理 1000 个连接，而 1000 个线程大部分是被阻塞起来的。由于 CPU 的核数或超线程数一般都不大，如 4 个核要跑 1000 个线程，那么每个线程的时间槽非常短，而线程切换非常频繁。这样就存在以下问题：
- 线程是有内存开销的，1 个线程可能需要 512K（或 2M）存放栈，那么 1000 个线程就要 512M（或 2G）内存。
- 线程的切换，或者说上下文切换是有 CPU 开销的，当大量时间花在上下文切换的时候，分配给真正的操作的 CPU 就要少很多。

当然，针对短连接产生的线程切换的开销浪费问题，可以通过线程池的方案来改善。但在大量长连接的场景中，因为线程被连接长期占用，不需要频繁地创建和销毁线程，内存占用问题依旧得不到解决。

BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。

## 2. NIO: 同步非阻塞式 IO / IO 多路复用

Java 从 JDK 1.4 开始支持同步非阻塞式 IO，其实现采用的是 IO 多路复用模型（而不是轮询），服务器通过 NIO 的多路复用器 Selector，用主线程（一个线程或者是 CPU 个数的线程）保持住所有的连接，管理和读取客户端连接的数据，将读取的数据交给后面的线程池处理，线程池处理完业务逻辑后，将结果交给主线程发送响应给客户端，少量的线程就可以处理大量连接的请求。

这样在处理 1000 个连接时，只需要 1 个线程监控就绪状态，对就绪的每个连接开一个线程处理就可以了，这样需要的线程数大大减少，减少了内存开销和上下文切换的 CPU 开销。

NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。

## 3. AIO: 异步非阻塞 IO

Java 从 JDK 1.7 引入 AIO(NIO2.0)，开始支持异步非阻塞 IO，为构建高性能的网络应用提供了一个利器。其底层在 windows 上是通过 IOCP 实现，在 Linux 上通过 epoll 实现 (LinuxAsynchronousChannelProvider.java,UnixAsynchronousServerSocketChannelImpl.java)。客户端的 I/O 请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理。

AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用操作系统参与并发操作，编程比较复杂。

## 4. 比较

|                     | BIO + 多线程 | BIO + 线程池 |     NIO      |     AIO      |
| :-----------------: | :----------: | :----------: | :----------: | :----------: |
| 客户端数目 ：IO 线程 |    1 : 1     |    m : n     |    m : 1     |    m : 0     |
|       IO 模型        |  同步阻塞 IO  |  同步阻塞 IO  | 同步非阻塞 IO | 异步非阻塞 IO |
|       吞吐量        |      低      |      中      |      高      |      高      |
|     编程复杂度      |     简单     |     简单     |   非常复杂   |     复杂     |

另外，I/O 属于底层操作，需要操作系统支持，并发也需要操作系统的支持，所以性能方面不同操作系统差异会比较明显。

## 5. Refer Links

[Java I/O 模型的演进](https://waylau.com/java-io-model-evolution/)

[也谈 IO 模型](http://www.rowkey.me/blog/2016/01/18/io-model/)