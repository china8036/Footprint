- [Java I/O 概述](#java-i-o)
  - [1. 发展历史](#1)
  - [2. 基本概念](#2)
  - [3. 类谱图](#3)
  - [4. 分类](#4)
    - [4.1. 按操作方式分类](#41)
      - [4.1.1. 输入流 & 输出流](#411)
      - [4.1.2. 字节流 & 字符流](#412)
      - [4.1.3. 节点流 & 处理流](#413)
    - [4.2. 按操作对象分类](#42)
      - [4.2.1. 文件操作节点流](#421)
      - [4.2.2. 管道操作节点流](#422)
      - [4.2.3. 数组操作节点流](#423)
      - [4.2.4. 缓冲操作处理流](#424)
      - [4.2.5. 基本数据操作处理流](#425)
      - [4.2.6. 打印操作处理流](#426)
      - [4.2.7. 打印操作处理流](#427)
      - [4.2.8. 对象序列化操作处理流](#428)
      - [4.2.9. 合并操作处理流](#429)
  - [5. 体系设计](#5)
    - [5.1. 设计原则](#51)
    - [5.2. 设计模式](#52)
      - [5.2.1. 装饰器模式](#521)
      - [5.2.2. 适配器模式](#522)
    - [5.3. 设计特点](#53)
      - [5.3.1. 优点](#531)
      - [5.3.2. 缺点](#532)
  - [6. Refer Links](#6-refer-links)

# Java I/O 概述

## 1. 发展历史

I/O 问题是任何编程语言都无法回避的问题，它是整个人机交互的核心问题，很多时候也是程序的性能瓶颈所在。

Java 在 I/O 上也一直在做持续的优化。
- Java 中传统的阻塞式输入输出（Blocking I/O， BIO）。
- JDK1.4 引入了同步非阻塞式输入输出 NIO（New I/O 或 Non-blocking I/O），提升了 I/O 的性能。
- JDK7 又在 java.nio 及其子包下提供了全新的 API -- 异步非阻塞式的输入输出（AIO，也称为 NIO2），使得程序的输入输出操作更加高效。

## 2. 基本概念

在 Java 中，I/O 通过 java.io 包下的类和接口来支持，其中包含了大概将近 80 个类。
- 从操作方式上看，java.io 包主要包括输入、输出两种 IO 流，而每种输入、输出流又可分为字节流和字符流两大类。
- 从操作对象上看，Java.io 包主要涉及文件，网络数据流，内存缓冲等的输入输出操作。

Java 的 IO 流使用装饰器的设计模式，将 IO 流分成底层节点流和上层处理流。其中，节点流用于和底层的物理节点流包装成统一的处理流，从而允许程序使用统一的输入、输出代码来读取不同的物理存储节点的资源。

Java 的 IO 流是实现输入 / 输出的基础，它可以方便地实现数据的输入 / 输出操作，在 Java 中把不同的输入输出源（键盘、文件、网络连接等）抽象表述为“流”。通过流的方式允许 Java 程序使用相同的方式来访问不同的输入输出源。

## 3. 类谱图

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/11/6f4008b30f3cb326d939e005c613ee2d.jpg)

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/11/f7d1564780c2b981c09e1bc17f157e39.jpg)

## 4. 分类

按照不同的分类方式，可以将流分为不同的类型。

### 4.1. 按操作方式分类

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/22/ffa8dec6b6343b7f94fc8228b3f50bcc.jpg)

#### 4.1.1. 输入流 & 输出流

按照流的流向来看，IO 流可分为输入流和输出流：
- 输入流：从内存读出到磁盘，只能从中读取数据，不能向其写入数据，主要由 InputStream 和 Reader 作为基类。
- 输出流：从磁盘读入到内存，只能向其写入数据，不能从中读取数据，主要由 OutputStream 和 Writer 作为基类。

NOTE：这里的输入、输出都是从程序运行所在的内存的角度来划分的。

#### 4.1.2. 字节流 & 字符流

按照流的元素来看，IO 流可分为字节流和字符流。它们的用法几乎完全一样，区别只在于其所操作的数据单元不同：
- 字节流：每次读入或读出的数据单元是 8 位的字节，可以读任何类型数据，主要由 InputStream 和 OutputStream 作为基类。
- 字符流：每次读入或读出的数据单元是 16 位的字符，只能读取字符类型数据，主要由 Reader 和 Writer 作为基类。

#### 4.1.3. 节点流 & 处理流

按照流的角色来看，IO 流可分为节点流和处理流：
- 节点流
  
  节点流可以从 / 向一个特定的 IO 设备（如磁盘、网络）读 / 写数据，也称为低级流。
  
  当使用节点流进行输入输出时，程序直接连接到实际的数据源，和实际的输入输出节点连接。

- 处理流
  
  处理流是对一个已存在的流进行连接或封装，通过封装后的流来实现数据的读 / 写功能，也称为高级流。
  
  当使用处理流进行输入输出时，程序不会直接连接到实际的数据源，没有和实际的输入输出节点连接，这样的好处是只要使用相同的处理流，程序就能够使用完全相同的代码来访问不同的数据源。也因此处理流需要跟节点流配合使用。

  实际上，Java 使用处理流来包装节点流是一种典型的装饰器设计模式，因此处理流也称为包装流。

  处理流模型的设计体现了 Java 输入输出流设计的高度灵活性，处理流的功能主要体现在以下方面：
  - 性能的提高：主要以增加缓冲的方式来提高输入输出的效率。
  - 操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的内容。

- 比较

	通常来说，字节流的功能比字符流的功能强大，因为字节流可以处理所有的二进制文件。但若使用字节流来处理文本文件，则只需要使用合适的方式将这些字节转换成字符，增加了编程的难度。

	因此，**如果进行输出输入的内容是文本内容，则应考虑使用字符流；如果进行输入输出的内容是非文本的二进制内容，则应考虑使用字节流。**

### 4.2. 按操作对象分类

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/22/f0732d58d00f90ac99d4abf929f541d9.jpg)

#### 4.2.1. 文件操作节点流

- FileInputStream（字节输入流）
- FileOutputStream（字节输出流）
- FileReader（字符输入流）
- FileWriter（字符输出流

#### 4.2.2. 管道操作节点流

- PipedInputStream（字节输入流）
- PipedOutStream（字节输出流）
- PipedReader（字符输入流）
- PipedWriter（字符输出流）

#### 4.2.3. 数组操作节点流

- ByteArrayInputStream
- ByteArrayOutputStream
- CharArrayReader
- CharArrayWriter

#### 4.2.4. 缓冲操作处理流

缓冲操作流（处理流）：带缓冲区的处理流，缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率。
- BufferedInputStream
- BufferedOutputStream
- BufferedReader
- BufferedWriter

#### 4.2.5. 基本数据操作处理流

基本数据类型操作流（处理流）：用于操作基本数据类型值。
- DataInputStream
- DataOutputStream

若是我们要输出一个 8 个字节的 long 类型或 4 个字节的 float 类型，那怎么办呢？可以一个字节一个字节输出，也可以把转换成字符串输出，但是这样转换费时间，因此这个数据流就解决了我们输出数据类型的困难。数据流可以直接输出 float 类型或 long 类型，提高了数据读写的效率。

#### 4.2.6. 打印操作处理流

打印控制流（处理流）：一般是打印到控制台，可以进行控制打印的地方。
- PrintStream
- PrintWriter

#### 4.2.7. 打印操作处理流

转换控制流（处理流）
- InputStreamReader：把字节转化成字符
- OutputStreamWriter：把字节转化成字符

#### 4.2.8. 对象序列化操作处理流

对象序列化操作流（处理流）：把封装的对象直接输出，而不是一个个在转换成字符串再输出。
- ObjectInputStream，对象反序列化
- ObjectOutputStream，对象序列化

#### 4.2.9. 合并操作处理流
- SequenceInputStream：可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。

## 5. 体系设计

### 5.1. 设计原则

- 单一职责原则：每一个 IO 类的都具有单独的功能和职责，需要对某种类型的流做修改时，只需要修改具体对应的 IO 流类即可。

- 里氏替换原则：子类完全实现了父类的方法，且有自己的个性，子类覆盖或实现父类的方法时输入参数和返回结果的范围没有变化。

- 接口隔离原则：输入输出流所实现的接口有所不同，而且接口比较细化，接口中的方法少。

- 依赖倒置原则：Java IO 中的各个具体的功能类，都继承或聚合了 InputStream/OutputStream 的抽象类，都共同依赖了抽象，而不是依赖了某个具体的功能的 IO 类。

- 开闭原则：当用户需要新增一种新特征、新方式的 IO 流时，可以直接新增一种类的流，让其继承或聚合 InputStream/OutputStream/FilterInputStream/FilterOutputStream 等类，从而来书写其特有的功能，减少。

- 聚合 / 组合复用原则：就比如 FileInputStream 中对 FileDescriptor 和 FileChannel 的使用，都是采用了聚合的方式，而非继承的方式，从而使类之间的耦合度降低，提高了灵活性。

### 5.2. 设计模式

#### 5.2.1. 装饰器模式

由于 java I/O 库需要很多性能的各种组合，如果这些性能都是用继承来实现，那么每一种组合都需要一个类，这样就会造成大量行重复的类出现。如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是 java I/O 库基本模式。装饰模式的引进，造成灵活性和复杂性的提高。因此在使用 java IO 库时，必须理解 java IO 库是由一些基本的原始流处理器和围绕它们的装饰流处理器所组成的。

以字节输入流为例。InputStream 是需要被装饰的抽象构件，而其下的 FileInputStream、ByteArrayInputStream 等是被装饰的具体构件；FilterInputStream 是装饰器的父类，BufferedInputStream、DataInputStream 则是具体的装饰器类。

#### 5.2.2. 适配器模式

适配器模式是 java IO 库中第二个重要的设计模式。如：StringBufferInputStream 就是一个适配器类。它继承了 InputStream 类型，同时持有一个对 String 类型的引用。这是将 String 对象适配成 InputStream 类型的对象形式的适配器模式。PipedOutputStream 也是一个适配器类。PipedOutputStream 总是和 PipedInputStream 一起使用，它接收一个类型为 PipedInputStream 的输入类型，并将之转换成 OutputStream 类型的输出流，这是一个对象形式的适配器模式应用。

### 5.3. 设计特点

#### 5.3.1. 优点

- 功能全面、强大和灵活，同时还防止了过多的类膨胀
- 符合开闭原则，开发可以通过各种装配能实现各种功能

#### 5.3.2. 缺点

- 复杂难记，API 使用繁琐。如：Jdk1.6 中，从文本文件中读取数据转换为字符串，就得至少 10 行代码。
- IO 流中的绝大多数方法都有 IOException 的检查异常，导致开发人员不得不在各个使用到的地方捕捉或再抛出异常，代码繁琐，不符合当前的主流设计思路。

## 6. Refer Links

[Java IO，硬骨头也能变软](https://zhuanlan.zhihu.com/p/28286559)

[深入分析 Java I/O 的工作机制](https://www.ibm.com/developerworks/cn/java/j-lo-javaio/)

[并发编程网：Java IO 教程](http://ifeve.com/java-io/)

[Java IO 知识整理](http://blinkfox.com/java-io-zhi-shi-zheng-li/)