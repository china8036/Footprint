- [Java 多线程 - 线程安全 - 概述](#java-%E5%A4%9A%E7%BA%BF%E7%A8%8B---%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8---%E6%A6%82%E8%BF%B0)
  - [1. 线程安全的程度](#1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%A8%8B%E5%BA%A6)
    - [1.1. 不可变](#11-%E4%B8%8D%E5%8F%AF%E5%8F%98)
    - [1.2. 绝对线程安全](#12-%E7%BB%9D%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8)
    - [1.3. 相对线程安全](#13-%E7%9B%B8%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8)
    - [1.4. 线程兼容](#14-%E7%BA%BF%E7%A8%8B%E5%85%BC%E5%AE%B9)
    - [1.5. 线程对立](#15-%E7%BA%BF%E7%A8%8B%E5%AF%B9%E7%AB%8B)
  - [2. 线程安全的实现](#2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0)
  - [3. Refer Links](#3-refer-links)

# Java 多线程 - 线程安全 - 概述

Java Concurrency In Practice:
> 当多个线程访问一个对象时，如果不用考虑这些线程在运行环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象时线程安全的。

以上定义要求线程安全的代码本身应封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须多关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。

## 1. 线程安全的程度

按照线程安全的“安全程度”由强至弱来排序，我们可以将 Java 语言中各种操作共享的数据分为以下 5 类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

### 1.1. 不可变

在 JDK1.5（JMM 修补完成）之后，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采用任何线程安全的保障措施。只要一个不可变的对象被正确地构建出来（没有发生 this 引用逃逸的情况），那么其外部的可见状态永远不会改变。“不可变”的线程安全是最简单和最纯粹的。

- 若共享的数据是一个基本数据类型变量，那么只需要在定义时使用 final 关键字修饰即可将其设置为不可变的。
- 若共享的数据是一个对象，那么就需要保证对象的行为不会对其状态产生任何影响。例如，String 是一个典型的不可变对象，每次对对象的操作都会返回一个新的对象，而不会去改变旧的对象，这样可以保证对象的线程安全。
  - 保证对象行为不影响自己状态的途径有很多种，其中最简单的就是把对象中带有状态的变量都声明为 final。
  - Java API 中符合不可变要求的类型有：String、java.lang.Number 的部分子类（如 Long 和 Double 的数值包装类）、BigInteger 和 BigDecimal 等大数据类型。但同为 Number 子类型的原子类 AtomicInteger 和 AtomicLong 则并非不可变的。

### 1.2. 绝对线程安全

绝对的线程安全完全满足 Java Concurrency In Practice 中对线程安全给出的定义，而这往往需要付出甚至不切实际的代价。因此，Java API 中标注自己是线程安全的类，大多数都不是属于绝对线程安全。

例：java.util.Vector 是一个线程安全的容器，其 add()、get()、size() 方法都是被 synchronized 修饰的方法。但在多线程环境中，如果不在方法调用端做额外的同步措施，Vector 的使用仍然是非线程安全的。在一个线程恰好在错误的时间删除了一个元素，导致序号 i 不再可用时，另一个线程再用 i 访问数组就会抛出越界异常。

### 1.3. 相对线程安全

相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

Java 语言中，大部分的线程安全都属于这种类型，例如 Vector，HashTable，Collections 的 synchronizedCollection() 方法包装的集合等。

### 1.4. 线程兼容

线程兼容就是我们绝大多数时候所讲的线程不安全，它是指对象本身并不是线程安全的，但是通过使用同步手段来保证对象在并发环境中可以安全的使用。

Java API 中大部分的类都是属于线程兼容的，如 ArrayList 和 HashMap。

### 1.5. 线程对立

线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生具有多线程的特性，因此这种排斥多线程的代码通常很少会出现，程序员也应尽量避免。

一个线程对立的例子就是 Thread 类的 suspend() 和 resumn() 方法（已被 JDK 声明废弃了）。如果存在两个线程同时持有一个线程对象，一个尝试中断线程，另一个尝试恢复线程，若并发执行此代码，无论低调用是否进行了同步，目标线程都是存在死锁风险的。

常见的线程对立操作还有 System.setIn(), System.setOut(), System.runFinalizersOnExit() 等。

## 2. 线程安全的实现

如何实现线程安全？

造成线程安全问题的主要诱因有两点，一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据。因此为了解决这个问题，我们需要这样一个方案：在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程所使用，这种方案也称为**同步**。

Java 在语言层面和 JVM 中都提供了一系列实现线程安全的同步措施，这些同步措施具体包括：

- 阻塞 / 互斥同步方案（悲观并发策略）
  - 使用 synchronized 关键字
  - 使用 java.util.concurrent 包中的可重入锁 ReentrantLock

- 非阻塞同步方案（乐观并发策略）
  - 使用 CAS 指令操作

- 无同步方案
  - 可重入代码
  - 线程本地存储

## 3. Refer Links