- [Java 多线程 - 线程池 - 概述](#java-%E5%A4%9A%E7%BA%BF%E7%A8%8B---%E7%BA%BF%E7%A8%8B%E6%B1%A0---%E6%A6%82%E8%BF%B0)
  - [1. 前言](#1-%E5%89%8D%E8%A8%80)
  - [2. 基本概念](#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
  - [3. 使用场景](#3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)
  - [4. 组成](#4-%E7%BB%84%E6%88%90)
  - [5. 处理流程](#5-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B)
  - [6. 优缺点](#6-%E4%BC%98%E7%BC%BA%E7%82%B9)
  - [7. 合理使用](#7-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8)
  - [8. Refer Links](#8-refer-links)

# Java 多线程 - 线程池 - 概述

## 1. 前言

如果服务器为每一个请求分配一个线程来进行处理，实现起来非常简便，但是存在以下问题：
- 如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。
- 随着并发的请求数量增加，服务器是如何处理请求的？比如一开始一个请求一个线程；线程满了之后放任务队列。当并发量多到千万甚至上亿级别，又该如何处理？

这就应该使用线程池了，线程池为线程生命周期的开销和资源不足问题提供了解决方案。

## 2. 基本概念

线程池会在系统启动时即创建大量的空闲进程，当向线程池提交一个执行任务时，线程池会启动一个线程来执行该任务；且执行完毕后，该线程不会死亡，而是再次返回到线程池中成为空闲状态，等待下一个任务。

同时，线程池的最大线程数参数可以对系统中的并发线程数进行限制，避免并发量过大时系统崩溃。如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。

## 3. 使用场景

- 若程序中创建了大量生命周期很短的线程，会造成很多用于线程创建和销毁的开销浪费。这种情况下使用线程池以减少线程重复创建和销毁的无用开销，通过对多个任务重用线程，将线程创建的开销分摊到多个任务上。

- 当需要创建的线程数量过大时，甚至会导致 JVM 崩溃。这种情况下使用线程池可减少并发线程的数目，使用固定数目的线程池，限制并发总数。

## 4. 组成

一般的线程池主要分为以下 4 个组成部分：
- 线程池管理器：用于创建并管理线程池，决定由哪个线程来执行任务。
- 线程队列：线程池中的线程。
- 任务接口：每个任务必须实现的接口，用于工作线程调度其运行。
- 任务队列：用于存放待处理的任务，提供一种缓冲机制。

## 5. 处理流程

当提交一个新任务到线程池时，线程池的处理流程如下：
1. 首先线程池判断基本线程池是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程。
1. 其次线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。
1. 最后线程池判断整个线程池是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。

## 6. 优缺点

优点：
- 降低资源消耗。
  
  通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

- 提高响应速度。
  
  当任务到达时，任务可以不需要等到线程创建就能立即执行。

- 提高线程的可管理性。

  线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控，但是要做到合理的利用线程池，必须对其原理了如指掌。

缺点：

线程池的使用也是存在风险的，比如一样存在和其他多线程程序存在的并发风险，如同步错误、死锁，还有线程池特有的风险，如资源不足、线程泄露。
- 线程泄露是指当线程池中调用一个线程去执行一项任务的时候，任务完成之后线程却没有返回线程池，就会发生线程泄露。比如在执行任务时抛出 RuntimeException 或者一个 Error，如果没有 catch 到，线程池线程数量永久减 1。当这样的情况发生次数足够多时，线程池就没有线程来处理任务了。

## 7. 合理使用

要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：
- 任务的性质：CPU 密集型任务，IO 密集型任务和混合型任务。 
- 任务的优先级：高，中和低。 
- 任务的执行时间：长，中和短。 
- 任务的依赖性：是否依赖其他系统资源，如数据库连接。

任务性质不同的任务可以用不同规模的线程池分开处理：
- CPU 密集型任务配置尽可能少的线程数量，如配置 Ncpu+1 个线程的线程池。
- IO 密集型任务由于需要等待 IO 操作，线程并不是一直在执行任务，则配置尽可能多的线程，如 2*Ncpu。
- 混合型的任务，如果可以拆分，则将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。
可以通过 `Runtime.getRuntime().availableProcessors()` 方法获得当前设备的 CPU 个数。

除此之外：
- 优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。
- 执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。
- 依赖数据库连接池的任务，因为线程提交 SQL 后需要等待数据库返回结果，如果等待的时间越长 CPU 空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用 CPU。
- 建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。如果使用无界队列，极端情况下可能会撑满内存，导致整个系统不可用。

## 8. Refer Links

[深入理解 Java 线程池：ThreadPoolExecutor](https://www.jianshu.com/p/d2729853c4da)

[【从 0 到 1 学习 Java 线程池】Java 线程池的简介以及使用](http://blog.luoyuanhang.com/2017/02/26/thread-pool-in-java-1/)

[聊聊并发（三）——JAVA 线程池的分析和使用](http://www.infoq.com/cn/articles/java-threadPool/)