- [JVM 内存分配](#jvm-内存分配)
  - [1. 对象优先在 Eden 区分配](#1-对象优先在-eden-区分配)
  - [2. 大对象直接进入老年代](#2-大对象直接进入老年代)
  - [3. 长期存活的对象将进入老年代](#3-长期存活的对象将进入老年代)
  - [4. 动态对象年龄判定](#4-动态对象年龄判定)
  - [5. 空间分配担保](#5-空间分配担保)
  - [6. Refer Links](#6-refer-links)

# JVM 内存分配

对象的内存分配，主要就是在堆上分配（但也可能经过 JIT 编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。

以下是几条最普遍的内存分配规则。

## 1. 对象优先在 Eden 区分配

大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够的空间进行分配时，虚拟机将发起一次 Minor GC。

虚拟机提供了 `-XX:+PrintGCDetails` 这个收集器日志参数，高数虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。在实际应用中，内存回收日志一般是打印到文件后通过日志工具进行分析。

## 2. 大对象直接进入老年代

所谓大对象就是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串及数组（如 byte[] 数组就是典型的大对象）。

大对象对虚拟机的内存分配来说就是一个坏消息（比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。

虚拟机提供了一个 `-XX:PretenureSizeThreshold` 参数，令大于这个设置值的对象直接在老年代分配，从而避免在 Eden 区及 2 各 Survivor 区之间发生大量的内存复制算法的内存收集操作。

## 3. 长期存活的对象将进入老年代

虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对象应当放在新生代，哪些对象应放在老年代中。

为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在 Survivor 区中每熬过一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

## 4. 动态对象年龄判定

为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。

## 5. 空间分配担保

在发生 Minor GC 前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间：
- 如果大于，那么 Minor GC 可以确保是安全的。
- 如果小于，虚拟机会查看 HandlePromotionFailure 设置值是否允许担任失败：
  - 如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小：
    - 如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的。
    - 如果小于，进行一次 Full GC。
  - 如果不允许，也要改为进行一次 Full GC。

新生代使用复制收集算法，但为了内存利用率，只使用其中一个 Survivor 空间来作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况时（最极端就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，让 Survivor 无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行 Full GC 来让老年代腾出更多空间。

取平均值进行比较其实仍然是一种动态概率的手段，也就是说如果某次 Minor GC 存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了 HandlePromotionFailure 失败，那就只好在失败后重新发起一次 Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将 HandlePromotionFailure 开关打开，避免 Full GC 过于频繁。

JDK 6u24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或历次晋升的平均大小就会进行 Minor GC，否则就进行 Full GC。

## 6. Refer Links