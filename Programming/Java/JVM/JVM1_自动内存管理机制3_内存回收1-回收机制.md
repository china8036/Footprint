- [JVM 内存回收：回收机制](#jvm-内存回收回收机制)
  - [1. 是否回收](#1-是否回收)
    - [1.1. 堆对象判定](#11-堆对象判定)
      - [1.1.1. 存活判定算法](#111-存活判定算法)
        - [1.1.1.1. 引用计数算法 (Reference Counting)](#1111-引用计数算法-reference-counting)
        - [1.1.1.2. 可达性分析算法 (Reachability Analysis)](#1112-可达性分析算法-reachability-analysis)
      - [1.1.2. 二次标记过程](#112-二次标记过程)
    - [1.2. 方法区判定](#12-方法区判定)
      - [1.2.1. 废弃常量](#121-废弃常量)
      - [1.2.2. 无用类](#122-无用类)
  - [2. 怎么回收](#2-怎么回收)
    - [2.1. 垃圾收集算法](#21-垃圾收集算法)
      - [2.1.1. 标记 - 清除算法 (Mark-Sweep GC)](#211-标记---清除算法-mark-sweep-gc)
      - [2.1.2. 复制算法 (Copying GC)](#212-复制算法-copying-gc)
      - [2.1.3. 标记 - 整理算法 (Mark-Compact GC)](#213-标记---整理算法-mark-compact-gc)
    - [2.2. 分代收集机制 (Generational Collecting)](#22-分代收集机制-generational-collecting)
      - [2.2.1. 新生代 GC (Young GC / Minor GC)](#221-新生代-gc-young-gc--minor-gc)
      - [2.2.2. 年代转换](#222-年代转换)
      - [2.2.3. 老年代 GC (Major GC/Full GC)](#223-老年代-gc-major-gcfull-gc)
      - [2.2.4. 空间分配担保](#224-空间分配担保)
  - [4. Refer Links](#4-refer-links)

# JVM 内存回收：回收机制

1960 年诞生于 MIT 的 Lisp 是第一门真正使用内存动态分配和垃圾收集技术的语言。经过半个多世纪的发展，GC 技术已经相当成熟，进行了自动化的时代。但当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，我们就需要对这些自动化的技术进行必要的监控和调节。

Java 内存运行时区域中，程序计数器、JVM 栈和本地方法栈随着线程的生命周期创建和销毁，因此这 3 个区域的内存分配和回收都具有确定性，在这几个区域内无需过多考虑 GC 的问题，因为方法结束或线程结束时，内存自然就随着被回收了。而**Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序运行期间才能知道会创建哪些对象，因此这部分内存的分配和回收都是动态的，也是垃圾收集机制所关注的内存区域，常说的内存分配和回收指的都是这部分内存**。

由于 JVM 采用分代垃圾收集算法，因此一般将 Java 堆分为**新生代和老年代**。其中，新生代相对老年代需要更频繁的清理，把它们区分开来，配用不同的清理策略，有助于提高效率。

GC 需要解决 3 个主要的问题：
- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

## 1. 是否回收

### 1.1. 堆对象判定

在 Java 堆中存放着**几乎**所有的对象实例，因此垃圾收集器在对堆进行 GC 前，第一件事情就是要确定这些对象中哪些还“存活”着，哪些是已经不可能再被任何途径使用的对象。

#### 1.1.1. 存活判定算法

##### 1.1.1.1. 引用计数算法 (Reference Counting)

引用计数算法 (Reference Counting) 是早期的垃圾收集策略。

- 引用的概念

  在 JDK1.2 之前，Java 中的引用定义很很纯粹：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

  在 JDK1.2 之后，Java 对引用的概念进行了补充，将引用分为以下 4 种（引用强度依次逐渐减弱）：
  - 强引用 (Stong Reference): 指程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收被引用的对象。
  - 软引用 (Soft Reference): 用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回事还是没有足够的内存，才会抛出内存溢出异常。
  - 弱引用 (Weak Reference): 也是用于描述非必需对象的，但其强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收弱引用关联的对象。
  - 虚引用 (Phantom Refenrece): 是最弱的一种引用关系。一个对象是否有虚引用完全不会对对象的生存时间造成影响，也无法通过虚引用来取得对象实例。它的唯一目的就是希望能在这个对象别回收时收到一个系统通知。在 JDK1.2 之后，提供了 PhantomReference 来实现虚引用。

- 基本思想

  该算法在一个对象被创建时，为该对象分配一个引用计数器：
  - 每当有一个地方引用它时，引用计数加 1。
  - 每当一个对象的引用失效（超过了生存期或者被设置一个新的值）时，引用计数减 1。任何时刻计数器为 0 的对象就是不可能再被使用的，可以被当作垃圾收集。
  - 当一个对象被垃圾收集的时候，它引用的任何对象计数值减 1。在这种方法中，一个对象被垃圾收集后可能导致后续其他对象的垃圾收集行动。

- 优缺点

  - 优点：算法实现简单，判断效率高。如微软的 COM 技术、使用 ActionScript3 的 FlashPlayer、python 语言和在游戏脚本领域被广泛使用的 Squirrel 中都使用了该算法进行内存管理。
  - 缺点：
    - 很难解决**对象之间的相互循环引用问题，也因为这个原因 JVM 未使用此算法进行内存管理**。例如，A 对象有一个对 B 对象的引用，B 对象又反过来有一个 A 对象的引用，除此之外这两个对象无任何其它引用，但引用计数都不会为 0，因此都无法被回收。
    - 每次引用计数的增加或者减少也带来额外开销。

##### 1.1.1.2. 可达性分析算法 (Reachability Analysis)

**可达性分析算法 (Reachability Analysis) 也称为根搜索算法 (Roots Tracting)，是目前主流的商用程序语言（如 Java、C#、甚至古老的 Lisp）主流的对象存活判定实现算法，解决了对象循环引用的问题**。

- 基本思想

  通过一系列的名为“GC Roots”对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 (Reference Chain), 当一个对象到 GC Roots 没有任何引用链相连（即从 GC Roots 到这个对象不可达）时，则此对象就是不可用的。实际上，**这个过程是一个典型的图搜索操作，可以使用深度优先搜索 (DFS) 或广度优先搜索 (BFS) 来实现**。

  例：

  ![image](http://img.cdn.firejq.com/jpg/2018/11/14/48674a5fa23e5baf1bf5483a5cdfc9ab.jpg)

  其中，对象 Object5、Object6、Object7 虽然互相关联，但它们到 GC Roots 是不可达的，因此都会被判定为可回收的对象。

  在 Java 语言中，可作为 GC Roots 的对象包括以下几种：
  - 虚拟机栈（栈帧中的局地变量表) 中的引用的对象。

    主要指 main 方法中产生的储存在 JVM 栈中的对对象的引用。Java 对象都存在 Heap 区，对对象的引用都存在 Stack 区。GC 会去找当前 Stack 区里还留有的 main 方法产生的引用。因为栈里的引用的生命周期都和他在代码里的作用域挂钩，比如说出了括号，括号里声明的引用就会从 stack 里擦除，跟着的一大串对象就再也不可能被标记到了。

  - 方法区中的类静态属性引用的对象和常量引用的对象。

    静态方法和变量不产生实例，直接由类引用。Java 的类由 java.lang.ClassLoader 类加载器加载，类的数据都不在逻辑堆，而是存在永生代，也就是 Method Area 方法区，现在叫 Metaspace。类本身一旦被 GC 清除，它的所有静态变量也就跟着被释放了。

  - 本地方法栈中 JNI 引用的对象。

    JNI 是支持其他编程语言的本机码和 Java 字节码互相调用的程序。除了 Java 进程内部的调用，JVM 还需要知道一个实例是否被外部本机代码所调用，JNI 引用就列举了当前的外部调用。

- 存在问题

  - 在可达性分析从 GC Roots 节点找引用链这个操作时，可作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，而现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里边的引用，那么必然会消耗很多时间。

  - 由于可达性分析必须在一个能保证一致性的快照中进行，导致 GC 进行时必须停顿所有 Java 执行线程 (Stop The World)。即使是在号称几乎不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。

- HotSpot 实现

  - 如何枚举根节点？OopMap

    在 HotSpot 的可达性分析实现中，**使用一组 OopMap 的数据结构，在类加载完成时，将对象内什么偏移量是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用**。这样，GC 在扫描时就可以直接得知这些信息了。

  - 如何进入 GC？
    - 安全点 (Safepoint)

      OopMap 内容变化的指令非常多，如果为每一条指令都声称他对应的 OopMap，那将会需要大量的额外空间，这样 GC 的空间成本将会变得非常高。因此，实际上 GC 只在特定的位置记录这些信息，这些位置称为“安全点”，即程序执行时并非在所有地方都能停顿下来 GC，只有在到达安全点时才能暂停。

      由于 safepoint 的选定既不能太少以至于让 GC 等待时间过长，又不能过多以至于过分增大运行时的负荷，因此**安全点的选定基本上是以程序是否具有让程序长时间执行的特征为标准进行选定的**，“长时间执行”的最明显特征就是指令序列复用，如方法调用、循环跳转、异常跳转等。

      **现今几乎所有的虚拟机都采用主动式中断来使程序停顿下来以进行 GC**：当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志被设置时就自己中断挂起。轮询标志与安全点的位置是重合的，另外再加上创建对象需要分配内存的地方。

    - 安全区域 (Safe Region)

      若线程处于 Sleep 或 Blocked 状态，程序没有被分配 CPU 时间，因此线程就无法响应 JVM 的中断请求，“走”到安全点去挂起。对于这种情况，就需要安全区域来解决。安全区域是指在一段代码片段中，引用关系不会发生变化，在这个区域中的任意地方开始 GC 都是安全的。因此也可以将安全区域看作是扩展的安全点。

      当线程执行到安全区域的代码时，首先标识自己已经进入了安全区域，这样之后 JVM 发起 GC 时，就不用管这个线程了。在线程要离开安全区域时，它要检查系统是否已经完成了根结点枚举（或整个 GC 过程），如果完成了，那么线程继续执行；否则它就必须等待直到可以安全离开安全区域的信号为止。

#### 1.1.2. 二次标记过程

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。**也就是说，要真正宣告一个对象死亡，至少要经历两次标记过程**。

![image](http://img.cdn.firejq.com/jpg/2018/11/15/bce4cae1de5c91be0decb7b2652eabb5.jpg)

- 第一次标记

  若 JVM 在对对象进行存活判定后将对象判定为可回收对象（如对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链），那么该对象将会被第一次标记并**筛选**此对象是否有必要执行 finalize() 方法：
  - 若对象没有覆盖 finalize() 方法，或者 finzlize() 方法已经被虚拟机调用过，那么 JVM 将这两种情况都判定为“没有必要执行” finalize() 方法，对象直接在第二次标记时被回收。
  - 若对象覆盖了 finalize() 方法，且 finzlize() 方法没有被虚拟机调用过，那么 JVM 将这种情况判定为“有必要执行” finalize() 方法，对象将会被放置在一个名为 **F-Queue** 的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的 Finalizer 线程去执行。

- 第二次标记

  对于在第一次标记的筛选中被判定为有必要执行 finalize 方法的对象，GC 将在其执行完 finalize() 方法后进行第二次小规模的标记：
  - 如果对象在 finalize() 中重新与引用链上的任何的一个对象建立关联（如把自己赋值给某个类变量或对象的成员变量），那么在第二次标记时它将移除出“即将回收”的集合。
  - 如果对象在执行完 finalize() 方法后的第二次标记中还没逃脱，那基本上它就真的被回收了。

NOTE
- finalize() 方法是对象脱逃死亡命运的最后一次机会，且这种自救的机会只有一次，因为**一个对象的 finalize() 方法最多只能被系统自动调用一次**。
- 虚拟机会触发 finalize() 方法，但并不承诺会等待它运行结束。因为如果一个对象 finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。
- 不同于 C/C++ 中的析构函数，实际上 finalize() 方法是 Java 刚诞生时为使 C/C++ 程序员更容易接受它所做出的一个妥协。它运行代价高昂、不确定性大、无法保证各个对象的调用顺序。因此，**建议开发者可以完全忘掉 Java 语言中这个方法的存在**。

### 1.2. 方法区判定

**按照分代垃圾收集算法的划分，JVM 运行时内存的方法区被划分为永生代 (Permanent Generation)。但从 JDK 1.8 开始，取消了“永生代”这个说法**，原先永生代中大部分内容比如类的元信息会被放入本地内存（元数据区，Metaspace），而类的静态变量和内部字符串被分离出放入到逻辑堆中。

Java 虚拟机规范中不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低（在新生代中进行一次 GC 可回收 70%~95% 的空间，而永久代的 GC 效率远低于此）。

方法区中的 GC 主要回收两部分内容：
- 废弃常量
- 无用类

#### 1.2.1. 废弃常量

判断常量是否废弃与判断堆中对象十分相似。例如，若常量池中存在字符串“abc”，而系统中并没有任何 String 对象的值为“abc”的，也就是没有任何对象引用它，那么它就可以被回收了。

#### 1.2.2. 无用类

判断类是否无用的条件则苛刻许多，类需要同时满足以下 3 个条件才能算是“无用的类”：
- 该类的所有对象实例已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类的 `java.lang.Class` 对象没有在任何地方被引用，无法使用反射来访问该类的方法。

满足了以上条件后，是否对类进行回收，还取决于 HotSpot 虚拟机的参数配置而不是一定会回收。

在大量使用反射、动态代理、Cglib 等 ByteCode 框架、动态生成 JSP 以及 OSGI 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保存永久代不会溢出。

## 2. 怎么回收

### 2.1. 垃圾收集算法

由于垃圾收集算法的实现涉及大量的程序细节，且各个平台的 JVM 操作内存的方法又各不相同，因此以下只对几种常见的 GC 算法进行阐述。

#### 2.1.1. 标记 - 清除算法 (Mark-Sweep GC)

标记 - 清除算法 (Mark-Sweep) 是最基础的收集算法，其它算法都是基于这种思路并对其不足进行改进而得到的。

标记 - 清除算法将垃圾回收分为两个阶段：
- 标记阶段：首先标记出所有需要回收的对象。
- 清除阶段：标记完成后，统一回收被标记的对象。

![image](http://img.cdn.firejq.com/jpg/2018/11/15/fea3f18a98a1374aa4dc7913a88d8a8e.jpg)

存在的主要问题：
- 效率问题：标记和清除两个过程的效率都不高。
- 空间问题：标记清除之后会产生大量的不连续的**内存碎片**，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作。

#### 2.1.2. 复制算法 (Copying GC)

复制算法 (Copying GC) 是为解决标记 - 清除算法的效率问题而出现的，最早由 Marvin Minsky 提出，**现在的商业虚拟机都采用这种收集算法来回收新生代**。

复制算法 (Copying GC) 将现有的可用内存空间按容量分为大小相等的 2 块，一个叫分配空间（Allocation Space），一个是幸存者空间（Survivor Space）。每次只使用其中一块，当其中一块用完了，就将还存活的对象复制到另外一块上，然后再把已使用过的内存空间一次清理掉。创建新的对象的时候都是在分配空间里创建，在 GC 的时候，把分配空间里的活动对象复制到 Survivor Space，把原来的分配空间全部清空。然后把这两个空间交换，就是说 Allocation Space 变成下一轮的 Survivor Space，现在的 Survivor Space 变成 Allocation Space。

![image](http://img.cdn.firejq.com/jpg/2018/11/17/9940ed807cf68252d7ed726eb4b09629.jpg)

- 例：

  ![image](http://img.cdn.firejq.com/jpg/2018/11/25/fcdae0765c49e6ff968c742b48a712d0.jpg)

  此时，from 空间已经满了，A 对象存活，A 又引用了 C 和 D，所以 C 和 D 也是活跃的。已经没有任何地方引用 B 对象了，那么 B 就是垃圾了。这时候，如果想再创建一个新的对象就不行了，这时就会执行 GC 算法，将 A，C，D 都拷贝到新的空间中去。

  ![image](http://img.cdn.firejq.com/jpg/2018/11/25/f0908b2cba083e433d04d2b1ad16957b.jpg)

  然后把原来的空间全部清空。这样，就完成了一次垃圾回收。

- 优点：
  - 由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。
  - 只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

- 缺点：
  - 内存减少为原来的一半，太浪费了。
  - 对象存活率较高的时候就要执行较多的复制操作，效率变低。
  - 如果不使用 50% 的对分策略，老年代需要考虑的空间担保策略。

- 实现改进：

  ![image](http://img.cdn.firejq.com/jpg/2018/11/17/5253029a4dc928666f34bf6fc092780e.jpg)

  - IBM 公司专门研究表明，新生代中的对象 98% 都是“朝生夕死”的，所以并不需要根据 1:1 划分内存空间，而是将内存划分为一块较大的 Eden Space 和两块较小的 Survivor Space，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性地复制到另外一块 Survivor 空间中，最后清洗掉 Eden 和刚才用过的 Survivor 空间。
  - 当 Survivor 空间不够用时，需要依赖其它内存（老生代）进行分配担保 (Handle Promotion)，即如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老生代。
  - 在 HotSpot 的实现中一开始就使用了这种改进的布局，**默认 Eden 和 Survivor 的大小比例是 8:1**。

#### 2.1.3. 标记 - 整理算法 (Mark-Compact GC)

由于复制算法的缺点，及老年代存活率高、没有额外内存对其进行空间担保的特点，**老年代一般不能使用复制算法。根据老生代的特点，一般使用的是标记 - 整理算法 (Mark-Compact)**。

标记 - 整理算法 (Mark-Compact) 的标记过程和标记 - 清除算法一样，会标记出所有需要回收的对象，但后续步骤不是直接对可回收对象进行清理，而是让存活的对象向内存的一端移动，然后直接清理掉边界以外的内存。

![image](http://img.cdn.firejq.com/jpg/2018/11/17/284adbbd2ed8ebb9b4b3b51128101b34.jpg)

### 2.2. 分代收集机制 (Generational Collecting)

**当前的商业虚拟机的垃圾收集都采用分代收集机制 (Generational Collecting)。**

分代收集机制 (Generational Collecting) 指的是**根据对象存活周期的不同把 Java 堆进行划分，从而可以根据各个年代的特点采用最适当的收集算法以提高 GC 效率**。

根据分代收集机制，将 Java 堆细分为：

![image](http://img.cdn.firejq.com/jpg/2018/11/25/ff28f5fc4df5a24db8198789b5efd416.jpg)

- 新生代
- 老年代

#### 2.2.1. 新生代 GC (Young GC / Minor GC)

**发生在新生代的垃圾收集动作称为 Young GC / Minor GC，每次垃圾收集时都发现有大批对象死去，只有少量存活，因此所采用的是复制算法**。由于 Java 对象大多都是朝生夕灭，而当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间，因此 Minor GC 非常频繁且回收速度非常快。

![image](http://img.cdn.firejq.com/jpg/2018/11/25/4e481e8d87bb9b86dfc434a86b534b56.jpg)

在年轻代中，又分为 Eden 区域和 Survivor 区域，默认 Eden 和 Survivor 的大小比例是 8:1。

- Eden 区

  大多数情况下，新对象的内存分配都会优先分配在 Eden 区域。当 Eden 区域的空间不足于分配新对象时，就会触发年轻代上的垃圾回收（发生在 Eden 和 Survivor 内存区域上）即 Minor GC。

  同时，每个对象都有一个“年龄”计数器，这个年龄实际上指的就是该对象经历过的 Minor GC 的次数。当对象刚分配到 Eden 区域时，对象的年龄为 0。

- Survivor1 (From Space) 区

  当第一次 Minor GC 被触发后，JVM 通过可达性分析对 Eden 区域中的对象进行存活判定，并把所有判定存活下来的对象拷贝到 Survivor1 区域，同时年龄自增。最后，JVM 就会清除整个 Eden 内存区域中的非可达对象。

- Survivor2 (To Space) 区

  当第一次 Minor GC 被触发后，JVM 再次通过可达性分析对 Eden 区域和 Survivor1 区域中的对象进行存活判定，并把所有判定存活下来的对象拷贝到 Survivor2 区域（这也就是为什么需要两个大小一样的 Survivor 区域的原因，两个区被交替使用，确保其中一个全空)），同时年龄自增。最后，JVM 会清除所有在 Eden 内存区域和 Survivor1 内存区域的非可达对象。

#### 2.2.2. 年代转换

- 长期存活的对象将进入老年代：

  当对象的年龄足够大（默认为 15，这个年龄阈值可以通过参数 `-XX:MaxTenuringThreshold` 来设置），当 Minor GC 再次发生时，它会从 Survivor 内存区域升级到老年代中。

- 动态对象年龄判定：

  为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代。如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半（Survivor 内存区域中没有足够的空间来容纳从 Eden 升级过来的对象时），年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。

#### 2.2.3. 老年代 GC (Major GC/Full GC)

老年代也称为 Tenured 区，**发生在老年代的垃圾收集动作称为 Major GC / Full GC，由于对象存活率高、没有额外空间对它进行分配担保，因此所采用的是标记 - 清除算法或标记 - 整理算法（取决于 JVM 所采用的垃圾收集器）**。

出现了 Major GC，一般都会伴随至少一次的 Minor GC（但非绝对的，在 ParallelScavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。老年代里面的对象几乎都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长，Major GC 的速度一般会比 Minor GC 慢 10 倍以上。

另外，标记 - 清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。

#### 2.2.4. 空间分配担保

在发生 Minor GC 前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间：
- 如果大于，那么 Minor GC 可以确保是安全的。
- 如果小于，虚拟机会查看 HandlePromotionFailure 设置值是否允许担任失败：
  - 如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小：
    - 如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的。
    - 如果小于，进行一次 Full GC。
  - 如果不允许，也要改为进行一次 Full GC。

新生代使用复制收集算法，但为了内存利用率，只使用其中一个 Survivor 空间来作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况时（最极端就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，让 Survivor 无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行 Full GC 来让老年代腾出更多空间。

取平均值进行比较其实仍然是一种动态概率的手段，也就是说如果某次 Minor GC 存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了 HandlePromotionFailure 失败，那就只好在失败后重新发起一次 Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将 HandlePromotionFailure 开关打开，避免 Full GC 过于频繁。

JDK 6u24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或历次晋升的平均大小就会进行 Minor GC，否则就进行 Full GC。

## 4. Refer Links

[HotSpot Memory Management 白皮书](https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf)

[对象存活判定算法（可回收对象的判定）](https://www.jianshu.com/p/9aad5570456d)

[JVM 垃圾收集器与内存分配策略](http://liucw.cn/2017/12/24/jvm/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/)

[Java 垃圾回收机制](https://www.jianshu.com/p/778dd3848196)

[知乎：Java 的垃圾回收机制的主要原理是什么？](https://www.zhihu.com/question/19912197)

[知乎：主流的垃圾回收机制都有哪些？](https://www.zhihu.com/question/32373436)

[JVM 的持久代——何去何从？](http://ifeve.com/jvm-permgen-where-art-thou/)

[Copy GC(1) : 基本原理](https://zhuanlan.zhihu.com/p/28197216)

[Copy GC(2) ： 非递归的遍历](https://zhuanlan.zhihu.com/p/28200199)

[Copy GC(3) : JVM 中的实现](https://zhuanlan.zhihu.com/p/28250544)

[Copy GC(4) : parallel scavenge](https://zhuanlan.zhihu.com/p/28399178)

[Copy GC(5): Parallel GC（下）](https://zhuanlan.zhihu.com/p/29088296)

[Tracing GC(1)](https://zhuanlan.zhihu.com/p/30175684)

[Tracing GC(2)](https://zhuanlan.zhihu.com/p/30247480)

[Tracing GC(3): mark & compaction](https://zhuanlan.zhihu.com/p/30797760)

[深入理解 JVM(4)——如何优化 Java GC「译」](https://crowhawk.github.io/2017/08/21/jvm_4/)

TODO:

[知乎：各种编程语言的实现都采用了哪些垃圾回收算法？这些算法都有哪些优点和缺点？](https://www.zhihu.com/question/20018826)

[知乎：为什么 Python 工程师很少像 Java 工程师那样讨论垃圾回收？](https://www.zhihu.com/question/38380754)