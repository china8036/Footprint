- [HotSpot 垃圾收集器 (Garbage Collectors)](#hotspot-垃圾收集器-garbage-collectors)
  - [1. 串行收集器](#1-串行收集器)
    - [1.1. Serial 收集器](#11-serial-收集器)
    - [1.2. Serial Old 收集器](#12-serial-old-收集器)
  - [2. 并行收集器](#2-并行收集器)
    - [2.1. ParNew 收集器](#21-parnew-收集器)
    - [2.2. Parallel Scavenge 收集器](#22-parallel-scavenge-收集器)
    - [2.3. Parallel Old 收集器](#23-parallel-old-收集器)
  - [3. 并发收集器](#3-并发收集器)
    - [3.1. CMS(Concurrent Mark Sweep) 收集器](#31-cmsconcurrent-mark-sweep-收集器)
    - [3.2. Garbage-First 收集器](#32-garbage-first-收集器)
      - [3.2.1. 运作过程](#321-运作过程)
      - [3.2.2. 基本特点](#322-基本特点)
      - [3.2.3. 实现难点](#323-实现难点)
      - [3.2.4. 适用场景](#324-适用场景)
    - [3.3. Z 收集器](#33-z-收集器)
  - [4. Refer Links](#4-refer-links)

# HotSpot 垃圾收集器 (Garbage Collectors)

如果说 GC 算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。

**JVM 规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别**，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。

对于 HotSpot 虚拟机，在 JDK 1.7 Update 14 之后正式提供了 G1 商用收集器。HotSpot 虚拟机包含的所有收集器如下：

![image](http://img.cdn.firejq.com/jpg/2018/12/25/1cf6db763dfc65f652457f4a29491054.jpg)

其中，**如果两个收集器之间存在连线，就说明它们可以搭配使用**，如：老年代收集器 CMS 收集器不能和新生代收集器 Parallel Scavenge 收集器搭配使用。

NOTE：虽然我们是在对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。因为**直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器**。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那 HotSpot 虚拟机就没必要实现那么多不同的收集器了。

## 1. 串行收集器

串行收集器也就是单线程收集器，只会使用一条 GC 线程去完成 GC，且必须暂停其他所有的用户线程，直到 GC 完成。

串行收集器一般只适用于 Heap 内存很小的、GC 停顿时间很短的环境，**是运行在 Client 模式下的 Hotspot 虚拟机的默认收集器**。

- 可通过 `-XX:+UseSerialGC`（一旦设置后会自动设置 `-XX:+UseSerialOldGC` 选项）来启用。

### 1.1. Serial 收集器

Serial 收集器是新生代收集器，也是最基本、发展历史最悠久的收集器，采用**Copy 算法**进行 GC。**在 JDK 1.3.1 之前是虚拟机新生代收集的唯一选择**。

Serial 收集器是一个单线程的收集器，只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，且在进行垃圾收集时，必须暂停其他所有的工作线程 (**STD -- "Stop The World"**)，直到它收集结束。由于这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下就把用户的正常工作的线程全部停掉，因此这对很多应用来说都是难以接受的。

![image](http://img.cdn.firejq.com/jpg/2018/11/20/fc88b34b67d6da5166372333a55de01e.jpg)

优点：
- 简单而高效（与其他收集器的单线程比），**对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率**。
- 在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，**只要不是频繁发生 GC，这点停顿时间是完全可以接受的。所以，Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择**。

缺点：
- GC 时暂停线程带给用户不良体验。

### 1.2. Serial Old 收集器

Serial Old 收集器是 Serial 收集器的老年代版本，同样是一个单线程收集器，但使用的是 **Mark-Compact GC 算法**，主要运行在 Client 模式下的虚拟机中的老年代。

若运行在 Server 模式下，它主要还有两大用途：
- 在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 的时候使用。

![image](http://img.cdn.firejq.com/jpg/2018/11/20/bc040189fb707ca92fef1e38660ee020.jpg)

由于是单线程收集器，因此同样由于 GC 时暂停线程，会带给用户不良的体验。

## 2. 并行收集器

并行收集器会使用多条 GC 线程并行进行 GC，但与串行收集器相同的是此时也必须暂停其他所有的用户线程，直到 GC 完成。

并行收集器关注点更多放在吞吐量（GC 耗时与用户程序耗时的占比），一般适用于科学计算、后台处理等弱交互的场景，**是运行在 Server 模式下的 Hotspot 虚拟机的默认收集器**。

相关参数
- 通过 `-XX:+UseParallelGC`（一旦设置后会自动设置 `-XX:+UseParallelOldGC` 选项）来启用。
- 通过 `-XX:ParallelGCThreads=<N>` 设置 N 个 GC 线程（若 CPU>8，则 N 默认为 5/8；若 CPU<8，则 N 默认为 CPU 核数）。

### 2.1. ParNew 收集器

ParNew 收集器是新生代收集器，事实上就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为都与 Serial 收集器完全一样，**实现上这两种收集器也共用了相当多的代码**。

![image](http://img.cdn.firejq.com/jpg/2018/11/20/57f3420c33fa7a4495a3971223adf210.jpg)

需要注意的是，**在单 CPU 的环境下，由于线程切换的开销，ParNew 收集器绝对不会比 Serial 收集器有更高的效率**。ParNew 收集器默认开启与 CPU 数量相同的收集线程数，可以使用 `-XX:ParallerlGCThreads` 参数来限制 GC 线程数。

### 2.2. Parallel Scavenge 收集器

与 ParNew 收集器一样，Parallel Scavenge 收集器是一个使用复制算法的新生代收集器，不同之处在于**Parallel Scavenge 收集器没有使用传统的 GC 收集器代码框架，而是另外独立实现**，其关注点在于以下两个方面：

- **可控制的吞吐量 (Throughtput)**，即 CPU 用于运行用户代码的时间与 CPU 消耗总时间的比值。

  ParNew、CMS 等收集器的关注点在于尽可能缩短垃圾收集时用户线程的停顿时间，停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验。而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量，高吞吐量可以高效率地理用 CPU 时间，尽快完成程序的运算任务，**适合在后台运算而不需要太多交互的任务**。

  由于与吞吐量关系密切，**Parallel Scavenge 收集器也被称为“吞吐量优先”收集器**。它提供了 `-XX:MaxGCPauseMills` 参数来控制最大垃圾收集停顿时间和 `-XX:GCTimeRatio` 来直接设置吞吐量。其中，GC 停顿时间的降低是通过牺牲吞吐量和新生代空间（减小新生代空间，GC 频率变大，吞吐量降低）来实现的。

- **自适应调节策略 (Ergonomics)**

  Parallel Scavenge 收集器的另一个重要特点是 GC 自适应的调节策略 (GC Ergonomics)：
  - `-XX:+UseAdaptiveSizePolicy`: 设置启用自使用调节策略，不需要指定新生代的大小、Eden 与 Surivior 的比例、晋升老年代的年龄等细节参数，让虚拟机根据当前系统的运行情况收集性能监控信息，并动态调整这些参数以提供最合适的停顿时间或最大吞吐量。
  - `-XX:YoungGenerationSizeIncrement=<N>`: 设置 Young 区的动态内存调整增幅。
  - `-XX:TenuredGenerationSizeIncrement=<N>`: 设置 Old 区的动态内存调整增幅。
  - `-XX:AdaptiveSizeDecrementScaleFactor=<N>`:

  NOTE
  - 由于实际情况非常复杂，因此在生产环境下，一般还是会进行人为的手工调节而不是使用自适应调节策略。

### 2.3. Parallel Old 收集器

Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，同样是一个多线程收集器，但使用的是 **Mark-Compact GC 算法**，在 JDK 1.6 中才开始提供。

在 Parallel Old 收集器出现之前，Parallel Scavenge 收集器一直处于一个尴尬的位置（由于 Parallel Scavenge 收集器无法与 CMS 收集器搭配，因此老生代只能选择单线程的 Serial Old 收集器）。Parallel Old 收集器的出现，使得“吞吐量优先”的收集器终于有了名副其实的应用组合，即 Parallel Scavenge 收集器加 Parallel Old 收集器。

![image](http://img.cdn.firejq.com/jpg/2018/11/20/c8a2e5bd7d6b051bec85eca3147abf54.jpg)

## 3. 并发收集器

并发收集器会使用多条 GC 线程并行进行 GC，但与并行收集器不同的是用户线程与 GC 线程可以同时进行，GC 的执行不会停顿用户线程的运行。

并发收集器关注点更多放在 GC 停顿时间（GC 中断应用执行的时间）/ 响应时间，一般适用于对响应时间有要求的强交互场景，如 Web 应用等。

### 3.1. CMS(Concurrent Mark Sweep) 收集器

**CMS(Concurrent Mark Sweep) 收集器是老年代收集器，使用 Mark-Sweep GC 算法。它是 JDK 1.5 推出的在强交互应用中几乎可被认为具有划时代意义的垃圾收集器，是 HotSpot 虚拟机中第一款真正意义上的并发收集器，真正实现了让 GC 线程与用户线程同时工作**。但 CMS 作为老生代收集器，却无法与 JDK1.4 中已存在的新生代 Parallel Scavenge 收集器配合工作，因此**在 JDK1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或 Serial 收集器中的一个**。

CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器，因此非常适用于重视服务响应速度的应用程序（如 B/S 应用）。

相关参数
- 通过 `-XX:+UseConcMarkSweepGC`（一旦设置后会自动设置 `-XX:+UseParNewGC` 选项）来启用。
- 通过 `-XX:ConcGCThreads=<N>` 设置并发的 GC 线程数。
- 通过 `-XX:CMSInitiatingOccupancyFraction=<N>` 设置 Old 区占用百分比达到 N 之后才触发 Full GC，默认值为 92%。
- 通过 `-XX:+CMSScavengeBeforeRemark`: 设置 Full GC 之前先执行 Young GC，以达到优化的目的。

CMS 收集器使用的是标记 - 清除算法 (Mark-Sweep GC)，其基本运作过程分为 4 个步骤：
1. 初始标记 (CMS initial mark): 需要暂停用户线程 (STW)，仅仅标记 GC Roots 能直接关联的对象，因此速度很快。
1. 并发标记 (CMS concurrent mark): 用户线程与标记线程并发执行，进行 GC Roots Tracing。
1. 重新标记 (CMS remark): 需要暂停用户线程 (STW)，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
1. 并发清除 (CMS concurrent sweep): 用户线程与清除线程并发执行。

![image](http://img.cdn.firejq.com/jpg/2018/11/21/f7b04bed0340b1c5047cbd60c7da15d7.jpg)

**由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以系统停顿时间极短**，总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发地执行的。

存在的明显问题：
- **对 CPU 资源非常敏感**。

  在并发阶段，虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低，应用程序会变慢，当 CPU 数不足时，尤其明显。

  为解决这个问题，虚拟机提供了一种 CMS 收集器的变种，即增量式并发收集器 (i-CMS)，在并发标记、清除时让 GC 线程与用户线程交替运行，以降低 GC 线程独占 CPU 的时间。但当 GC 时间将变长时，实际效果非常一般，因此也被弃用。

- **无法处理浮动垃圾**，可能出现 Concurrent Mode Failure 而导致另一次 Full GC 的产生。

  在并发清除阶段，用户线程仍在运行，此时产生的垃圾无法在该次收集中处理，只好等下一次 GC 时再进行清理，这部分垃圾就称为浮动垃圾。

  同时由于要保证并发，就必须预留内存给用户线程使用，因此 CMS 无法等到老年代几乎完全填满时再进行收集。JDK 1.5 中 CMS 默认当老年代被使用 68% 时被激发。1.6 中为 92%。当 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode “Failure”失败，这时虚拟机将启动后备预案：临时使用 Serial Old 收集器来重新进行老年代垃圾收集，这样停顿时间就会很长，性能反而降低。

- **收集结束时会产生大量的空间碎片**，因为使用的是 Mark-Sweep GC 算法。

  这是由于该收集器的“标记 - 清除”算法所引起的，所以往往存在有很大空间剩余，但当无法找到足够大的连续空间来分配当前对象时，还是不得不提前出发一次 Full GC。

  为解决此问题，虚拟机提供了 2 个控制选项：
  - `-XX:+UseCMSCompactFullCollection`: （默认开启）设置每次 Full GC 后执行 1 次内存碎片的压缩整理，该过程不能并发，故停顿时间会变长。
  - `-XX:CMSFullGCsBeforeCompaction=<N>`: 设置执行 N 次 Full GC 后执行 1 次内存碎片的压缩整理。默认为 0，表示每次进入 Full GC 时都进行碎片整理。

### 3.2. Garbage-First 收集器

**G1 (Garbage First) 收集器是同时适用于新生代和老年代的收集器，也当今收集器技术发展的最前沿成果之一**，作为体验版随着 JDK 6u14 版本面世，在 JDK 7u4 版本发行时被正式推出，它被视为 JDK 1.7 中 HotSpot 虚拟机的一个重要进化特征。**在 JDK 9 中，G1 被设置为默认垃圾收集器（JEP 248）**。

G1 收集器是一款面向 Server 端应用的垃圾收集器，被开发来替代掉 JDK1.5 发布的 CMS 收集器。G1 收集器都没有使用传统的 GC 收集器代码框架，而是另外独立实现。

相关参数
- `-XX:+UseG1GC`: 启用 G1 收集器。
- `-XX:G1NewSizePercent=<N>`:
- `-XX:G1MaxNewSizePercent=<N>`:
- `-XX:ReservePercent=<N>`:
- `-XX:ParallelGCThreads=<N>`: 设置 SWT 线程数。
- `-XX:ConcGCThreads=<N>`: 设置并发线程数。

#### 3.2.1. 运作过程

如果不计算维护 Remembered Set 的操作，G1 收集器的运作过程与 CMS 相似：
1. 初始标记：暂停用户线程，标记 GC Roots 能直接关联的对象。
1. 并发标记：用户线程与标记线程并发，进行 GC Roots 的 Trace。
1. 最终标记：修正并发标记阶段，因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录。
1. 筛选回收：对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。

![image](http://img.cdn.firejq.com/jpg/2018/11/21/bc689d33f4bb5477c1a5c6ecba09fe30.jpg)

#### 3.2.2. 基本特点

与其它收集器相比，G1 收集器具有以下特点：
- 并行且并发

  G1 收集器可充分利用多 CPU 资源的硬件优势，使用多个 CPU 来缩短 Stop-The-World 的时间。

- 分代收集，可管理整个 Heap

  传统的 GC 收集器将连续的内存空间划分为新生代、老年代和永久代（JDK 8 去除了永久代，引入了元空间 Metaspace），这种划分的特点是各代的存储地址（逻辑地址，下同）是连续的。如下图所示：

  ![image](http://img.cdn.firejq.com/jpg/2018/11/21/6e13e757d833259ffc5d3bcada83673b.jpg)

  而 G1 的堆内存布局与其他收集器不同，**G1 将整个堆内存空间划分为多个大小相等的 Region，虽然仍然有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的，他们都是一部分 Region（不需要连续）的集合。各代存储地址是不连续的，每一代都使用了 n 个不连续的大小相同的 Region，每个 Region 占有一块连续的虚拟内存地址**。如下图所示：

  ![image](http://img.cdn.firejq.com/jpg/2018/11/21/ff1db5bb7ae74a4d040940137f12349f.jpg)

  因此，其它收集器进行收集的范围都是整个新生代或老年代，而 G1 收集器可以不需要与其它收集器配合就能独立管理整个 GC 堆。

- 空间整合

  G1 收集器从整体来看是基于标记 - 整理算法实现的收集器，但从局部（2 个 Region 之间）来看是基于复制算法实现的。这 2 种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。

- 可预测的停顿时间模型

  降低停顿时间是 G1 和 CMS 收集器都追求的关注点，但 G1 除了追求低停顿，还能建立可预测的停顿时间模式，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒，这几乎已经是实时 Java (RTSJ) 的垃圾收集器的特征了。

  **G1 之所以能建立可预测的停顿时间模型，是因为它极力地避免全区域的垃圾收集**。G1 将内存划分为多个独立的 Region，并跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region，从而保证了 G1 收集器再有限的时间内可以获取经可能高的收集效率。

#### 3.2.3. 实现难点

虽然内存分为 Region，但垃圾收集不能真的以 Region 为单位进行，因为 Region 不可能是孤立的，存在某个对象被多个 Region 的引用，那在做可达性判断确定对象是否存活时，岂不是需要扫描整个堆空间才能保证准确性？

**在 G1 收集器中，Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用 Remembered Set 来避免全堆扫描的**。G1 收集器中每个 Region 都有一个与之对应的 Remembered Set，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断操作，检查 Reference 类型引用的对象是否处于不同的 Region（在分代的例子中就是检查是否老年代的对象引用了新生代中的对象），如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。

#### 3.2.4. 适用场景

- 如果原来的收集器没有出现任何问题，那么就没有任何理由去选择 G1。
- 如果引用追求低停顿，那么 G1 可以作为一个可尝试的选择。
- 如果应用追求吞吐量，那么 G1 并不会带来什么特别的好处。

### 3.3. Z 收集器

TODO:

[JEP 333: ZGC: A Scalable Low-Latency Garbage Collector](http://openjdk.java.net/jeps/333)

[Java 程序员的荣光，听 R 大论 JDK11 的 ZGC](https://mp.weixin.qq.com/s?__biz=MzIzODYyNjkzNw==&mid=2247483956&idx=1&sn=e9f8bbbb70c8919cf1efea2ed465f5d3&chksm=e9373322de40ba34f0e8ea645c556b62cc3829cafefb390537321693a13d31480bd6c768ea40&mpshare=1&scene=1&srcid=0831tknoOQCZ6tVCJyuQzszC#rd)

Z Garbage Collector (ZGC) 项目需要完成的目标是：控制 Java 的垃圾回收时长在 10ms 以内，绝对不超过 10ms，并且使用了该垃圾回收策略之后，吞吐对比当前 Java 缺省的垃圾回收策略 G1，下降不超过 15%。

## 4. Refer Links

[Java Hotspot G1 GC 的一些关键技术](https://tech.meituan.com/g1.html)

[JVM 垃圾回收器工作原理及使用实例介绍](https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/index.html)

[深入理解 JVM(3)——7 种垃圾收集器](https://crowhawk.github.io/2017/08/15/jvm_3/)

<!-- TODO: -->

[G1 最佳实践](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations)
