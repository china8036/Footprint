- [JVM 对象](#jvm-%E5%AF%B9%E8%B1%A1)
  - [1. 对象内存布局](#1-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80)
    - [1.1. 对象头](#11-%E5%AF%B9%E8%B1%A1%E5%A4%B4)
    - [1.2. 实例数据](#12-%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE)
    - [1.3. 对齐填充](#13-%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85)
  - [2. 对象的创建](#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA)
    - [2.1. 类加载检查](#21-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5)
    - [2.2. 分配内存](#22-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98)
    - [2.3. 内存初始化](#23-%E5%86%85%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96)
    - [2.4. 设置对象头](#24-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4)
    - [2.5. 执行构造方法](#25-%E6%89%A7%E8%A1%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95)
  - [3. 对象的访问定位](#3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D)
  - [4. Refer Links](#4-refer-links)

# JVM 对象

对于 JVM 的内存中，对象是如何创建、如何布局、如何访问的细节问题，必须限定在具体的虚拟机和集中在某一个内存区域上才有意义，因此以下内容基于 HotSpot 虚拟机的 Java 堆中。

## 1. 对象内存布局

在 HotSpot 虚拟机中，**对象在内存中存储的布局可以分为 3 块区域：对象头 (Header)、实例数据 (Instance Data) 和对齐填充 (Padding)**。

### 1.1. 对象头

HotSpot 虚拟机的对象头包括两部分信息：
- 第一部分用于存储**对象自身的运行时数据 (Mark Word)**，包括哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit。

  实际上，由于对象需要存储的运行数据非常多，基本上都会超过 32bit/64bit Bitmap 结构所能记录的限度，但是考虑到对象头信息是与对象定义本身数据无关的额外存储成本以及 JVM 的空间效率，Mark Word 通常被设计为一个非固定的数据结构以便在极小的空间中存储尽可能多的信息，它会根据对象的状态**复用**自己的存储空间。

  以下是 32 位 JVM 的 Mark Word 默认存储结构：

  | 锁状态  | 25bit      | 4bit   | 是否是偏向锁 1bit | 锁标志位 2bit  |
  | ---- | ---------- | ------ | ------------------ | ----------- |
  | 无锁状态 | 对象 HashCode | 对象分代年龄 | 0          | 01        |

  除了上述列出的 Mark Word 默认存储结构外，还有如下可能变化的结构：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/31/d7b63501b9a3f68af48fa381f237cfbc.jpg)

- 另一部分是**类型指针 (Class Metadata Address)**，即对象指向它的类元数据的指针，JVM 通过这个指针来确定这个对象是哪个类的实例（需要注意，并不是所有 JVM 实现都通过在对象数据上保留类型指针来查找对象的元数据信息），这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit。

由于 JVM 可以通过 POJO 的元数据信息确定 POJO 的大小，但从数组的元数据中无法得知数组的长度大小。因此，**如果对象是一个数组，那么在对象头中还需要有一块用于记录数组长度的数据空间**。

### 1.2. 实例数据

实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容（包括了从父类继承的字段和子类定义的字段）。

**相同宽度的字段总会被分配到一起，并且在父类中定义的变量会出现在子类之前，如果 CompactFields 参数值为 true（默认为 true），那么子类中较窄的变量也可能会插入到父类变量的空隙之中**。

这部分内存按 4 字节对齐。

### 1.3. 对齐填充

对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。

**由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，也就是说对象的大小必须是 8 字节的整数倍，对象头部分正好是 8 字节的倍数**。因此，当对象实例不满 8 个字节的时候，就需要使用对齐填充来占位补全。

## 2. 对象的创建

在语言层面，创建对象通常仅仅是一个 new 关键字而已，但将 Java 代码编译为字节码后，在 JVM 中对象的创建需要一系列的操作流程。

### 2.1. 类加载检查

当 JVM 遇到一个 new 指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

### 2.2. 分配内存

在类加载检查通过后，接下来 JVM 就会为新生对象分配内存。由于对象所需内存的大小在类加载完成后便是完全确定的，因此为对象分配内存的任务等同于把一块确定大小的内存从 Java 堆中划分出来。

那么，应该如何为对象划分一段确定大小的可用内存空间？
- 如果 Java 堆中的内存是绝对规整的，所有用过的内存在一边，空闲的内存都在另一边，中间放着一个指针作为分界点的指示器，那么分配内存就仅仅是将该指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“**指针碰撞**”。
- 如果 Java 堆中的内存并不是规整的，已使用的内存和未使用的内存相互交错，那么 JVM 必须维护一个列表，记录哪些内存块是可用的，从而在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“**空闲列表**”。

选择哪种分配方式，取决于 Java 堆是否是规整的，而 Java 堆是否规整又由采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。

除此之外，另一个需要考虑的问题是对象创建在 JVM 中是非常频繁的行为，因此即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的。解决这一问题一般有两种方法：
- **对分配内存空间的动作进行同步处理。实际上 JVM 采用 CAS 加失败重试的方法来保证更新操作的原子性**。
- **将内存分配动作按照线程划分在不同的空间中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）**。每个线程都在各自的 TLAB 上进行内存的分配操作，只有 TLAB 用完需要分配新的 TLAB 时，才进行同步锁定。JVM 是否开启 TLAB 功能，可通过 `-XX:+/-UseTLAB` 参数来设定。

### 2.3. 内存初始化

内存分配完之后，**JVM 需要将分配到的内存空间都初始化为零值**（**不包括对象头**），如果使用 TLAB，这一工作过程也可以提前至 TLAB 分配时进行。

这一步操作保证了对象的实例字段在 Java 代码中可不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

### 2.4. 设置对象头

接下来，JVM 对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。

这些信息存放在对象的对象头中，根据 JVM 当前运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式。

### 2.5. 执行构造方法

执行完上边的一系列操作后，从 JVM 的角度上看，一个新的对象已经产生了，但从 Java 程序的角度上看，对象创建还需要执行 init 方法，按照程序员的意愿进行初始化，这样一个真正可用的对象就完全创建完毕了。

## 3. 对象的访问定位

Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。**由于 JVM 规范中没有定义 reference 数据的对象引用应该如何定位、访问堆中的对象的具体位置，因此，对象的访问方式取决于 JVM 的实现。**

目前访问对象的方式主流的方式有两种：句柄和直接指针。

- 如果直接使用句柄访问，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的是对象的句柄地址，而句柄中包含了**对象实例数据**与**类型数据各自的具体地址信息**。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/30/d6d0c2acc806922b1e49bf35469abf09.jpg)

  使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。

- 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/3/30/a7b323a4dfe48e2781a9272ef8b676c0.jpg)

  使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。
  

**HotSpot 虚拟机使用的是直接指针访问的方式，但从软件开发的整个范围来看，句柄访问的情况在各种语言和框架中也十分常见**。

## 4. Refer Links

《深入理解 Java 虚拟机》 周志明 著
