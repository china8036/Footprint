- [JVM 自动内存管理：概述](#jvm-自动内存管理概述)
  - [1. Refer Links](#1-refer-links)

# JVM 自动内存管理：概述

> Java 和 C++ 之间有一堵由**内存动态分配**和**垃圾收集技术**所围城的“高墙”，墙外的人想进来，墙内的人却想出去。

Java 技术体系中的自动内存管理机制最终可归结为自动化地解决了 2 个问题：
- 自动给对象分配内存
- 自动回收分配给对象的内存

**内存泄露**是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。

TODO:

GC 分为 2 种：
- 新生代 GC (Minor GC):

  指发生在新生代的垃圾收集动作，所采用的是复制算法。

  由于 Java 对象大多都是朝生夕灭，而当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间，因此 Minor GC 非常频繁且回收速度非常快。

- 老年代 GC (Major GC / Full GC):

  指发生在老年代的垃圾收集动作，所采用的是标记-清除算法。

  出现了 Major GC，一般都会伴随至少一次的 Minor GC（但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。老年代里面的对象几乎都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长，Major GC 的速度一般会比 Minor GC 慢 10 倍以上。

  另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。
  

## 1. Refer Links