- [JVM 内存区域](#jvm-内存区域)
  - [1. 区域划分](#1-区域划分)
  - [2. 程序计数器 （Program Counter Register）](#2-程序计数器-program-counter-register)
    - [2.1. 存放内容](#21-存放内容)
    - [2.2. 线程私有](#22-线程私有)
    - [2.3. 异常情况](#23-异常情况)
  - [3. Java 虚拟机栈 (VM Stack)](#3-java-虚拟机栈-vm-stack)
    - [3.1. 存放内容](#31-存放内容)
    - [3.2. 栈帧](#32-栈帧)
    - [3.3. 线程私有](#33-线程私有)
    - [3.4. 异常情况](#34-异常情况)
  - [4. 本地方法栈 (Native Method Stack)](#4-本地方法栈-native-method-stack)
    - [4.1. 存放内容](#41-存放内容)
    - [4.2. 异常情况](#42-异常情况)
  - [5. Java 堆 (Heap)](#5-java-堆-heap)
    - [5.1. 存放内容](#51-存放内容)
    - [5.2. 区域划分](#52-区域划分)
      - [5.2.1. 内存分配](#521-内存分配)
      - [5.2.2. 内存回收](#522-内存回收)
    - [5.3. 线程共享](#53-线程共享)
    - [5.4. 异常情况](#54-异常情况)
  - [6. 方法区 (Method Area)](#6-方法区-method-area)
    - [6.1. 存放内容](#61-存放内容)
    - [6.2. 运行时常量池](#62-运行时常量池)
    - [6.3. 永生代](#63-永生代)
    - [6.4. 异常情况](#64-异常情况)
  - [7. 直接内存 (Direct Memory)](#7-直接内存-direct-memory)
  - [8. Refer Links](#8-refer-links)

# JVM 内存区域

## 1. 区域划分

在 Java 程序的执行过程中，JVM 会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为**Runtime Data Area（运行时数据区）**，也就是我们常说的 JVM 内存，在 Java 中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。

JVM 在执行 Java 程序的过程中会把它所管理的内存（即运行时数据区）划分成若干个不同的数据区域。这些区域有各自的用途、创建时间和销毁时间，有的区域随者虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。

根据 [Java SE 7 虚拟机规范](https://docs.oracle.com/javase/specs/jvms/se7/html/index.html) 规定，**JVM 所管理的内存将会包括以下几个运行时数据区域：程序计数器、Java 虚拟机栈、本地方法栈、Java 堆、方法区**。

![image](http://img.cdn.firejq.com/jpg/2018/3/29/79a6511cfbe2dd6fbf4ae7997f53bd9b.jpg)

按照线程私有与否可将上图整理为：

![image](http://img.cdn.firejq.com/jpg/2018/3/29/83ea6d9fbea1b0287fd49482c2ae5e0e.jpg)

NOTE: 在 JVM 规范中虽然规定了程序在执行期间运行时数据区应该包括这几部分，但是**至于具体如何实现并没有做出规定，因此，不同的虚拟机厂商可以有不同的实现方式**。

## 2. 程序计数器 （Program Counter Register）

### 2.1. 存放内容

计算机 CPU 的寄存器中有一个 **PC 寄存器，存放下一条指令所在存储单元的地址**，当 CPU 需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加 1 或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。

类似 CPU 的程序计数器，JVM 在内存中设立了一块较小的内存区域，**存放正在执行的字节码地址（而不是下一条字节码地址），这块区域称为程序计数器 （Program Counter Register）**。

程序计数器 (Program Counter Register) 可以看作是**当前线程所执行的字节码的行号指示器**。在虚拟机概念模型中，**字节码解释器工作时就是通过改变这个计数器的值来选取下一条要执行的字节码指令的**，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

### 2.2. 线程私有

由于 JVM 的多线程是通过线程轮流切换并分配 CPU 执行时间的方式来实现的，为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器 PCR，各个线程的 PCR 之间互不影响、独立存储，属于“线程私有”的内存。

如果线程正在执行的是一个 Java 方法，这个 PCR 记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个 PCR 则为空 (Undefined)。

### 2.3. 异常情况

由于 PCR 中存储数据所占空间的大小不会随程序的执行而发生改变，因此**此内存区域不会发生内存溢出现象 (OutOfMemory)，也是唯一在 JVM 规范中没有规定任何 OutOfMemoryError 异常情况的区域**。

## 3. Java 虚拟机栈 (VM Stack)

### 3.1. 存放内容

Java 虚拟机栈 (VM Stack) 描述的是 Java 方法执行的内存模型：

**Java 栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法**。在每个栈帧中，存储了局部变量表 (Local Variables)、操作数栈 (Operand Stack)、指向当前方法所属类的运行时常量池的引用 (Reference to runtime constant pool)、方法返回地址 (Return Address) 和一些额外的附加信息。

![image](http://img.cdn.firejq.com/jpg/2018/3/29/541c8f65b4fede3a58478380b972fae9.jpg)

**Linux x64 上 HotSpot VM 给 Java 虚拟机栈定义的“系统默认”大小为 1MB**。

### 3.2. 栈帧

- **局部变量表 (Local Variables)**

  经常有人将 Java 内存分为堆内存和栈内存，这样的分法显然过于粗糙，但这也说明这两块内存区域是最受关注的区域。其中，**“栈”所指的就是 Java 虚拟机栈，或者说是虚拟机栈中的局部变量表部分**。

  局部变量表用于存储方法中的局部变量（包括在方法中声明的非静态变量以及方法的形参）：
  - 对于编译器可知的各种基本数据类型的变量，则直接存储变量值。其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间（Slot），其余数据类型只占用 1 个。
  - 对于对象引用类型的变量，则存储指定对象的引用 (reference 类型)。
  - 对于 returnAddress 类型，则存储指向一条字节码指令的地址。

  **局部变量表的容量以变量槽（Slot）为最小单位，在虚拟机规范中并没有明确指明一个 Slot 应占用的内存空间大小（允许其随着处理器、操作系统或虚拟机的不同而发生变化）**。
  - 一个 Slot 可以存放一个 32 位以内的数据类型：boolean、byte、char、short、int、float、reference（对象的引用类型）和 returnAddresss（字节码指令的地址）。
  - 对于 64 位的数据类型（long 和 double），虚拟机会以高位在前的方式为其分配两个连续的 Slot 空间。

  虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从 0 开始到局部变量表最大的 Slot 数量，对于 32 位数据类型的变量，索引 n 代表第 n 个 Slot，对于 64 位的，索引 n 代表第 n 和第 n+1 两个 Slot。

- **操作数栈 (Operand Stack)**

  操作数栈又常被称为操作栈，当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。

  **Java 虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈**。因此我们也称 Java 虚拟机是基于栈的，这点不同于 Android 虚拟机，Android 虚拟机是基于寄存器的。**基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些**；而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差。

- **指向所属类的运行时常量池的引用 (Reference to runtime constant pool)**

  在方法执行的过程中有可能需要用到类中的常量，因此必须要有一个指向方法区中该方法所属类的运行时常量池的引用，以支持方法调用过程中的动态连接。

- **方法返回地址 (Return Address)**

  **当一个方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。**

  而当一个方法遇到了任意一个方法返回的字节码指令正常退出时，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址（调用者的 PC 计数器的值），用来帮助恢复它的上层方法的执行状态。

  方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令。

**栈帧所需的内存空间在编译期间完成分配，也就是说，当 Java 程序被编译成 Class 文件后，程序中某个方法需要在帧中分配多大的局部变量空间、多深的操作数栈是完全确定的，并且写入了方法表的 Code 属性之中，在方法的运行期间不会改变栈帧的大小。**

当线程调用执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈；当方法执行完毕之后，便会将栈帧出栈，线程当前执行的方法所对应的栈帧必定位于 Java 虚拟机栈的顶部。因此，每一个方法从调用到执行完毕的过程，实际上就是一个栈帧在 VM Stack 中入栈到出栈的过程。这也是为什么在使用递归方法的时候容易导致栈内存溢出现象的原因。

### 3.3. 线程私有

由于每个线程正在执行的方法可能不同，因此 Java 虚拟机栈也是线程私有的内存区域，每个线程都会有一个自己的 Java 虚拟机栈，互不干扰，相互独立。

### 3.4. 异常情况

在 Java 虚拟机规范中，对这个区域规定了两种异常情况：
- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常。
- 如果虚拟机允许动态扩展（当前大多数 VM 实现都支持），在动态扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常。

## 4. 本地方法栈 (Native Method Stack)

### 4.1. 存放内容

本地方法栈 (Native Method Stack) 与 Java 栈的作用和原理非常相似，区别只不过是**Java 虚拟机栈是为执行 Java 方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的**。

在 JVM 规范中，并没有对本地方法的具体实现方法以及数据结构进行强制的规定，因此具体的虚拟机可以自由实现它，比如**在 HotSopt 虚拟机中就直接把本地方法栈和 Java 虚拟机栈合二为一了**。

### 4.2. 异常情况

与 Java 虚拟机栈一样，Java 虚拟机规范对这个区域也规定了两种异常情况：StackOverflowError 和 OutOfMemoryError 异常。

## 5. Java 堆 (Heap)

### 5.1. 存放内容

对于大多数 Java 应用来说，**Java 堆是 Java 虚拟机所管理的内存中最大的一块。但它唯一的目的就是存放对象实例和数组**，几乎所有的对象实例和数组都在这里分配内存（数组引用存放在 Java 虚拟机栈中）。但随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不那么“绝对”了。

在 C 语言中，堆这部分空间是唯一一个程序员可以自由管理的内存区域，程序员可以通过 malloc 函数和 free 函数在堆上申请和释放空间。Java 和 C 语言中的不同，在 Java 中，程序员基本不用去关心空间释放的问题，Java 的垃圾回收机制会自动进行处理。因此**Java 堆也是 Java 垃圾收集器管理的主要区域，很多时候也被称为“GC 堆”**。

根据 Java 虚拟机规范的规定，Java 堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可（就像磁盘空间一样）。在具体的 Java 虚拟机实现中，可以实现成固定大小，也可以设计为可扩展的。但目前主流的虚拟机都是按照可扩展来实现的。

### 5.2. 区域划分

首先**无论怎么划分，都与存放的内容无关，Java 堆中存放的始终是对象实例和数组，进一步的划分只是为了更高地回收内存和更快地分配内存**。

#### 5.2.1. 内存分配

从内存分配的角度上看，线程共享的 Java 堆中可能划分出多个线程私有的**分配缓冲区 (Thread Local Allocation Buffer，TLAB)**。

#### 5.2.2. 内存回收

![image](http://img.cdn.firejq.com/jpg/2018/11/25/ff28f5fc4df5a24db8198789b5efd416.jpg)

从内存回收的角度上看，由于现在收集器基本都采用**分代收集算法**，因此 Java 堆中还可细分为：
- 新生代

  在年轻代中，又分为：
  - Eden 区
  - Survivor1 (From Space)
  - Survivor2 (To Space) 区

- 老年代 (Tenured 区)

### 5.3. 线程共享

**Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建**。

### 5.4. 异常情况

如果在堆中没有内存可分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。

## 6. 方法区 (Method Area)

### 6.1. 存放内容

方法区与 Java 堆一样，也是一块线程共享的内存区域，用于**存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码（类方法）等数据**。

虽然 Java 虚拟机规范把方法区描述为 Java 堆的一个逻辑部分，但它却有一个别名“Non-Heap”，目的应该与 Java 堆区分开来。

由于 Sun HotSpot 虚拟机的设计团队选择把 GC 分代收集扩展到方法去，或者说使用永久代来实现方法区，因此方法区域又被称为“永久代”。但这仅仅对于 Sun HotSpot 来讲，在 JRockit 和 IBM J9 等其它虚拟机中并不存在永久代的概念。另外，由于使用永久代来实现方法区，更容易遭受到内存溢出的问题，因此在 JDK1.7 的 HotSpot 中，已经把原本放在永久代的字符串常量池移出了。

Java 虚拟机规范对方法区的限制非常宽松，除了和 Java Heap 一样不需要连续的内存，可以选择固定大小或可扩展外，还允许该区域可以选择不实现垃圾收集。**方法区的 GC 主要是针对常量池的回收和对类型的卸载，一般情况发生回收的情况较少，但这确实是必要的**，Sun 公司曾出现的若干 BUG 就是因为低版本的 HotSpot 虚拟机对此区域未完全回收而导致的内存泄漏。

### 6.2. 运行时常量池

运行时常量池是方法区的一部分。CLass 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于**存放编译期生成的各种字面量、符号引用和翻译出来的直接引用**，这部分内容将在类加载后进入方法区的运行时常量池中存放。

JVM 对 class 文件的每一部分都有严格的规范，但对于运行时常量池却没有做任何细节的要求，不同的虚拟机提供商可以按照自己的需要来实现这个内存区域。

运行时常量池相对于 CLass 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 CLass 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是 String 类的 intern() 方法。

### 6.3. 永生代

**从内存回收的角度上看，方法区属于永生代 (Permanent Generation)**。

但**从 Java 8 开始，永生代这个本来就比较别扭的说法被取消**，原永生代中大部分内容（如类的元信息）会被放入本地内存（元数据区 Metaspace），而类的静态变量和内部字符串被分离出放入到 Java 堆中。因此，**Java 8 的 Heap 中实际包含了类的静态变量和局部字符串池的**。

![image](http://img.cdn.firejq.com/jpg/2018/12/19/16a55265bb81712ed9a08c45b8927cbe.jpg)

### 6.4. 异常情况

根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。

## 7. 直接内存 (Direct Memory)

<!-- TODO: -->

直接内存并不是虚拟机允许时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，但这部分内存被频繁地使用，且也可能产生 OOM 异常。

在 JDK1.4 版本中加入了 NIO 类，引入了基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，**使用 Native 函数库直接分配堆外内存，再通过一个存储在 Java 堆中地 DirectByteBuffer 对象作为这块内存地引用进行操作**。通过这种方式，不会在运行时数据区域分配内存，这样就避免了在 Java 堆和 Native 堆中来回复制数据，而是直接调用外部内存。

服务器管理员在配置虚拟机参数时，会根据实际内存设计 -Xmx 等参数信息，但经常忽略直接内存，导致各个内存区域的综合大于物理内存限制，从而导致动态扩展时出现 OOM 异常。

## 8. Refer Links

《深入理解 Java 虚拟机》 周志明 著

[Java 内存区域与内存溢出](http://wiki.jikexueyuan.com/project/java-vm/storage.html)

[JVM 的内存区域划分](https://www.cnblogs.com/dolphin0520/p/3613043.html)

[Java 内存区域详解](https://segmentfault.com/a/1190000002931555)
