- [Design Pattern 结构型模式](#design-pattern-结构型模式)
  - [1. 代理模式 (Proxy Pattern)](#1-代理模式-proxy-pattern)
  - [2. 适配器模式](#2-适配器模式)
    - [2.1. 基本概念](#21-基本概念)
    - [2.2. 实现方式](#22-实现方式)
      - [2.2.1. 继承方式 - 类适配器](#221-继承方式---类适配器)
      - [2.2.2. 组合方式 - 对象适配器](#222-组合方式---对象适配器)
    - [2.3. 适用场景](#23-适用场景)
  - [3. 桥接模式](#3-桥接模式)
  - [4. 装饰模式](#4-装饰模式)
  - [5. 外观模式](#5-外观模式)
  - [6. 享元模式](#6-享元模式)
  - [7. Refer Links](#7-refer-links)

# Design Pattern 结构型模式

如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等，因此对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点。

## 1. 代理模式 (Proxy Pattern)

## 2. 适配器模式

### 2.1. 基本概念

适配器模式可以将一个类的接口和另一个类的接口匹配起来，而无须修改原来的适配者接口和抽象目标类接口。其中，将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作的模块称为包装器 (Wrapper)。

NOTE: 在适配器模式定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合。

根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。在实际开发中，对象适配器的使用频率更高。

### 2.2. 实现方式

#### 2.2.1. 继承方式 - 类适配器

采用继承方式实现的适配器称为类适配器，这种方式通过多重继承不兼容接口，实现对目标接口的匹配，单一的为某个类而实现适配。

优点：
- 在类适配器模式中，由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。

缺点：
- 对于 Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；
- 适配者类不能为最终类，如在 Java 中不能为 final 类，C#中不能为 sealed 类；
- 在 Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。

#### 2.2.2. 组合方式 - 对象适配器

采用组合方式实现的适配器称为对象适配器，这种方式**将被适配者作为一个对象组合到适配器类中**，以修改目标接口包装被适配者。

优点：
- 在对象适配器模式中，一个对象适配器可以把多个不同的适配者适配到同一个目标，且由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。

缺点：
- 与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。

### 2.3. 适用场景

适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在 Spring 等开源框架、驱动程序设计（如 JDBC 中的数据库驱动程序）中也使用了适配器模式。

无论是对象适配器模式还是类适配器模式都具有如下优点：
- 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。
- 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。
- 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。

在以下情况下可以考虑使用适配器模式：
- 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。
- 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

## 3. 桥接模式

## 4. 装饰模式

## 5. 外观模式

## 6. 享元模式

## 7. Refer Links
