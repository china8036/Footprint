- [网页渲染机制](#%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6)
  - [1. 网页生成过程](#1-%E7%BD%91%E9%A1%B5%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B)
  - [2. 重排和重绘](#2-%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98)
  - [3. 性能优化](#3-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96)
  - [4. Refer Links](#4-refer-links)

# 网页渲染机制

## 1. 网页生成过程

![image](http://img.cdn.firejq.com/jpg/2018/2/3/fb7710ed4b5aab52ad3e458aa4a23147.jpg)

网页的生成过程，大致可以分成五步：
1. HTML 代码转化成 DOM
1. CSS 代码转化成 CSSOM（CSS Object Model）
1. 结合 DOM 和 CSSOM，生成一棵渲染树（包含每个节点的视觉信息）
1. 生成布局（layout），即将所有渲染树的所有节点进行平面合成
1. 将布局绘制（paint）在屏幕上

这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。第四步"生成布局"（flow）和第五步"绘制"（paint）合称为"渲染"（render）。

## 2. 重排和重绘

网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。

以下三种情况，会导致网页重新渲染：
- 修改 DOM
- 修改样式表
- 用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）

**重新渲染，就需要重新生成布局和重新绘制。前者叫做"重排"（reflow），后者叫做"重绘"（repaint）。**

注意：
- "重绘"不一定需要"重排"，比如改变某个网页元素的颜色，就只会触发"重绘"，不会触发"重排"，因为布局没有改变。
- 但是，"重排"必然导致"重绘"，比如改变一个网页元素的位置，就会同时触发"重排"和"重绘"，因为布局改变了。

## 3. 性能优化

重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。提高网页性能，不可忽略的一点就是要降低"重排"和"重绘"的频率和成本，尽量少触发重新渲染。

现代浏览器大多会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。但若开发者的写法不好，仍旧会导致浏览器多次重排和重绘。一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染：
```
offsetTop/offsetLeft/offsetWidth/offsetHeight
scrollTop/scrollLeft/scrollWidth/scrollHeight
clientTop/clientLeft/clientWidth/clientHeight
getComputedStyle()
```

一般的规则是：
- 样式表越简单，重排和重绘就越快。
- 重排和重绘的 DOM 元素层级越高，成本就越高。
- table 元素的重排和重绘成本，要高于 div 元素

因此，从性能优化来讲，一般有以下技巧：
- 尽量不要把 DOM 的读操作和写操作，放在一个语句里面：
  ```javascript
  // bad
  div.style.left = div.offsetLeft + 10 + "px";
  div.style.top = div.offsetTop + 10 + "px";

  // good
  var left = div.offsetLeft;
  var top  = div.offsetTop;
  div.style.left = left + 10 + "px";
  div.style.top = top + 10 + "px";
  ```

- 如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。

- 不要一条条地改变样式，而要通过改变 class，或者 csstext 属性，一次性地改变样式。
  ```javascript
  // bad
  var left = 10;
  var top = 10;
  el.style.left = left + "px";
  el.style.top  = top  + "px";

  // good 
  el.className += " theclassname";

  // good
  el.style.cssText += "; left: " + left + "px; top: " + top + "px;";
  ```

- 尽量使用离线 DOM，而不是真实的网面 DOM，来改变元素样式。比如，操作 Document Fragment 对象，完成后再把这个对象加入 DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。

- 先将元素设为 display: none（需要 1 次重排和重绘），然后对这个节点进行 100 次操作，最后再恢复显示（需要 1 次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达 100 次的重新渲染。

- position 属性为 absolute 或 fixed 的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。

- 只在必要的时候，才将元素的 display 属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden 的元素只对重绘有影响，不影响重排。

- 使用虚拟 DOM 的脚本库，比如 React 等。

- 使用 `window.requestAnimationFrame()`、`window.requestIdleCallback()` 这两个方法调节重新渲染。<!-- todo: -->
  - `window.requestAnimationFrame()` 方法可以将某些代码放到下一次重新渲染时执行。
  - `window.requestIdleCallback()` 方法指定只有当一帧的末尾有空闲时间，才会执行回调函数。

- 需要大量修改 DOM 时使用 `DocumentFragment` 避免重复多次的页面渲染。

  使用类似 node.appendChild() 这种方法对 DOM 进行修改时，这个方法是无缓冲的，也就是说我们每次调用 appendChild 方法的时候，浏览器都会重新渲染页面。如果只是对少量的 DOM 节点进行更新，并不会带来太大的性能问题，但是如果大量的更新 DOM 节点，浏览器要不停的渲染页面，那么性能的差距就会越来越明显了。

  JavaScript 中提供了一个 [DocumentFragment](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment) 的机制，它可以提供一个缓冲的机制，将构造的 DOM 节点先放到内存中，当节点都构造完成后，再将 DocumentFragment 对象添加到页面中，所有的节点都会一次渲染出来，从而减少浏览器很多的负担，明显的提高页面渲染速度。
  ```javascript
  function CreateNodes() {    
      for(var i = 0;i < 10000;i++) {
          var tmpNode = document.createElement("div");
          tmpNode.innerHTML = "test" + i + " <br />";
          document.body.appendChild(tmpNode);
      }
  }
  // 使用 DocumentFragment 改写为
  function CreateFragments() {
      var fragment = document.createDocumentFragment();
      for(var i = 0;i < 10000;i++) {
          var tmpNode = document.createElement("div");
          tmpNode.innerHTML = "test" + i + "<br />";
          fragment.appendChild(tmpNode);
      }
      document.body.appendChild(fragment);
  }
  ```

## 4. Refer Links

[阮一峰：网页性能管理详解](http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html)

[JavaScript Tips - 使用 DocumentFragment 加快 DOM 渲染速度](https://www.cnblogs.com/springfield/archive/2010/06/27/1765589.html)