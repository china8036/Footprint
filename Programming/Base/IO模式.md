- [I/O 模式](#io-模式)
  - [1. 基本概念](#1-基本概念)
    - [1.1. 阻塞和非阻塞](#11-阻塞和非阻塞)
    - [1.2. 同步和异步](#12-同步和异步)
  - [2. IO 模式](#2-io-模式)
    - [2.1. Reactor 模式](#21-reactor-模式)
    - [2.2. Proactor 模式](#22-proactor-模式)
    - [2.3. Actor 模式](#23-actor-模式)
  - [3. Refer Links](#3-refer-links)

# I/O 模式

<!-- TODO: -->

## 1. 基本概念

IO 操作实际上可以分为两步：
1. 发起 IO 请求（即查询目标资源就绪状态）。
1. 实际的 IO 操作（即从内核向进程复制数据）。

### 1.1. 阻塞和非阻塞

**如果在第一步发起 IO 请求时发生阻塞，那么这个 IO 就可以说阻塞的，否则是非阻塞的**。

阻塞和非阻塞描述的是用户线程调用内核 IO 操作的方式，是指在用户程序查询 IO 就绪状态时（比如查询 IO 是否有数据），用户程序对 IO 不同的就绪状态所表现出来的不同形式。以读取数据为例，当 IO 没有数据可供读取时，如果是阻塞 IO，程序会一直阻塞直至 IO 有数据，如果是非阻塞 IO，程序会直接返回错误码说当前没有数据，请稍后再来查询。

你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟 check 一下老板有没有返回结果。

### 1.2. 同步和异步

**如果在第二步实际 IO 操作时发生阻塞，那么这个 IO 就是同步的，否则就是异步的**。

同步和异步描述的是用户线程与内核的交互方式，是由在进行实际的 IO 操作时，用户程序是否等待数据操作完成来决定。还是以读取数据为例，如果是同步 IO，用户程序会等待读取数据完成，在此期间这个线程什么也不做，如果是异步 IO，用户程序可以去作别的事情，内核在完成数据读取后，会以回调的方式通知用户程序。

你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是 5 秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

NOTE: **在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API ( 如 POSIX 的 aio_* 系列函数 ) 才是异步 IO**。

![image](http://img.cdn.firejq.com/jpg/2018/6/1/cb68a4980c64f35d6358a290ffbf26e4.jpg)

## 2. IO 模式

### 2.1. Reactor 模式

TODO:

https://pdfs.semanticscholar.org/3d9f/fc7669ab488ea74841181e9b1be9d10d5cea.pdf

Reactor 实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应。适用于同时接收多个服务请求，并且依次**同步**的处理它们的事件驱动程序。

一般过程：
1. 向事件分发器注册事件回调
1. 事件发生
1. 事件分发器调用之前注册的函数
1. 在回调函数中读取数据，对数据进行后续处理

eg: Reactor 将 handle 放到 select()，等待可写就绪，然后调用 `write()` 写入数据，写完处理后续逻辑。

Reactor 模型实例：libevent/libev/libuv/Event Library in Redis/ACE/Select/Epoll/ZeroMQ。

优点：
- Reactor 实现相对简单，对于耗时短的处理场景处理高效。
- 操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性。
- 事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁。
- 事务分离，将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来。

缺点：
- Reactor 处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理。

### 2.2. Proactor 模式

TODO:

https://www.dre.vanderbilt.edu/~schmidt/PDF/proactor.pdf

Proactor 实现了一个主动的事件分离和分发模型，这种设计允许多个任务并发的执行，从而提高吞吐量，且可执行耗时长的任务（各个任务间互不影响）。适用于**异步**接收和同时处理多个服务请求的事件驱动程序。

一般过程：
1. 向事件分发器注册事件回调
1. 事件发生
1. **操作系统读取数据，并放入应用缓冲区，然后通知事件分发器**
1. 事件分发器调用之前注册的函数
1. 在回调函数中对数据进行后续处理

e.g. Proactor 调用 aoi_write 后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑。

Proactor 模型实例：Boost.Asio/IOCP。

优点：
- 相比 Reactor，Proactor 性能更高，能够处理耗时长的并发场景。

缺点：
- Proactor 实现逻辑复杂，依赖操作系统对异步的支持，但目前实现了纯异步操作的操作系统少，如 windows IOCP，但由于其 windows 系统用于服务器的局限性，目前应用范围较小；而 Unix/Linux 系统对纯异步的支持有限，因此应用事件驱动的主流还是通过 select/epoll 来实现。

### 2.3. Actor 模式

TODO:

http://www.yeolar.com/note/2012/12/15/io-design-patterns/

Actor 模型是一个概念模型，被称为高并发事务的终极解决方案。它定义了一系列系统组件应该如何动作和交互的通用规则，实体之通过消息通讯，各自处理自己的数据，适用于处理并发计算的场景。

Actors 一大重要特征在于 actors 之间相互隔离，它们并不互相共享内存。这点区别于上述的对象。也就是说，一个 actor 能维持一个私有的状态，并且这个状态不可能被另一个 actor 所改变。

```
Actor 模型 = 数据 + 行为 + 消息。
```

**Actor 模型内部的状态由自己的行为维护，外部线程不能直接调用对象的行为，必须通过消息才能激发行为，这样就保证 Actor 内部数据只有被自己修改**。

Proactor 模型实例：Erlang/Skynet/Akka/[Ray](https://ray.readthedocs.io/en/latest/walkthrough.html#remote-classes-actors)。

## 3. Refer Links