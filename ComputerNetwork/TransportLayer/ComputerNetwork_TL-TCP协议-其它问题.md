- [计算机网络 - 传输层：Transport control protocol 其它问题](#计算机网络---传输层transport-control-protocol-其它问题)
  - [1. TCP 分段 (TCP Segment)](#1-tcp-分段-tcp-segment)
    - [1.1. MSS](#11-mss)
    - [1.2. TCP 分段](#12-tcp-分段)
  - [2. TCP KeepAlive 机制](#2-tcp-keepalive-机制)
    - [2.1. TCP 断连问题](#21-tcp-断连问题)
    - [2.2. 基本原理](#22-基本原理)
    - [2.3. KeepAlive 缺陷](#23-keepalive-缺陷)
    - [2.4. TCP KeepALive 与应用层心跳](#24-tcp-keepalive-与应用层心跳)
  - [3. Linux 下单机 TCP 连接的最大并发量](#3-linux-下单机-tcp-连接的最大并发量)
    - [3.1. 理论最大并发量](#31-理论最大并发量)
    - [3.2. 实际最大并发量](#32-实际最大并发量)
  - [4. TCP 拆包粘包问题](#4-tcp-拆包粘包问题)
    - [4.1. 问题描述](#41-问题描述)
    - [4.2. 解决方法](#42-解决方法)
  - [5. TCP 半开连接问题](#5-tcp-半开连接问题)
    - [5.1. 问题描述](#51-问题描述)
    - [5.2. 处理方案](#52-处理方案)
  - [6. TCP 与 UDP 的区别](#6-tcp-与-udp-的区别)
  - [7. TCP 协议是如何保证可靠传输的？](#7-tcp-协议是如何保证可靠传输的)
  - [8. TCP 协议是如何防止数据被篡改的？](#8-tcp-协议是如何防止数据被篡改的)
  - [9. TCP 协议的缺陷？](#9-tcp-协议的缺陷)
  - [10. Refer Links](#10-refer-links)

# 计算机网络 - 传输层：Transport control protocol 其它问题

## 1. TCP 分段 (TCP Segment)

### 1.1. MSS

最大分段大小 (Maximum Segment Size, MSS) 是指 TCP 数据包每次能够传输的最大数据分段（不包括 TCP Header），单位为字节。

```
                         _____________MTU______________          
                        |                              |
--------------------------------------------------------
| MAC 头 14 字节 | IP 头 20 字节 | TCP 头 20 字节 | 数据 |
--------------------------------------------------------
                                                |      |
                                                ---MSS--
```

TCP 协议中 MSS 的计算方法：
> MSS = MTU - IP Header - TCP Header
eg:
- 以太网 MSS = 1500 - 20 -20 = 1460 bytes. 
- IEEE 802.3/802.2 MSS = 1492 - 20 - 20 = 1452 bytes.

### 1.2. TCP 分段

TCP 如何避免 IP 分片？

为避免 IP 分片，达到最佳的传输效能，TCP 会先进行 MSS 协商，并对超过 MSS 的数据流进行 TCP 分段。

- MSS 协商

  TCP 协议在建立连接的时候通常先要协商双方的 MSS 值，通讯双方会根据双方提供的 MSS 值的最小值确定为这次连接的 MSS 值。

  TCP 在三次握手的第一个 SYN 消息中有一个选项 option 4，通告双方的 MSS，并会选择较小的一方作为这个 TCP 连接的协定 MSS，即 MSS = minimum{MSSs, MSSr}。从而使得双向通信都可以避免因为 IP 包太大引起的分片。
  
  但实际上，MSS 协商只能解决源主机、目的主机之间 first hop 的 MTU 问题，可以保证第一跳不分片，但是不能克服路径中有更小的 MTU 而造成的分片（但这是少数情况）。

- TCP 分段

  - 一旦传递给 TCP 层的数据流超过了 MSS，则在传输层会对 TCP 包进行分段，以避免在 IP 层发生分片行为。通过 TCP 分段，TCP 将通信过程中发生 IP 分片的机会大幅度降低。
  - 而对于 UDP / ICMP 协议，由于不具备分段机制，因此只能由 IP 层进行 IP 分片。
    - 在普通的局域网环境下，UDP 的数据最大为 1472 字节最好（避免分片重组）。
    - Internet 中的路由器可能有设置成不同的值（小于默认值），Internet 上的标准 MTU 值为 576，所以 Internet 的 UDP 编程时数据长度最好在 576－20－8＝548 字节以内。
  

## 2. TCP KeepAlive 机制

### 2.1. TCP 断连问题

[TCP 连接断连问题剖析](https://www.ibm.com/developerworks/cn/aix/library/0808_zhengyong_tcp/index.html)

[网络编程释疑之：TCP 连接拔掉网线后会发生什么](http://blog.51cto.com/yaocoder/1589919)

> 当客户端与服务器建立起正常的 TCP 连接后，如果客户主机掉线（网线断开、电源掉电、或系统崩溃等），服务端进程将永远不会知道（通过常用的 select/epoll 都监测不到断开或错误事件）。

因此，如果在 Server-Client 已建立了长连接的期间，断开客户端与服务器的物理连接，可能存在以下情况：

- 如果断开的时间短暂，在服务端 SO_KEEPALIVE 设定的探测时间间隔内，并且两端在此期间没有任何针对此长连接的网络操作，也就是说断开期间不足以让服务端“发现”客户端的连接出错了。因此，当连上网线后此 TCP 连接可以自动恢复，继续进行正常的网络操作。

- 如果断开的时间很长，超出了 SO_KEEPALIVE 设定的探测时间间隔，或者两端期间在此有了任何针对此长连接的网络操作，也就是说断开期间服务端“发现”了客户端的连接出错了，于是服务端会抛弃这个连接。因此，当连上网线时就会出现 ETIMEDOUT 或者 ECONNRESET 的错误，必须重新建立一个新的长连接进行网络操作。

### 2.2. 基本原理

由于 TCP 断连问题，在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费。

为解决这个问题，在传输层 TCP 提供了 [KeepAlive 机制](http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/)，主流的操作系统内核都支持了这个机制的实现。

TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。

HTTP 应用层协议中的 KeepAlive 字段就是基于 TCP 的这个机制实现的，且几乎所有的浏览器都默认会使用 TCP 的这个机制，重用一个 TCP 连接来处理多个 HTTP 请求，然后让客户端去断链接（浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。

### 2.3. KeepAlive 缺陷

TCP KeepAlive 机制主要存在以下 2 个问题：

- TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量。

- TCP KeepAlive 检查不到机器断电、网线拔出、防火墙这些断线情况，只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。本质上来说，KeepAlive 是用来检测长时间不活跃的连接的，所以，不适合用来及时检测连接的状态。
  
  例如，当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，但 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值相对较小，**需要做连接保活的应用层程序（例如 QQ 等长连接需求的程序），一般需要在应用层实现自己的心跳检测和保活功能，并在获知了断线之后，可以按照服务器逻辑进行相应操作（如断线后的数据清理、重新连接等）。**。

  <!-- [既然 TCP 中有心跳检测（KeepAlive 机制）了，为什么还要在应用层做心跳检测？](https://www.cnblogs.com/1wen/p/5808276.html ) -->

  <!-- 回答：https://blog.coderzh.com/2015/03/05/WhyHeartBeatNeeded/  -->

  <!-- http://blog.csdn.net/hengyunabc/article/details/44310193 -->

  <!-- [服务端主动发送心跳包，还是客户端发送比较好？](https://www.zhihu.com/question/35896874) -->

### 2.4. TCP KeepALive 与应用层心跳

**心跳包机制一般两种：TCP 自带的 keep-alive 和应用层的心跳包探活。**那到底使用 tcp 的 keep-alive 还是应用层自己实现的心跳机制呢？

- TCP KeepALive 机制占用带宽少，不用开发人员实现。但在有代理的网络下，不一定能探活到服务器，除非反向代理也有相应的心跳机制。
- 应用层心跳能携带更多状态，但需要开发人员自己实现。

## 3. Linux 下单机 TCP 连接的最大并发量

### 3.1. 理论最大并发量

在 TCP 应用中，Server 事先在某个固定端口监听，Client 主动发起连接，经过三路握手后建立 TCP 连接。系统用一个 4 四元组来唯一标识一个 TCP 连接：`{local ip, local port,remote ip,remote port}`。

- Client 端最大 TCP 并发量

  Client 每次发起 TCP 连接请求创建 Socket 时，除非绑定指定的端口，否则系统会自动选取一个空闲的本地端口（local port）。该端口是独占的，不能和其它 TCP 连接共享，因此，Client 端的 TCP 连接数取决于可用的端口数量。

  TCP 端口的数据类型是 unsigned short，因此本地端口个数最大为 65536，端口 0 有特殊含义不能使用，即可用的端口最多为 65535。所以在全部作为 TCP Client 端的情况下，一个 client 最大 TCP 连接数为 65535，这些连接可以连到不同的 Server ip。

- Server 端最大 TCP 并发量

  虽然现在的集群，分布式技术可以为我们将并发负载分担在多台服务器上，那我们只需要扩展出数十台电脑就可以解决问题，但是我们更希望能更大的挖掘单台服务器的资源，先努力垂直扩展，再进行水平扩展，这样可以有效的节省服务器相关的开支（硬件资源，机房，运维，电力其实也是一笔不小的开支）。那么到底一台服务器能够支持多少 TCP 并发连接呢？

  Server 通常固定在某个本地端口上监听，等待 Client 的连接请求。不考虑地址重用（unix 的 SO_REUSEADDR 选项）的情况下，即使 Server 端有多个 ip，本地监听端口也是独占的，因此 Server 端的 TCP 连接 4 元组中，只有 remote ip (Client ip) 和 remote port (Client port) 是可变的。也就是说，最大 TCP 连接并发量为 `number of Client ip * number of Client port`。

  对于 IPv4，不考虑 ip 地址分类等因素，最大 TCP 连接数为 `2^32 (number of Client ip) * 2^16 (number of Client port)`，也就是 Server 端单机最大 TCP 连接数约为 `2^48`。

### 3.2. 实际最大并发量

- 文件句柄限制

  在 Linux 中每个 TCP 连接都需要占用一个文件描述符，一旦所有文件描述符都被占用，新的连接到来时会返回错误 `Socket/File:Can't open so many files`。因此，操作系统的文件句柄限制，是实际应用中影响 TCP 连接并发量的因素之一。

  - 进程限制

    执行 `ulimit -n` 输出 1024，说明对于一个进程，默认情况下最多只能打开 1024 个文件，所以如果采用默认配置，最多也就可以并发上千个 TCP 连接。

    - 临时修改：`ulimit -n 1000000`，但是这种临时修改只对当前登录用户目前的使用环境有效，系统重启或用户退出后就会失效。

    - 永久修改：编辑 `/etc/security/limits.conf` 文件， 修改后内容为
      ```
      * soft nofile 1000000
      * hard nofile 1000000
      ```
      或编辑 /etc/rc.local，在其后添加如下内容
      ```
      ulimit -SHn 1000000
      ```

  - 全局限制

    执行 `cat /proc/sys/fs/file-nr` 输出 `9344 0 592026`，含义分别为：
    - 已经分配的文件句柄数。
    - 已经分配但没有使用的文件句柄数。
    - 最大文件句柄数。
    
    可通过修改 /etc/sysctl.conf 文件来增大最大文件句柄数：
    ```
    fs.file-max = 1000000
    net.ipv4.ip_conntrack_max = 1000000
    net.ipv4.netfilter.ip_conntrack_max = 1000000
    ```

- 内存限制

  每个进程 / 线程都需要占用一定的内存。

- 带宽限制

## 4. TCP 拆包粘包问题

### 4.1. 问题描述

- UDP 是基于报文发送的，从 UDP 的帧结构可以看出，在 UDP 首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。
- TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界。另外从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。

### 4.2. 解决方法

粘包与拆包是由于 TCP 协议是字节流协议，没有记录边界所导致的，所以如何确定一个完整的业务包就由应用层来处理了。
（这就是分包机制，本质上就是要在应用层维护消息与消息的边界）
分包机制一般有两个通用的解决方法：
- 特殊字符控制，例如 FTP 协议。
- 在包头首都添加数据包的长度，例如 HTTP 协议。

## 5. TCP 半开连接问题

### 5.1. 问题描述

当客户端与服务器建立起正常的 TCP 连接后，如果客户主机掉线（网线断开、电源掉电、或系统崩溃等），服务端进程将永远不会知道（通过常用的 select/epoll 都监测不到断开或错误事件），如果不主动处理或重启系统的话对于服务端来说会一直维持着这个连接，这种情况就是半开连接，浪费了服务器端可用的文件描述符。

### 5.2. 处理方案

- 利用操作系统在传输层进行心跳检查

  TCP Socket 的系统 API 中存在保持存活的选项 SO_KEEPALIVE，通过设置该参数，如果在两个小时之内在该套接字的任何一个方向上都没数据交换，TCP 就自动给对端发送一个保持存活探测分节，如果此 TCP 探测分节的响应为 RST，说明对端已经崩溃且已经重新启动，该套接字的待处理错误被置为 ECONNRESET，套接字本身则被关闭。如果没有对此 TCP 探测分节的任何响应，该套接字的处理错误就被置为 ETIMEOUT，套接字本身则被关闭。

  这样确实可以处理 TCP 半开连接的问题，但是该方式存在以下问题：
  - 大多数内核是基于整个内核而不是基于每个套接字维护这些时间参数的，因此如果把无活动周期从两小时改为（比如）2 分钟，那将影响到该主机上所有开启了此选项的套接字。
  - SO_KEEPALIVE 由操作系统负责探查，因此即便是进程死锁或有其他异常，操作系统也会正常收发 TCP keepalive 消息，而对方无法得知这一异常。在这种情况下，SO_KEEPALIVE 参数明显失去了心跳检测应有的作用。

- 在应用层自己实现心跳检测

  可以在应用层模拟 SO_KEEPALIVE 的方式，用心跳包来模拟保活探测分节，例如[使用 libevent 进行检测](http://blog.51cto.com/yaocoder/1349003)。

  由于服务器通常要承担成千上万的并发连接，所以可以将心跳逻辑部署在客户端，由客户端在应用层进行心跳来模拟保活探测分节。
  - 客户端发送心跳包后，若多次收不到服务器的响应，则说明与此次连接产生了问题，因此可终止此 TCP 连接。
  - 服务端可监测所有客户端的 Socket 连接，若在一定时间间隔内未收到来自某个客户端的任何心跳包，则可以终止此 TCP 连接，这样就有效避免了 TCP 半开连接的情况。

## 6. TCP 与 UDP 的区别

- TCP 是面向连接的，UDP 是无连接的。

- TCP 是面向数据流的协议，UDP 是面向数据报的协议。

  TCP 的分包 / 粘包问题也就是 TCP 协议的“流”特性造成的。

  假设客户端一次完全发送这么一串字符 str = "hello world!"到服务端，在服务端一次 read，并且 read 长度的参数大于 strlen(str) 的情况下，用 TCP 和 UDP 协议会有什么区别？

  在网络没有出问题的情况下，根据系统内核的套接字缓冲区是否充足：
  - 用 UDP 协议发送的话，在服务端要么是什么也收不到；要么是全部收到了"hello world!"这个字符串。
  - 用 TCP 协议发送的话，有可能一次 read 只是得到了"hello world!"的部分字符，经过多次 read 累积缓冲区才能收到整个字符串；有可能一次全部收到。

  举一个例子类比一下，我们要把一个空碗接满水，我们可以一次倒入也可以分多次倒入。但是我们要把一个馒头完整的放进另一个碗中，你的选择只有放一次，要么放得下要么放不下。

- TCP 是可靠的，而 UDP 是不可靠的，尽最大努力交付。

- TCP 有拥塞控制机制，而 UDP 没有拥塞控制。因此网络出现拥塞时 UDP 不会使源主机的发送速率降低（这对实时应用很有用，如 IP 电话、实时视频会议等）。

- TCP 连接只能是点对点的，而 UDP 协议支持一对一、一对多、多对一和多对多的交互通信。

- TCP 首部开销 20 字节，而 UDP 的首部只有 8 个字节，网络开销较小。

## 7. TCP 协议是如何保证可靠传输的？

可靠传输 (Reliable Transmission) 是相对于 UDP 不可靠传输来说的，指在常见的丢包、乱序的条件下依然可以保证数据被顺序接受，中间不丢数据，即需要保证数据确实到达目的地；如果未到达，能够发现并重传。

措施：
- 序列号和确认号
- 滑动窗口
- 重传机制

## 8. TCP 协议是如何防止数据被篡改的？

错误检测 (Error Detection) 用于验证数据是否被篡改、伪造。

措施：对于 TCP 协议而言，错误检测仅靠 TCP 段头部的一个 16 bit 的字段：校验和 checksum 来完成。这种校验非常弱，规则都是透明的，同时篡改数据内容和校验数即可绕过。因此，**TCP 无法真正防止数据被篡改**。

在 TCP 之外，要防止数据被篡改可以通过以下措施：
- 加密。没有密钥的第三方即使拿到数据包也无法还原成有意义的内容，更无法修改替换。
- 身份认证。防止双方从最开始就被中间人两头骗，SSL/TLS 是一个比较成熟通用的解决方案。

## 9. TCP 协议的缺陷？

- TCP 的流控算法不能很好的适应高带宽高延迟的场景。由于延迟确认机制的存在，ACK 不能及时送达，导致传输速度远低于理论的传输带宽。

- TCP 的拥塞控制算法是基于丢包的，是否发生了丢包是判断网络是否拥塞的唯一依据，但 TCP 由于对网络了解的很片面，无法分辨丢包是什么原因造成的，不能很好的适应网络不太稳定的场景：
  - 网络真的拥堵而丢包，这种情况 TCP 流量控制可以很好的起效果。
  - 线路质量差 CRC 校验失败丢、或信号干扰丢，这种情况 TCP 流量控制不起作用。
  - IP 包乱序而引起的误判，这种情况 TCP 流量控制也不起作用。

  例如在无线网络中，TCP 的拥塞控制认为丢包是因为网络传输饱和，所以一旦出现丢包就采取指数级避让，而无线网络因为短暂的信号干扰导致的丢包并不是因为网络传输饱和，此时采取指数级避让是不合适的，会导致无线传输的速度骤降。

  关于这点已经有很多改进的算法了，比如基于带宽实时测量的 Google BBR 算法。

- 事实上，TCP 协议的许多缺陷都通过 TCP option 在不断地打着补丁：
  - Scaling window 应对长肥管道。
  - Selective ACK 应对高丢包率场景。
  - Timestamp 应对序列号回滚、RTT 测量的精度。
  - Authentication Option 应对数据完整性挑战。
  - TCP Cookie 应对 SYN Flooding DOS 攻击。
  - FAST TCP Open 应对 TCP 传输数据延时大。

## 10. Refer Links

[网络编程释疑之：TCP 协议的“流”特性](http://blog.51cto.com/yaocoder/1339958)

[TCP 半开连接问题](http://blog.51cto.com/yaocoder/1309358)

[关于应用层解决拆包粘包问题？](https://www.zhihu.com/question/37023914)

[TCP 粘包，拆包及解决方法](https://blog.insanecoder.top/tcp-packet-splice-and-split-issue/)

[Linux 中，一个端口能够接受 TCP 连接数的理论上限是？](https://www.nowcoder.com/questionTerminal/997f45dddc9b4c8ea7da76288aa439d1)

[单机最大 tcp 连接数](http://wanshi.iteye.com/blog/1256282)

[单台服务器上的并发 TCP 连接数可以有多少？](http://blog.51cto.com/yaocoder/1312821)

[The C10K problem](http://www.kegel.com/c10k.html)

[tcp 的可靠性到底指的是什么？](https://www.zhihu.com/question/49596182)

[TCP 协议存在那些缺陷？](https://www.zhihu.com/question/47560918)

[TCP 和 Udp 的区别是什么？](https://www.zhihu.com/question/47378601)

<!-- todo: -->
[TCP 协议专场问题](https://zhuanlan.zhihu.com/p/30032980)