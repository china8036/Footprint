- [HTTPS](#https)
  - [1. 发展历史](#1-发展历史)
  - [2. 运行过程](#2-运行过程)
    - [2.1. 握手阶段](#21-握手阶段)
      - [2.1.1. 客户端发出请求（ClientHello）](#211-客户端发出请求clienthello)
      - [2.1.2. 服务器回应（SeverHello）](#212-服务器回应severhello)
      - [2.1.3. 客户端回应](#213-客户端回应)
      - [2.1.4. 服务器的最后回应](#214-服务器的最后回应)
    - [2.2. 加密通信](#22-加密通信)
  - [3. Refer Links](#3-refer-links)

# HTTPS

> 电子前哨基金会 (Electronic Frontier Foundation) 曾经建议“在理想的世界中，任何网络请求都能默认为 HTTPS 的”。

超文本传输安全协定 (Hypertext Transfer Protocol Secure，HTTPS)，常称为 HTTP over TLS，HTTP over SSL 或 HTTP Secure，是一种通过计算机网络进行安全通讯的传输协议。HTTPS 经由 HTTP 进行通讯，但利用 SSL/TLS 来加密封包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换资料的隐私与完整性。

**严格地讲，HTTPS 并不是一个单独的协议，而是对工作在加密连接（SSL/TLS）上的常规 HTTP 协议的称呼**。

HTTPS 报文中的任何东西都被加密，包括所有报头和荷载。除了可能的选择密文攻击之外，攻击者所能知道的只有在两者之间有连接存在这一事实。

## 1. 发展历史

网景公司（Netscape）在 1994 年首次提出了 HTTPS，并应用在网景导航者浏览器中。最初，HTTPS 是与 SSL 一起使用的；在 SSL 逐渐演变到 TLS 时，最新的 HTTPS 也由在 2000 年五月公布的 RFC 2818 正式确定下来。

互联网加密通信协议的历史，几乎与互联网一样长。

**1994 年，NetScape 公司首次设计了 SSL 协议（Secure Sockets Layer）的 1.0 版，但是未发布**。

1995 年，NetScape 公司发布 SSL 2.0 版，很快发现有严重漏洞。

1996 年，SSL 3.0 版问世，得到大规模应用。

**1999 年，互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS(Transport Layer Security) 1.0 版**。

2006 年和 2008 年，TLS 进行了两次升级，分别为 TLS 1.1 和 TLS 1.2，最新的变动是 2018 年 TLS 1.3 的修订版。由于 TLS 是 SSL 升级而来，因此 TLS 1.0 也被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3。

目前，应用最广泛的是 TLS 1.0，但主流浏览器都已经实现了 TLS 1.2 的支持。

## 2. 运行过程

SSL/TLS 协议的基本过程是这样的：
1. 双方握手阶段：
  1. 客户端向服务器端索要并验证公钥。
  1. 双方协商生成"对话密钥"。
1. 双方采用"对话密钥"进行加密通信。

### 2.1. 握手阶段

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/10/7/abc7d6868c0f7f1f5d908333df6e2b53.jpg)

#### 2.1.1. 客户端发出请求（ClientHello）

首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello 请求。

在这一步，客户端主要向服务器提供以下信息：

- 支持的协议版本，比如 TLS 1.0 版。
- 客户端生成的第一个随机数，稍后用于生成"对话密钥"。
- 支持的加密方法，比如 RSA 公钥加密。
- 支持的压缩方法。

#### 2.1.2. 服务器回应（SeverHello）

服务器收到客户端请求后，向客户端发出回应，这叫做 SeverHello。服务器的回应包含以下内容：

- 确认使用的加密通信协议版本，比如 TLS 1.0 版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
- 服务器生成的第一个随机数，稍后用于生成"对话密钥"。
- 确认使用的加密方法。**握手阶段默认使用 RSA 算法，但也可使用 Diffie-Hellman 算法**。
- 服务器证书。证书至少包含了以下内容：
  - 服务器公钥
  - 服务器专有名称
  - 证书的发布机构，即颁发证书的 CA 的专有名称
  - 证书生效的起始日期
  - 证书的到期日期
  - **序列号**。这是颁发证书的 CA 所分配的唯一标识，也就是说，序列号在颁发证书的 CA 中是唯一的，同一 CA 证书签署的两个证书不会具有相同的序列号。

除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供 USB 密钥，里面就包含了一张客户端证书。

#### 2.1.3. 客户端回应

客户端收到服务器回应以后，首先验证服务器证书：

如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

如果证书没有问题，**客户端就会从证书中取出服务器的公钥**。然后，向服务器发送下面三项信息：

- 客户端生成的第二个随机数。**该随机数用服务器公钥加密，防止被窃听**。这是整个握手阶段出现的第三个随机数，又称"pre-master key"。
- **编码改变通知**，表示随后的信息都将用双方商定的加密方法和密钥发送。
- **客户端握手结束通知**，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务器校验。
- 如果上一步中，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。

至此，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。

- P.S. 那么为什么一定要用三个随机数，来生成"会话密钥"呢？

  不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于 SSL 协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。

  对于 RSA 密钥交换算法来说，pre-master-key 本身就是一个随机数，再加上 hello 消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。

  pre master 的存在在于 SSL 协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么 pre master secret 就有可能被猜出来，那么仅适用 pre master secret 作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上 pre master secret 三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一点。

#### 2.1.4. 服务器的最后回应

服务器收到客户端的第三个随机数 pre-master key 之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息：

- **编码改变通知**，表示随后的信息都将用双方商定的加密方法和密钥发送。
- **服务器握手结束通知**，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验。

至此，整个握手阶段全部结束。

### 2.2. 加密通信

接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用"会话密钥"加密内容。

## 3. Refer Links

《图解 HTTP》

[RFC 5246 TLS 协议](https://tools.ietf.org/html/rfc5246)

[阮一峰：SSL/TLS 协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)

[阮一峰：图解 SSL/TLS 协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)

[阮一峰：SSL 延迟有多大？](http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html)

[阮一峰：HTTPS 升级指南](http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html)
