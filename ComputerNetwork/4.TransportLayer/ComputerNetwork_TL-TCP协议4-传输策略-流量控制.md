- [计算机网络 - 传输层：Transport control protocol 传输策略：流量控制](#计算机网络---传输层transport-control-protocol-传输策略流量控制)
  - [1. 相关字段](#1-相关字段)
  - [2. 基本原理](#2-基本原理)
  - [3. 作用](#3-作用)
    - [3.1. 提供面向流的可靠性](#31-提供面向流的可靠性)
    - [3.2. 提供流量控制](#32-提供流量控制)
    - [3.3. 解决延迟确认问题](#33-解决延迟确认问题)
  - [4. Refer Links](#4-refer-links)

# 计算机网络 - 传输层：Transport control protocol 传输策略：流量控制

流量控制指的是防止一个发送能力较强的发送端的数据将一个接收能力较差的接收端“淹没”的控制措施。

**TCP 流量控制是通过一个可变大小的滑动窗口 (Sliding Window) 来实现的**，除此之外，TCP 协议本身的操作都是围绕滑动窗口协议来进行的，因此：

> 如果你不了解 TCP 的滑动窗口这个事，你等于不了解 TCP 协议。

## 1. 相关字段

TCP 段中窗口的相关字段：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/6/15/c003e446f4caaff25b0a564033662896.jpg)

**TCP 的 Window 是一个 16bit 位字段，它代表的是窗口的字节容量，也就是 TCP 的标准窗口最大为 2^16-1=65535 个字节**。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

另外在 TCP 的选项字段中还包含了一个 TCP 窗口扩大因子，option-kind 为 3，option-length 为 3 个字节，option-data 取值范围 0-14。窗口扩大因子用来扩大 TCP 窗口，可把原来 16bit 的窗口，扩大为 31bit。

## 2. 基本原理

TCP 的滑动窗口分为接收窗口和发送窗口：
- 发送窗口

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/6/15/fce737911a5228e54a0cd401e1fd98d1.jpg)

  对于 TCP 会话的发送方，任何时候在其发送缓存内的数据都可以分为 4 类：
  - 已经发送并得到对端 ACK 的：数据流中最早的字节已经发送并得到确认。
  - 已经发送但还未收到对端 ACK 的：发送方在确认之前，不认为这些数据已经被处理。
  - 未发送但对端允许发送的：设备尚未将数据发出，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间，发送方会立即尝试发送。
  - 未发送且对端不允许发送：由于接收方 not ready，还不允许将这部分数据发出。
  其中，“已经发送但还未收到对端 ACK 的”和“未发送但对端允许发送的”这两部分数据结合起来就称为发送窗口。

  当收到接收方新的 ACK（对于发送窗口中后续字节的确认）时，窗口向后至 ACKnum。例：收到 ACKnum=36 时：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/6/15/fbf0312af887af483a60b290c347b733.jpg)

  **发送窗口的大小取决于 TCP 连接对方通告的接收窗口大小，要求两者保持相同**。

- 接收窗口

  对于 TCP 的接收方，在某一时刻在它的接收缓存内存在 3 种：
  - 已接收
  - 未接收准备接收
  - 未接收并未准备接收
  - （由于 ACK 直接由 TCP 协议栈回复，默认无应用延迟，不存在“已接收未回复 ACK”）
  其中，“未接收准备接收”部分就称为接收窗口，用于向对端通知本地希望一次接收多少字节的数据。

  接收窗口大小取决于应用、系统、硬件的限制（TCP 传输速率不能大于应用的数据处理速率）。

- 关系

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/6/15/eb21c6b4a08419d2f193f88fa8828766.jpg)

  **TCP 是双工的协议，会话的双方都可以同时接收、发送数据。因此，TCP 会话的双方都各自维护一个发送窗口和一个接收窗口**。

## 3. 作用

### 3.1. 提供面向流的可靠性

  - TCP 最基本的传输可靠性来源于“确认重传”机制，事实上 TCP 的滑动窗口的可靠性也是建立在“确认重传”基础上的。
  
  - 发送窗口**只有收到对端对于本段发送窗口内字节的 ACK 确认，才会移动发送窗口的左边界。**
  
  - 接收窗口只有在前面所有的段都确认的情况下才会移动左边界。**假设在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认，以此确保对方在未接收到 ACK 导致计时器超时后会对这些数据重传。**

    但存在一个缺陷是：因为它不会对每一个片段分别进行确认，这可能会导致其他实际上已经接收到的片段被重传。

### 3.2. 提供流量控制

  在于基本的滑动窗口机制中，数据于接收时确认，但并不一定立即从缓存中传输出去。也就意味着当接收数据速度快于接收 TCP 处理速度时，缓存有可能被填满。因此，当这一情况发生时，接收设备需要调整窗口大小已防止缓存过载。

  窗口大小能够以这种方式管理连接两端设备数据流的速率，实际上 TCP 就是通过这种方式实现传输层流量控制任务的，即通过增加或缩小窗口大小，服务器和客户端能够确保对端发送数据的速度等同于处理速度。

  应用程序在需要（如内存不足）时，通过 API 通知 TCP 协议栈缩小 TCP 的接收窗口。然后 TCP 协议栈在下个段发送时包含新的窗口大小通知给对端，对端按通知的窗口来改变发送窗口，以此达到减缓发送速率的目的。

### 3.3. 解决延迟确认问题

TCP 是面向数据流的协议，它将独立的字节数据当作流来处理。但实际上，一次发送一个字节并接收一次确认显然是不可行的，即使重叠传输（即不等待确认就发送下一个数据），速度也还是会非常缓慢。因此，**为提高速度，TCP 实现采用了延迟确认的机制，即将确认和窗口更新延迟 50 毫秒，以获得一些数据免费搭载过去**。

尽管通过延迟确认减少了接收端对网络的负载，但发送端总发送多个小数据包的方式仍非常低效。在这种模式下，可能会出现 Silly Window Syndrome （低能窗口综合症）。即如果接收方来不及取走 Receive Windows 里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的 window，而我们的发送方会义无反顾地发送这几个字节。

- Nagle 算法

  Nagle’s algorithm 是针对 sender 端的解决方法。它的思路非常简单：当数据每次以很少量的方式进入发送端时，发送端只是发送第一次到达的数据，然后将其它的字节缓冲起来，直到发送出去的那个数据包被确认，才将所有缓冲的字节放在一个 TCP 段中发送出去，并继续缓冲后续到达的字节，直到下一个段被确认。

  **Nagle 算法默认是打开的**，所以，对于一些需要小包场景的程序，如 telnet 或 ssh 这样的交互性比较强的程序，需要手动关闭这个算法。可以在 Socket 设置 `TCP_NODELAY` 选项来关闭这个算法。

  P.S. 参数 `TCP_CORK` 是更激进的 Nagle 算法，它完全禁止了小包发送，而参数 `TCP_NODELAY` 指定的 Nagle 算法没有禁止小包发送，只是禁止了大量的小包发送。

- Clark 方案

  David D Clark’s 方案是针对 receiver 端的解决方法。它的思路是禁止 receiver 端发送只有 1 个字节的窗口更新段，强制 receiver 端必须等待一段时间，直到有了一定数量的可用空间后再通告 sender 端。

**Nagle 算法试图解决由于发送端应用每次向 TCP 传递一个字节而引起的问题，Clark 方案则试图解决由于接收端应用每次从 TCP 流种读取一个字节而引起的问题**。这两种方案各自有效、相互补充，发送端的目标是不发送太小的数据段，而接收端也不要请求太小的段。

## 4. Refer Links

[TCP 的那些事儿（上）](https://coolshell.cn/articles/11564.html)

[TCP 的那些事儿（下）](https://coolshell.cn/articles/11609.html)

[TCP 协议的滑动窗口具体是怎样控制流量的？](https://www.zhihu.com/question/32255109)

[网络基本功（八）：细说 TCP 滑动窗口](https://wizardforcel.gitbooks.io/network-basic/content/7.html)

[网络基本功（十一）：TCP 窗口调整与流控](https://wizardforcel.gitbooks.io/network-basic/content/10.html)

[阮一峰：TCP 协议简介](http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html)