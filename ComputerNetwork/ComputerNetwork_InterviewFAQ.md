- [计算机网络：面试常见问题](#计算机网络面试常见问题)
  - [1. 常见概念辨析](#1-常见概念辨析)
    - [1.1. 网络硬件](#11-网络硬件)
    - [1.2. IEEE 标准](#12-ieee-标准)
    - [1.3. Size Limition](#13-size-limition)
      - [1.3.1. Header Size](#131-header-size)
      - [1.3.2. MTU && MSS](#132-mtu--mss)
      - [1.3.3. Packet Size](#133-packet-size)
    - [1.4. Address Length](#14-address-length)
    - [1.5. 各层职责](#15-各层职责)
  - [2. 网络模型](#2-网络模型)
    - [2.1. OSI 模型有什么缺陷？](#21-osi-模型有什么缺陷)
    - [2.2. TCP/IP 模型有什么缺陷？](#22-tcpip-模型有什么缺陷)
  - [3. TCP 协议](#3-tcp-协议)
    - [3.1. IP 地址和端口号可以确定网络上唯一的进程吗？](#31-ip-地址和端口号可以确定网络上唯一的进程吗)
    - [3.2. TCP 与 UDP 的区别](#32-tcp-与-udp-的区别)
    - [3.3. TCP 协议是如何保证可靠传输的？](#33-tcp-协议是如何保证可靠传输的)
    - [3.4. TCP 协议是如何防止数据被篡改的？](#34-tcp-协议是如何防止数据被篡改的)
    - [3.5. TCP 协议的缺陷？](#35-tcp-协议的缺陷)
  - [4. HTTP 协议](#4-http-协议)
    - [4.1. GET 与 POST 的区别？](#41-get-与-post-的区别)
  - [5. Refer Links](#5-refer-links)

# 计算机网络：面试常见问题

## 1. 常见概念辨析

### 1.1. 网络硬件

- 物理层 (L1) 设备：转发器、集线器、中继器。
- 数据链路层 (L2) 设备：网桥、交换机（高级交换机可以工作在第三层（网络层）和第四层（传输层））。
- 网络层 (L3) 设备：路由器（互联网的主要骨干）。

### 1.2. IEEE 标准

- IEEE 802.15：短程无线通信标准，用于无线个人局域网（蓝牙、ZigBee 等）。
- IEEE 802.11：无线局域网通用标准。
- IEEE 802.3：以太网通用标准，描述物理层和数据链路层的 MAC 子层的实现方法，在多种物理媒体上以多种速率采用 CSMA/CD 访问方式。
- IEEE 802.16：无线宽带通用标准。

### 1.3. Size Limition

#### 1.3.1. Header Size

- TCP Header: 20 bytes
- UDP Header: 8 bytes
- IPv4 Header: 20 bytes
- IPv6 Header: 40 bytes
- ICMP Header: 8 bytes
- ICMPv6 Header: 32 bytes
- Ethernet Frame Header: 14 bytes
- Ethernet Frame check sequence: 4 bytes

#### 1.3.2. MTU && MSS

- MTU 与 IP 分片

  最大传输单元 (Maximum Transmission Unit，MTU) 是指物理接口（数据链路层）提供给其上层（如 IP 层、MPLS 层）最大一次传输数据的大小。

  常见缺省 MTU:
  - 以太网 MTU: 1500 bytes
  - IEEE 802.3/802.2 MTU: 1492 bytes

  如果 IP 层（网络层）以上的协议层发送的数据段的长度超过了 MTU，则在发送者的 IP 层（网络层）将对数据段进行**分片**，在接收者的 IP 层（网络层）再对接收到的分片进行重组 (Reassemble)。在网络通讯中，分片重组对网络性能影响很大，因此**应尽量避免发生分片和重组**。

- MSS 与 TCP 分段

  TCP 协议中 MSS 的计算方法：
  > MSS = MTU - IP Header - TCP Header
  
  eg:
  - 以太网 MSS = 1500 - 20 -20 = 1460 bytes. 
  - IEEE 802.3/802.2 MSS = 1492 - 20 - 20 = 1452 bytes.
  
  通常将 MSS 设置为 MTU - 40 字节，携带 TCP 报文段的 IP 数据报的长度就不会超过 MTU，从而避免本机发生 IP 分片。

#### 1.3.3. Packet Size

- Frame
  
  以太网帧的最小长度为 64 字节（6+6+2+46+4），最大长度为 1518 字节（6+6+2+1500+4）。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/6/10/fc48827a2545af91da4bf0a1e399fc3d.jpg)

- Package

  若不考虑下层（链路层）传输限制，则 IP 数据包的最小长度为 20 字节（20+0），最大长度为 65536 字节（20+65516）。

  > 在 IP 头中用 2 个字节描述报文长度，2 个字节所能表达的最大数字就是 65536，因此 IP 数据包理论上的最大长度是 64Kb (65536 Byte)。

- Segement
  
  TCP Segement 的理论上限为 65515 字节（65535-20）。

### 1.4. Address Length

- IPv4 Address: 32 bits / 4 bytes
- IPv6 Address: 128 bits / 16 bytes
- MAC Address
  - MAC-48: 48 bits / 6 bytes 
  - EUI-64: 64 bits / 8 bytes
- Port: 16 bits / 2 bytes

### 1.5. 各层职责

- 应用层
- 传输层
  - 为应用层的进程提供可靠、高效、成本有效的数据传输服务
    - 差错控制
    - 拥塞控制（间接流量输入），实现了基于流量的路由算法。
    - 流量控制
  - 屏蔽不同的通信子网
- 网络层
  - 拥塞控制（由于拥塞发生在网络中，网络层直接经历着拥塞，且必须由它最终确定如何处理过载的数据包，因此网络层必须提供拥塞控制的功能），避免某些通信线路的路由器负载过重而导致网络拥塞。
  - 路由选择，选择网络拓扑结构中的最佳路径。
  - 网络互联，允许异构网络相互连接。
- 链路层
  - LLC
    - 流量控制
    - 差错控制（物理层提供的比特流传输是不可靠的，因此在链路层必须进行差错控制）
    - 为上层提供统一逻辑视图，维护函数调用表。
  - MAC
    - 将比特流成帧，并提供校验机制。
    - 分配局域网地址。
    - 提供信道复用。
- 物理层
  - 在两个网络设备之间提供透明的比特流传输。

## 2. 网络模型

### 2.1. OSI 模型有什么缺陷？

OSI 参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的制定。即 **OSI 参考模型并不是一个标准，而是一个在制定标准时所使用的概念性框架，忽略了很多实现上的细节问题**。

### 2.2. TCP/IP 模型有什么缺陷？

- 该模型没有明确区分服务、接口和协议。
- 通用性差，不适用用于描述 TCP/IP 之外的任何其它协议栈，如蓝牙。
- 没有区分物理层和数据链路层。物理层需要考虑铜线、光纤和无线通信的传输特征，而数据链路层需要确定帧的开始和结束并把帧从一边发送到另外一边，这是 2 个完全不同的层。

## 3. TCP 协议

### 3.1. IP 地址和端口号可以确定网络上唯一的进程吗？

[IP 地址和端口号可以确定网络上唯一的进程吗？](https://www.zhihu.com/question/27784864/answer/496153949)

**不可以**。在 Linux 系统中，通过 SO_REUSEADDR 和 SO_REUSEPORT 可以复用地址和端口，也就是说可以在同一个 IP 的同一个 port 上绑定多个进程，即**端口复用技术**。这种技术的通常使用场景是针对 TIMEWAIT 链接，防止服务器重启时绑定的端口还未释放或者程序意外退出导致系统没有释放端口，如果这时设立了端口复用，那么重新启动或者新启动的应用进程可以直接绑定端口。

### 3.2. TCP 与 UDP 的区别

- TCP 是面向连接的，UDP 是无连接的。

- TCP 是面向数据流的协议，UDP 是面向数据报的协议。

  TCP 的分包 / 粘包问题也就是 TCP 协议的“流”特性造成的。

  假设客户端一次完全发送这么一串字符 str = "hello world!"到服务端，在服务端一次 read，并且 read 长度的参数大于 strlen(str) 的情况下，用 TCP 和 UDP 协议会有什么区别？

  在网络没有出问题的情况下，根据系统内核的套接字缓冲区是否充足：
  - 用 UDP 协议发送的话，在服务端要么是什么也收不到；要么是全部收到了"hello world!"这个字符串。
  - 用 TCP 协议发送的话，有可能一次 read 只是得到了"hello world!"的部分字符，经过多次 read 累积缓冲区才能收到整个字符串；有可能一次全部收到。

  举一个例子类比一下，我们要把一个空碗接满水，我们可以一次倒入也可以分多次倒入。但是我们要把一个馒头完整的放进另一个碗中，你的选择只有放一次，要么放得下要么放不下。

- TCP 是可靠的，而 UDP 是不可靠的，尽最大努力交付。

- TCP 有拥塞控制机制，而 UDP 没有拥塞控制。因此网络出现拥塞时 UDP 不会使源主机的发送速率降低（这对实时应用很有用，如 IP 电话、实时视频会议等）。

- TCP 连接只能是一对一的，而 UDP 协议支持一对一、一对多、多对一和多对多的交互通信。

- TCP 首部开销 20 字节，而 UDP 的首部只有 8 个字节，网络开销较小。

### 3.3. TCP 协议是如何保证可靠传输的？

可靠传输 (Reliable Transmission) 是相对于 UDP 不可靠传输来说的，指在常见的丢包、乱序的条件下依然可以保证数据被顺序接受，中间不丢数据，即需要保证数据确实到达目的地；如果未到达，能够发现并重传。

措施：
- 序列号和确认号
- 滑动窗口
- 重传机制

### 3.4. TCP 协议是如何防止数据被篡改的？

错误检测 (Error Detection) 用于验证数据是否被篡改、伪造。

措施：对于 TCP 协议而言，错误检测仅靠 TCP 段头部的一个 16 bit 的字段：校验和 checksum 来完成。这种校验非常弱，规则都是透明的，同时篡改数据内容和校验数即可绕过。因此，**TCP 无法真正防止数据被篡改**。

在 TCP 之外，要防止数据被篡改可以通过以下措施：
- 加密。没有密钥的第三方即使拿到数据包也无法还原成有意义的内容，更无法修改替换。
- 身份认证。防止双方从最开始就被中间人两头骗，SSL/TLS 是一个比较成熟通用的解决方案。

### 3.5. TCP 协议的缺陷？

- TCP 的流控算法不能很好的适应高带宽高延迟的场景。由于延迟确认机制的存在，ACK 不能及时送达，导致传输速度远低于理论的传输带宽。

- **TCP 的拥塞控制算法是基于丢包的，是否发生了丢包是判断网络是否拥塞的唯一依据，但 TCP 由于对网络了解的很片面，无法分辨丢包是什么原因造成的，不能很好的适应网络不太稳定的场景**：
  - 网络真的拥堵而丢包，这种情况 TCP 流量控制可以很好的起效果。
  - 线路质量差 CRC 校验失败丢、或信号干扰丢，这种情况 TCP 流量控制不起作用。
  - IP 包乱序而引起的误判，这种情况 TCP 流量控制也不起作用。

  例如在无线网络中，TCP 的拥塞控制认为丢包是因为网络传输饱和，所以一旦出现丢包就采取指数级避让，而无线网络因为短暂的信号干扰导致的丢包并不是因为网络传输饱和，此时采取指数级避让是不合适的，会导致无线传输的速度骤降。

  关于这点已经有很多改进的算法了，比如**基于带宽实时测量的 Google BBR 算法**。

- 事实上，TCP 协议的许多缺陷都通过 TCP option 在不断地打着补丁：
  - Scaling window 应对长肥管道。
  - Selective ACK 应对高丢包率场景。
  - Timestamp 应对序列号回滚、RTT 测量的精度。
  - Authentication Option 应对数据完整性挑战。
  - TCP Cookie 应对 SYN Flooding DOS 攻击。
  - FAST TCP Open 应对 TCP 传输数据延时大。

## 4. HTTP 协议

### 4.1. GET 与 POST 的区别？

- GET 是用来从服务器上获得数据（没有请求体)，而 POST 是用来向服务器上传递数据（包含请求体)。

- GET 将表单中数据的按照 variable=value 的形式，添加到 action（服务）所指向的 URL 后面，并且两者使用“?”连接，而各个变量之间使用“&”连接；POST 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL。

- GET 是不安全的，因为在传输过程，数据被放在请求的 URL 中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求 URL 记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。POST 的所有操作对用户来说都是不可见的。

- GET 传输的数据量小，因为受 URL 长度限制；POST 可以传输大量的数据，所以在上传文件只能使用 POST。

- GET 限制 Form 表单的数据集的值必须为 ASCII 字符；而 POST 支持整个 ISO10646 字符集，默认是用 ISO-8859-1 编码。

- GET 是 Form 的默认提交方法。

- 使用 GET 方法时，浏览器可能会缓存你的地址等信息，还会留下历史记录，而对于 POST 方法，则不会进行缓存。

## 5. Refer Links