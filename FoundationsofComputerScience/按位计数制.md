- [数制表示和转换](#)
  - [1. 按位计数制](#1)
  - [2. 浮点数的二进制表示](#2)
    - [2.1. 表示规则](#21)
    - [2.2. 实例](#22)
  - [3. 非十进制计算](#3)
    - [3.1. 加减法](#31)
    - [3.2. 乘除法](#32)
  - [4. 负数表示](#4)
    - [4.1. 符号 - 数值表示法](#41)
    - [4.2. 反码表示法](#42)
    - [4.3. 余码表示法](#43)
    - [4.4. 补码表示法](#44)
  - [5. 机器码](#5)
    - [5.1. 原码](#51)
    - [5.2. 反码](#52)
    - [5.3. 补码](#53)
    - [5.4. 移码](#54)
  - [6. Refer Links](#6-refer-links)

# 按位计数制

## 1. 按位计数制

按位计数制（positional number system）：即传统计数制。用一串数码表示一个数，每个数码的位置对应有一个权值（weight），所有数码按权值展开相加之和即为该数的值。

基数（base/radix）：常见的按位计数制有二进制、八进制、十进制、十六进制等，这里的二、八、十、十六，称为基数。

P.S.
-  [在 c++ 中，0 是一个八进制数](http://justjavac.com/other/2013/03/03/is-0-a-decimal-literal-or-an-octal-literal.html).

  根据 C++ 标准：
  ```
  2.14.2 整数 [lex.icon]
  integer-literal:  
      decimal-literal integer-suffixopt  
      octal-literal integer-suffixopt  
      hexadecimal-literal integer-suffixopt  
  decimal-literal:  
      nonzero-digit  
      decimal-literal digit  
  octal-literal:  
      0                    <--------------------《这里》
      octal-literal octal-digit
  ```
- 若一个二进制数有 n 个二进制位，则这个数的最大值是 2^n-1，最高位的 1 是 2^(n-1)。

## 2. 数制转换

| 按位计数制 | 二进制                             | 八进制                               | 十进制   | 十六进制                               |
| ---------- | ---------------------------------- | ------------------------------------ | -------- | -------------------------------------- |
| 二进制     | *                                  | 替换：每 3 位二进制替换成 1 位八进制     | 按权求和 | 替换：每 4 位二进制替换成 1 位十六进制     |
| 八进制     | 替换：每 1 位八进制替换成 3 位二进制   | *                                    | 按权求和 | 替换：先替换成二进制，再替换成十六进制 |
| 十进制     | 除 2 取余（由下至上取余）            | 除 8 取余（由下至上取余）              | *        | 除 16 取余（由下至上取余）               |
| 十六进制   | 替换：每 1 位十六进制替换成 4 位二进制 | 替换：先替换成二进制，再替换成八进制 | 按权求和 | *                                      |

注：替换时不足位补 0 即可。

## 3. 浮点数的二进制表示

IEEE 二进制浮点数算术标准（ANSI/IEEE Std 754-1985）：IEEE754，是浮点数的二进制表示的国际统一标准。手动计算可使用[依据 IEEE754 编写的浮点数二进制转换工具](https://www.h-schmidt.net/FloatConverter/IEEE754.html) 进行验证。

根据 IEEE 754，任意一个二进制浮点数 V 可以表示成这样的形式：
```
V = (-1)^s * M * 2^E
```
其中：
- s 表示符号位，当 s=0，V 为正数；当 s=1，V 为负数。
- M 表示有效数字，大于等于 1，小于 2。
- E 表示指数位。

### 3.1. 表示规则

IEEE 754 规定，浮点数的二进制在计算机中按以下规则存储：
- 对于 32 位的单精度 float 浮点数：
  
  最高的 1 位是符号位 S，接着的 8 位是指数 E，剩下的 23 位为有效数字 M。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/13/96a7b0c8a78bda981c138b816a101611.jpg)

- 对于 64 位的双精度 double 浮点数
  
  最高的 1 位是符号位 S，接着的 11 位是指数 E，剩下的 52 位为有效数字 M。

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/13/bb249bbfe226e75a49e278b73d9b5d8f.jpg)

其中：
- 对于有效数字 M：
  
  在计算机内部保存 M 时，默认这个数的第一位总是 1，因此可以被舍去，即**对于尾数 1.xxxxxx，只保存后面的 xxxxxx 部分**。比如保存 1.01 的时候，只保存 01，等到读取的时候，再把第一位的 1 加上去。这样做的目的，是节省 1 位有效数字。
  
  以 32 位浮点数为例，留给 M 只有 23 位，将第一位的 1 舍去以后，等于可以保存 24 位有效数字。

- 对于指数 E：
  
  E 为一个无符号整数（unsigned int）。这意味着，如果 E 为 8 位，它的取值范围为 0~255；如果 E 为 11 位，它的取值范围为 0~2047。IEEE 754 规定，**E 应该在真实值的基础上加上中间数 127（或 1023）之后，再转换为二进制存储**。

  因此，针对指数 E，浮点数的值可以分为三种不同的情况：

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/13/47c1622887394e9970f6eff4730e5fec.jpg)

  - E 不全为 0 或不全为 1：
    
    此时，浮点数就采用上面的规则表示，即指数 E 的计算值减去 127（或 1023），得到真实值，再将有效数字 M 前加上第一位的 1。
  
  - E 全为 0：
    - 若有效数字 M 也全为 0，此时表示 0。    
    - 若有效数字 M 不全为 0，则浮点数的指数 E 等于 -127（或者 -1023），有效数字 M 不再加上第一位的 1，而是还原为 0.xxxxxx 的小数。这样做是为了表示±0，以及接近于 0 的很小的数字。
  
  - E 全为 1：
    - 若有效数字 M 全为 0，表示“± 无穷”infinity（正无穷 / 负无穷取决于符号位 s）。
    - 若有效数字 M 不全为 0，表示这个数不是一个数，即 NaN（Not a Number）。

### 3.2. 实例

- 例 1：将 20.59375(10) 转换成 IEEE754 标准的 32 位二进制浮点数。

  分析：float 类型共 32 位，1 位符号位，8 位指数位，23 位尾数位

  步骤：

  1. 将 20.59375(10) 的整数和小数部分分别转换为二进制：
      
      - 20 转换为 10100.
      - 0.59375 采取乘 2 取整数位的方法（如下图），转换为 0.10011:

        ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/13/72216ba52ff9cb966018d21db9d344c2.jpg)

        因此，20.59375(10) = 10100.10011(2).

  1. 化为科学计数法：(-1)^0x1.010010011x2^4.
  1. 因此，S=0，E=4+127=131=10000011，M=0100 1001 1000 0000 0000 000.
  1. 20.59375 的 IEEE754 表示法为：`0 10000011 01001 0011 0000 0000 0000`.
        

- 例 2：已知 double 类型 38414.4, 求：其对应的二进制表示。

  分析：double 类型共计 64 位； 1 位是符号位，11 位是指数位，52 位是尾数位。

  步骤：按照 IEEE 浮点数表示法，下面先把 38414.4 转换为二进制数，把整数部和小数部分开处理：

  1. 整数部分转换为二进制：1001011000001110。
  1. 小数的处理：0.4=0.5*0+0.25*1+0.125*1+0.0625*0+……
      
      实际上这永远算不完！这就是著名的**浮点数精度问题**。所以直到加上前面的整数部分算够 53 位就行了。如果你够耐心，手工算到 53 位那么因该是： 
      ```
      38414.4(10)=1001011000001110.0110011001100110011001100110011001100(2)。
      ```
      再转换为科学记数法：`1.001011000001110 0110011001100110011001100110011001100`，左移了 15 位，所以指数为 15。即表达式为：
      ```
      (-1)^0x1.001011000001110 0110011001100110011001100110011001100×2^15
      ```
      因此：
      - 符号位 S = 0.
      - 指数`E=（15+1023）10 = 1038（10）= 100 0000 1110(2)`.
      - 尾数`M = 001011000001110 0110011001100110011001100110011001100`（舍去最高位 1.）.
      合在一起得到浮点数 38414.4 的二进制表示：
      ```
      01000000 11100010 11000001 110 01100  11001100  11001100  11001100  11001100
      ```

- 例 3：浮点数 x 的 IEEE754 标准储存格式为 0x0000 0009，则其浮点数的十进制数值为 0.000000.

  ![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/13/487853a5574e4761fa1b845528fc8886.jpg)

  分析：
  - 首先，将十六进制数 0x00000009 展开成二进制：0 00000000 000 0000 0000 0000 0000 1001，得到第一位符号位 s=0，后面 8 位的指数 E=00000000，最后 23 位的有效数字 M=000 0000 0000 0000 0000 1001。
  - 由于指数 E 全为 0，所以符合上一节的第二种情况。因此，浮点数 V 就写成：
　　> V=(-1)^0×0.00000000000000000001001×2^(-126)=1.001×2^(-146)
  - 显然，V 是一个很小的接近于 0 的正数，所以用十进制小数表示就是 0.000000。

- 例 4：用二进制表示的浮点数 9.0，还原成十进制结果是 1091567616：

  分析：
  - 首先，浮点数 9.0 等于二进制的 1001.0，即 1.001×2^3。
  - 那么，第一位的符号位 s=0，有效数字 M 等于 001 后面再加 20 个 0，凑满 23 位，指数 E 等于 3+127=130，即 10000010。
  - 所以，写成二进制形式，应该是 S+E+M，即 0 10000010 001 0000 0000 0000 0000 0000。这个 32 位的二进制数，还原成十进制，正是 1091567616。

## 4. 非十进制计算

### 4.1. 加减法

### 4.2. 乘除法

## 5. 负数表示

### 5.1. 符号 - 数值表示法

符号 - 数值表示法（signed-magnitude system）: 一个数由表示该数为正负的符号和数值两部分组成。若没写符号则默认为正。0 有两种可能的表示：+0 和 -0，但它们的值是相同的。

### 5.2. 反码表示法

### 5.3. 余码表示法

### 5.4. 补码表示法

由于补码表示法便于计算，因此计算机中通常会采用补码表示法来表示负数。

## 6. 机器码

### 6.1. 原码

```
x=+1001, [x] 原 = 01001.
x=-1001, [x] 原 = 11001.
```
0 的原码有两个。

### 6.2. 反码

```
正数：与原码相同。
负数：在原码的基础上，除符号位外各位都取反。
```
0 的反码有两个。

### 6.3. 补码

```
正数：与原码相同。
负数：在反码的基础上，最低位加 1.
```
0 的补码只有一个。

### 6.4. 移码

补码的符号位取反：

![image](http://otaivnlxc.bkt.clouddn.com/jpg/2018/5/13/8cf4dcdbc7e123b413e26fb24638a891.jpg)

## 7. Refer Links

http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html

https://www.cnblogs.com/FlyingBread/archive/2009/02/15/660206.html

https://www.cnblogs.com/zuoxiaolong/p/computer11.html

http://blog.163.com/yql_bl/blog/static/847851692008112013117685/
