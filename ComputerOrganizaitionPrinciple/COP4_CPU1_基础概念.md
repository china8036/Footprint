- [计算机组成原理：CPU - 基础概念](#计算机组成原理cpu---基础概念)
  - [1. 发展历史](#1-发展历史)
  - [2. 主要功能](#2-主要功能)
  - [3. 基本组成](#3-基本组成)
    - [3.1. 主要寄存器](#31-主要寄存器)
    - [3.2. 操作控制器](#32-操作控制器)
    - [3.3. 时序产生器](#33-时序产生器)
  - [5. Refer Links](#5-refer-links)

# 计算机组成原理：CPU - 基础概念

## 1. 发展历史

- 晶体管（继电器 → 真空管 → 晶体管 / 半导体硅）的应用和集成工艺的提升，孕育了微处理器的诞生。

- 1971 年 11 月，Intel 推出 Intel 4004 (4-bit)。这是第一个将 CPU 的所有元件都放入同一块芯片内的产品，也是世界上第一个可商用的微处理器。

- 1972 年 4 月，Intel 推出 Intel 8008 (8-bit, 2 MHz, 14-bit address bus that could address 16 KB of memory)，这是世界上第一个 8 位微处理器，它比 4004 复杂一倍；同年 8 月，Motorola 推出了 Motorola 6800 (8-bit, 1 MHz, 14-bit address bus that could address 16 KB of memory)，也是一个 8 位的微处理器。这 2 个 CPU 被称为改变世界的 2 款 microprocessor。

- 1974 年，Intel 推出了 Intel 8080 (8-bit)，这是世界上第一个为通用微机而设计的微处理器（4004 和 8008 是为特殊用途而设计的）。

- 1976 年，Intel 推出了 Intel 8085 (8-bit)。

- 1978 年，Intel 推出了 Intel 8086 (16-bit)，由于 Intel 8086 在 3 年后被 IBM PC 所选用，因此 **x86 成为了 PC 的标准平台，成为了历来最成功的 CPU 指令集架构体系**。

- 1985 年，Intel 推出了 Intel 80386 (32-bit)，其保护模式是当今 x86 处理器主要的工作模式。

## 2. 主要功能


## 3. 基本组成

### 3.1. 主要寄存器

<!-- ----- -->

寄存器个数，现在 Intel 的最新一代 CPU 里大概有上百个寄存器，扣除重复使用的相同空间的寄存器，寄存器的大小大概是 2KB 多，具体的寄存器如下图：

![image](http://img.cdn.firejq.com/jpg/2019/1/11/7c72e6d942e557b1551e15742f29a921.jpg)

(Registers available in the x86-64 instruction set)

<!-- ----- -->

[汇编语言里所有寄存器， 就是现代 CPU 内部中所有的寄存器吗？](https://www.zhihu.com/question/24229120)

- 指令集中包含的寄存器和 CPU 内部的寄存器有点儿不太一样。你说的那些东西是指令集里的寄存器，因为考虑程序兼容性的问题，所以这些东西一般不变，变的话也是只增不减。
  我猜测你的疑问是寄存器这么几十年没增加，性能会好么？
  对于这个问题，其实 CPU 硬件里的寄存器不只这些，尤其是 CPU 支持多级流水以及乱序发射之后，有很多内部的寄存器被流水线电路使用，但是这些寄存器不是软件可见的，所以你不用关心。
  另外你说的也不准确，从 X86 到 X64 转换的时候，不光寄存器的位数增加了，寄存器的个数也增加了，后面加了 8 个通用寄存器。
  而且还有指令集的扩展比如 SSE, SSE2 等也会引入一些新的寄存器。

- 远远不止这些啊，比如 ring 0 的代码才能访问的各种 control registers 和 debug registers，比如 SSE 对应的各种 XMM，AVX 对应的 YMM 寄存器，AVX-512 加的 ZMM 寄存器，比如 64 位模式下的 r8~r15，等等。这些都是可以在汇编里访问的，更别说各种不让你访问的。指令集 ISA 决定编译器可以看到的寄存器。

<!-- ----- -->

[阮一峰：为什么寄存器比内存快？](http://www.ruanyifeng.com/blog/2013/10/register.html)

- 距离不同

  内存离 CPU 比较远，所以要耗费更长的时间读取。距离对于桌面电脑影响很大，对于手机影响就要小得多。手机 CPU 的时钟频率比较慢（iPhone 5s 为 1.3GHz），而且手机的内存紧挨着 CPU。

- 硬件设计不同

  内存的设计相对简单，每个位就是一个电容和一个晶体管，而寄存器的设计则完全不同，多出好几个电子元件。并且通电以后，寄存器的晶体管一直有电，而内存的晶体管只有用到的才有电，没用到的就没电，这样有利于省电。这些设计上的因素，决定了寄存器比内存读取速度更快。

- 工作方式不同

  寄存器的工作方式很简单，只有两步：
  1. 找到相关的位
  1. 读取这些位

  内存的工作方式就要复杂得多：
  1. 找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。）
  1. 将指针送往内存管理单元（MMU），由 MMU 将虚拟的内存地址翻译成实际的物理地址。
  1. 将物理地址送往内存控制器（memory controller），由内存控制器找出该地址在哪一根内存插槽（bank）上。
  1. 确定数据在哪一个内存块（chunk）上，从该块读取数据。
  1. 数据先送回内存控制器，再送回 CPU，然后开始使用。

  内存的工作流程比寄存器多出许多步。每一步都会产生延迟，累积起来就使得内存比寄存器慢得多。

为了缓解寄存器与内存之间的巨大速度差异，硬件设计师做出了许多努力，包括在 CPU 内部设置缓存、优化 CPU 工作方式，尽量一次性从内存读取指令所要用到的全部数据等等。

<!-- ----- -->

[为什么 X86 的寄存器数量没有随着性能的提升而增加？](https://www.zhihu.com/question/65682145/answer/233730966)

- 从编译的角度看，寄存器压力（局部的数量不够用导致不得不访存），在寄存器多到一定程度（大概 16 到 32），就不那么大了。
- 从乱序执行硬件的角度看，现代处理器一般都应用了**寄存器重命名**技术，很多还特别优化了 reg2reg mov 操作，所以对于寄存器不够用导致的额外搬移，在这些处理器上并不会有非常大的性能损失（或者说软件在这方面的优化空间有限）。
- 另外 x86 处理器的访存单元会特别优化，像 st fwd ld 都做的比较激进，所以你用一些内存读写也不影响性能。

<!-- ----- -->

### 3.2. 操作控制器

### 3.3. 时序产生器

## 5. Refer Links

TODO:

[为什么 ARM 和 MIPS 那么多寄存器，x86 那么少？](https://www.zhihu.com/question/24551779)

[关于现代 CPU，程序员应当更新的知识](https://linux.cn/article-6201-1.html)
