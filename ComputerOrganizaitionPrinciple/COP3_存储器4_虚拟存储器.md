- [计算机组成原理：虚拟存储器](#计算机组成原理虚拟存储器)
  - [1. 基本概念](#1-基本概念)
    - [1.1. 发展由来](#11-发展由来)
    - [1.2. 访问机制](#12-访问机制)
    - [1.3. Cache 与虚存的异同](#13-cache-与虚存的异同)
  - [2. 实现方式](#2-实现方式)
    - [2.1. 页式虚拟存储器](#21-页式虚拟存储器)
      - [2.1.1. 内页表](#211-内页表)
        - [2.1.1.1. 地址映射](#2111-地址映射)
        - [2.1.1.2. 转换后援缓冲器 (TLB)](#2112-转换后援缓冲器-tlb)
      - [2.1.2. 外页表](#212-外页表)
      - [2.1.3. 优缺点](#213-优缺点)
    - [2.2. 段式虚拟存储器](#22-段式虚拟存储器)
      - [2.2.1. 地址映射](#221-地址映射)
      - [2.2.2. 优缺点](#222-优缺点)
    - [2.3. 段页式虚拟存储器](#23-段页式虚拟存储器)
  - [3. 替换算法](#3-替换算法)
  - [4. Refer Links](#4-refer-links)

# 计算机组成原理：虚拟存储器

## 1. 基本概念

### 1.1. 发展由来

在早期的单用户单任务操作系统（如 DOS）中，每台计算机中只有一个用户，每次运行一个程序，且程序不是很大，单个程序完全可以放在实际内存中。这种情况下，虚拟内存并没有太大的用处。

随着程序占用存储器容量的增长和多用户多任务系统的出现，在程序设计时，在程序所需的存储器容量与计算机系统实际配备的主存储器的容量之间往往存在着矛盾。例如：
- 在某些计算机中，物理内存的容量较小，而某些程序却需要很大的内存才能运行。
- 在多用户多任务系统中，多个用户或多个任务共享全部主存，要求同时执行多道程序。而这些同时运行的程序到底占用实际内存中的哪一部分，在编制程序时时无法确定的，必须等到程序运行时才能动态分配。

因此，希望能有这样一种机制：
- 在编写程序时独立编址，既不考虑程序是否能在物理存储器中放得下也不用考虑程序应该放在什么物理位置。
- 在程序运行时，分配给每个程序一定的运行空间，由地址转换部件 (MMU) 将编程时的地址转换实际内存的物理地址，如果分配的内存不够，则只调入当前正在运行的或将要运行的程序块（或数据块），其余部分暂时驻留在辅存中。

在这种存储机制中：
- 用户编写程序时使用的地址称为**虚地址或逻辑地址**，其对应的存储空间称为**虚存储空间或逻辑地址空间**。
- 计算机物理内存的访问地址称为**实地址或物理地址**，其对应的存储空间称为**物理存储空间或主存空间**。
- 程序进行虚地址到实地址转换的过程称为程序的**再定位**。

### 1.2. 访问机制

1. 虚存空间的用户程序按照虚地址编程并存放在辅存中。
1. 程序运行时，由地址变换机构 (MMU) 依据当时分配给该程序的实地址空间把程序的一部分调入实存。
1. 每次访存时，首先判断该虚地址所对应的部分是否在实存中：如果是，则进行地址转换并用实地址访问主存；否则，按照某种算法将辅存中的部分程序调度进内存，再按同样的方法访问主存。

由此可见，每个程序的虚地址空间可以远大于实地址空间，也可以远小于实地址空间。前一种情况以提高存储容量为目的，后一种情况则以地址变换为目的。后者通常出现在多用户或多任务系统中：实存空间较大，而单个任务并不需要很大的地址空间，较小的虚存空间则可以缩短指令中地址字段的长度。

在这种访问机制中，每个程序就可以拥有一个虚拟的存储器，它具有辅存的容量和接近主存的访问速度，但**这个虚存是由主存和辅存以及辅存管理部件构成的概念模型，不是实际的物理存储器**。**虚存是在主存和辅存之外附加一些硬件（MMU）和软件（操作系统中的内存管理组件）实现的**。由于软件的介入，使虚存对设计存储管理软件的系统程序员而言不是透明的，但对应用程序员而言仍然是透明的。

### 1.3. Cache 与虚存的异同

从虚存的概念可以看出，主存 - 辅存的访问机制与 Cache- 主存的访问机制是类似的。这是**由 Cache 存储器、主存和辅存构成的三级存储体系**中的两个层次。**Cache 和主存构成了系统的内存，而主存和辅存依靠辅助软硬件的支持构成了虚拟存储器**。

在三级存储体系中，cache - 主存和主存 - 辅存这两个存储层次有许多相同点：
- 出发点相同：二者都是为了提高存储系统的**性能价格比**而构造的分层存储体系，都力图使存储系统的性能接近高速存储器，而价格和容量接近低速存储器。
- 原理相同：都是利用了程序运行时的**局部性原理**把最近常用的信息块从相对慢速而大容量的存储器调入相对高速而小容量的存储器。

但 cache - 主存和主存 - 辅存这两个存储层次也有许多不同之处：
- 侧重点不同：Cache 主要解决主存与 CPU 的速度差异问题；而就性能价格比的提高而言，虚存主要是解决存储容量问题，另外还包括存储管理、主存分配和存储保护等方面。
- 数据通路不同：**CPU 与 cache 和主存之间均有直接访问通路**，cache 不命中时可直接访问主存；而**虚存所依赖的辅存与 CPU 之间不存在直接的数据通路**，当主存不命中时只能通过调页解决，CPU 最终还是要访问主存。
- 透明性不同：**cache 的管理完全由硬件完成**，对系统程序员和应用程序员均透明；而**虚存管理由软件（操作系统）和硬件（MMU）共同完成**，由于软件的介入，虚存对实现存储管理的系统程序员不透明，而只对应用程序员透明（段式和段页式管理对应用程序员“半透明”）。
- 未命中时的损失不同：由于主存的存取时间是 cache 的存取时间的 5～10 倍，而主存的存取速度通常比辅存的存取速度快上千倍，故**主存未命中时系统的性能损失要远大于 cache 未命中时的损失**。

## 2. 实现方式

### 2.1. 页式虚拟存储器

#### 2.1.1. 内页表

##### 2.1.1.1. 地址映射

页式虚拟存储系统中：
- 虚地址空间被分成等长大小的页，称为**逻辑页**；相应地，虚地址分为两个字段：高字段为逻辑页号，低字段为页内地址（偏移量）。
- 主存空间也被分成同样大小的页，称为**物理页**。相应地，实存地址分两个字段：高字段为物理页号，低字段为页内地址。

**通过页表可以把虚地址（逻辑地址）转换成物理地址，在大多数系统中，每个进程对应一个页表**。页表中对应每一个虚存页面有一个表项，表项的内容包含该虚存页面所在的主存页面的地址（物理页号），以及指示该逻辑页是否已调入主存的有效位。地址变换时，用逻辑页号作为页表内的偏移地址索引页表（将虚页号看作页表数组下标）并找到相应物理页号，用物理页号作为实存地址的高字段，再与虚地址的页内偏移量拼接，就构成完整的物理地址。**现代的中央处理器通常有专门的硬件（MMU）支持地址变换**。

每个进程所需的页数并不固定，所以页表的长度是可变的，因此**通常的实现方法是把页表的基地址保存在寄存器中，而页表本身则放在主存中**。

##### 2.1.1.2. 转换后援缓冲器 (TLB)

由于内页表通常在主存中，因而即使逻辑页已经在主存中，也至少要访问两次物理存储器才能实现一次访存，这将使虚拟存储器的存取时间加倍。

**为了避免对主存访问次数的增多，可以对页表本身实行二级缓存，把页表中的最活跃的部分存放在高速存储器中，组成快表。这个专用于页表缓存的高速存储部件通常称为转换后援缓冲器 (TLB)，而保存在主存中的完整页表则称为慢表**。地址变换时，根据逻辑页号同时查快表和慢表，当在快表中有此逻辑页号时，就能很快找到对应的物理页号。

根据程序局部性原理，多数虚拟存储器访问都将通过 TLB 进行，从而有效降低访存的时间延迟。

#### 2.1.2. 外页表

虚地址到主存物理地址的变换表，通常称为内页表。而与内页表对应的还有**外页表，用于虚地址与辅存地址之间的变换**。

当主存缺页时，调页操作首先要定位辅存，而外页表的结构与辅存的寻址机制密切相关。例如对磁盘而言，辅存地址包括磁盘机号、磁头号、磁道号和扇区号等。

外页表通常放在辅存中，在需要时可调入主存。当主存不命中时，由存储管理部件向 CPU 发出“缺页中断”，进行调页操作。

#### 2.1.3. 优缺点

- 优点：页长固定，因而便于构造页表、易于管理，且不存在碎片。
- 缺点：页长与程序的逻辑大小不相关（如某个时刻一个子程序可能有一部分在主存中，另一部分在辅存中），这不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。

### 2.2. 段式虚拟存储器

段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。

#### 2.2.1. 地址映射

在段式虚拟存储系统中，虚地址由段号和段内地址（偏移量）组成。

虚地址到实主存地址的变换通过段表实现。每个程序设置一个段表，段表的每一个表项对应一个段，每个表项至少包含下面三个字段：
- 有效位：指明该段是否已经调入实存。
- 段起址：指明在该段已经调入实存的情况下，该段在实存中的首地址。
- 段长：记录该段的实际长度。设置段长字段的目的是为了保证访问某段的地址空间时，段内地址不会超出该段长度导致地址越界而破坏其他段。

段表本身也是一个段，可以存在辅存中，但一般驻留在主存中。

#### 2.2.2. 优缺点

优点：
- 段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序共享。
- 段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。

缺点：
- 因为段的长度不固定，主存空间分配比较麻烦。
- 容易在段间留下许多外碎片，造成存储空间利用率降低。
- 由于段长不一定是 2 的整数次幂，因而不能简单地像分页方式那样用虚地址和实地址的最低若干二进制位作为段内偏移量，并与段号进行直接拼接，必须用加法操作通过段起址与段内偏移量的求和运算求得物理地址。因此，段式存储管理比页式存储管理方式需要更多的硬件支持。

### 2.3. 段页式虚拟存储器

**段页式虚拟存储器是段式虚拟存储器和页式虚拟存储器的结合**。

**实存被等分成页，每个程序先按逻辑结构分段，每段再按照实存的页大小分页，程序按页进行调入和调出操作，但可按段进行编程、保护和共享**。在段页式虚拟存储器中，每道程序均通过一个段表和多个页表进行两级再定位。段表中的每一个表项对应一个段，每个表项有一个指针指向该段的页表。页表则指明该段各页在主存中的位置，以及是否装入、是否已修改等状态信息。

CPU 提供了各种段寄存器用于查询段表中的段，还提供了控制寄存器用于实现段页式内存管理，而段表和页表等数据结构是要由操作系统来实现并维护的。

段页式虚拟存储器的缺点是在由虚地址向主存地址的映射过程中需要多次查表，因此实现复杂度较高。

## 3. 替换算法

当从辅存调页至主存而主存已满时，也需要进行主存页面的替换。虚拟存储器的替换算法与 cache 的替换算法类似，有 FIFO 算法、LRU 算法、LFU 算法等。

虚拟存储器的替换算法与 cache 的替换算法不同的是：
- cache 的替换全部靠硬件实现，而虚拟存储器的替换有操作系统的支持。
- 虚存缺页对系统性能的影响比 cache 未命中要大得多，因为调页需要访问辅存，并且要进行任务切换。
- 虚存页面替换的选择余地很大，属于一个进程的页面都可替换。

为支持虚存的替换，通常在页表或段表的每一表项中设置一个修改位，标识该表项所对应的主存页或段空间在被调入主存后是否修改过。对于将被替换出去的空间，假如其内容没有被修改过，就不必进行额外处理；否则就需把该空间存储的内容重新写入辅存，以保证辅存中数据的正确性。

## 4. Refer Links

TODO:

[Wikipedia: 保护模式](https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F)

[实模式和保护模式区别及寻址方式](https://www.cnblogs.com/bethunebtj/articles/4839781.html)

[MMU 内存管理单元](https://www.cnblogs.com/alantu2018/p/9002309.html)
