- [计算机组成原理：机器运算 - 数据表示](#计算机组成原理机器运算---数据表示)
  - [1. 基础概念](#1-基础概念)
    - [1.1. 按位计数制](#11-按位计数制)
    - [1.2. 机器码](#12-机器码)
      - [1.2.1. 原码](#121-原码)
      - [1.2.2. 反码](#122-反码)
      - [1.2.3. 补码](#123-补码)
      - [1.2.4. 移码](#124-移码)
    - [1.3. 负数表示方法](#13-负数表示方法)
      - [1.3.1. 符号 - 数值表示法](#131-符号---数值表示法)
      - [1.3.2. 反码表示法](#132-反码表示法)
      - [1.3.3. 余码表示法](#133-余码表示法)
      - [1.3.4. 补码表示法](#134-补码表示法)
    - [1.4. 数据格式](#14-数据格式)
  - [2. 定点数表示](#2-定点数表示)
  - [3. 浮点数表示](#3-浮点数表示)
    - [3.1. 表示规则](#31-表示规则)
    - [3.2. 浮点数的精度问题](#32-浮点数的精度问题)
      - [3.2.1. 问题产生](#321-问题产生)
      - [3.2.2. 问题表现](#322-问题表现)
      - [3.2.3. 问题规避](#323-问题规避)
    - [3.3. 实例](#33-实例)
  - [4. 字符表示](#4-字符表示)
  - [5. Refer Links](#5-refer-links)

# 计算机组成原理：机器运算 - 数据表示

## 1. 基础概念

### 1.1. 按位计数制

按位计数制（positional number system）：即传统计数制。用一串数码表示一个数，每个数码的位置对应有一个权值（weight），所有数码按权值展开相加之和即为该数的值。

基数（base/radix）：常见的按位计数制有二进制、八进制、十进制、十六进制等，这里的二、八、十、十六，称为基数。

数制转换：

| 按位计数制 | 二进制                             | 八进制                               | 十进制   | 十六进制                               |
| ---------- | ---------------------------------- | ------------------------------------ | -------- | -------------------------------------- |
| 二进制     | *                                  | 替换：每 3 位二进制替换成 1 位八进制     | 按权求和 | 替换：每 4 位二进制替换成 1 位十六进制     |
| 八进制     | 替换：每 1 位八进制替换成 3 位二进制   | *                                    | 按权求和 | 替换：先替换成二进制，再替换成十六进制 |
| 十进制     | 除 2 取余（由下至上取余）            | 除 8 取余（由下至上取余）              | *        | 除 16 取余（由下至上取余）               |
| 十六进制   | 替换：每 1 位十六进制替换成 4 位二进制 | 替换：先替换成二进制，再替换成八进制 | 按权求和 | *                                      |

注：替换时不足位补 0 即可。

### 1.2. 机器码

#### 1.2.1. 原码

```
x=+1001, [x] 原 = 01001.
x=-1001, [x] 原 = 11001.
```
0 的原码有两个。

#### 1.2.2. 反码

```
正数：与原码相同。
负数：在原码的基础上，除符号位外各位都取反。
```
0 的反码有两个。

#### 1.2.3. 补码

```
正数：与原码相同。
负数：在反码的基础上，最低位加 1.
```
0 的补码只有一个。

#### 1.2.4. 移码

补码的符号位取反：

![image](http://img.cdn.firejq.com/jpg/2018/5/13/8cf4dcdbc7e123b413e26fb24638a891.jpg)

移码通常用于表示浮点数的阶码。

### 1.3. 负数表示方法

#### 1.3.1. 符号 - 数值表示法

符号 - 数值表示法 (signed-magnitude system):  一个数由表示该数为正负的符号和数值两部分组成。若没写符号则默认为正。

0 有两种可能的表示：+0 和 -0，但它们的值是相同的。

#### 1.3.2. 反码表示法

#### 1.3.3. 余码表示法

#### 1.3.4. 补码表示法

由于补码表示法便于计算，因此计算机中通常会采用补码表示法来表示负数。

### 1.4. 数据格式

一般来说，计算机常用的数据表示格式有两种：
- 定点格式

  即约定机器中所有数据的小数点位置都是固定不变的。定点格式容许的数值范围有限，要求的处理硬件比较简单。

- 浮点格式

  即把一个数的有效数字和数的范围在计算机的一个存储单元中分别予以表示，相当于数的小数点位置随比例因子的不同而在一定范围内可以自由浮动。浮点格式容许的数值范围很大，要求的处理硬件比较复杂。

P.S.

- 整数和小数是数学里面的概念，在计算机中，只有定点数和浮点数，没有整数和小数。**在计算机中，通常使用定点数来存储数学上的整数，使用浮点数来存储数学上的小数。但需要注意的是，小数同样也可以使用定点数来表示**。

- **定点、浮点，“点”是什么意思？“点”就是小数点**。把小数点固定，通常固定在最右面，就是定点数。把小数点浮动，就是浮点数。浮点放在哪儿？这个就是在 IEEE 浮点数标准里面定义的。

## 2. 定点数表示

## 3. 浮点数表示

### 3.1. 表示规则

IEEE 二进制浮点数算术标准（ANSI/IEEE Std 754-1985）：IEEE754，是浮点数的二进制表示的国际统一标准。手动计算可使用依据 IEEE754 编写的[浮点数二进制转换工具](https://www.h-schmidt.net/FloatConverter/IEEE754.html) 进行验证。

根据 IEEE 754，任意一个二进制浮点数 V 可以表示成这样的形式：
```
V = (-1)^s * M * 2^E
```
其中：
- s 表示符号位，当 s=0，V 为正数；当 s=1，V 为负数。
- M 表示有效数字，大于等于 1，小于 2。
- E 表示指数位。

IEEE 754 规定，浮点数的二进制在计算机中按以下规则存储：
- 对于 32 位的单精度 float 浮点数：

  最高的 1 位是符号位 S，接着的 8 位是指数 E，剩下的 23 位为有效数字 M。

  ![image](http://img.cdn.firejq.com/jpg/2018/5/13/96a7b0c8a78bda981c138b816a101611.jpg)

- 对于 64 位的双精度 double 浮点数

  最高的 1 位是符号位 S，接着的 11 位是指数 E，剩下的 52 位为有效数字 M。

  ![image](http://img.cdn.firejq.com/jpg/2018/5/13/bb249bbfe226e75a49e278b73d9b5d8f.jpg)

其中：
- 对于有效数字 M：

  在计算机内部保存 M 时，默认这个数的第一位总是 1，因此可以被舍去，即**对于尾数 1.xxxxxx，只保存后面的 xxxxxx 部分**。比如保存 1.01 的时候，只保存 01，等到读取的时候，再把第一位的 1 加上去。这样做的目的，是节省 1 位有效数字。

  以 32 位浮点数为例，留给 M 只有 23 位，将第一位的 1 舍去以后，等于可以保存 24 位有效数字。

  **将一个小数转化为二进制表示的方式是，不断的乘 2，取其中的整数部分**。

- 对于指数 E：

  E 为一个无符号整数（unsigned int）。这意味着，如果 E 为 8 位，它的取值范围为 0~255；如果 E 为 11 位，它的取值范围为 0~2047。IEEE 754 规定，**E 应该在真实值的基础上加上中间数 127（或 1023）之后，再转换为二进制存储**。

  因此，针对指数 E，浮点数的值可以分为三种不同的情况：

  ![image](http://img.cdn.firejq.com/jpg/2018/5/13/47c1622887394e9970f6eff4730e5fec.jpg)

  - E 不全为 0 或不全为 1 (Normalized)：

    此时，浮点数就采用上面的规则表示，即指数 E 的计算值减去 127（或 1023），得到真实值，再将有效数字 M 前加上第一位的 1。

  - E 全为 0（E = 0，即实际指数值为 0 - 127 = -127）：
    - 若有效数字 M 也全为 0，此时表示 0。
    - 若有效数字 M 不全为 0，则浮点数的指数 E 等于 -127（或者 -1023），有效数字 M 不再加上第一位的 1，而是还原为 0.xxxxxx 的小数。这样做是为了表示±0，以及接近于 0 的很小的数字。

  - E 全为 1（E = 255(10)，即实际指数值为 255 - 127 = 128）：
    - 若有效数字 M 全为 0，表示“± 无穷”infinity（正无穷 / 负无穷取决于符号位 s）。
    - 若有效数字 M 不全为 0，表示这个数不是一个数，即 NaN（Not a Number）。

### 3.2. 浮点数的精度问题

#### 3.2.1. 问题产生

通过 IEEE 754 标准存储浮点数，由于**实数的无限精度跟计算机的有限内存之间的矛盾**，会存在浮点数的精度问题。

在 IEEE 754 标准的浮点数存储规则中，需要将浮点数的小数部分转换为二进制。**将一个小数转化为二进制表示的方式是，不断的乘 2，取其中的整数部分**，这实质上相当于“移动”小数部分。

eg: 将 0.625 转换为二进制数
```
0.625 * 2 = 1.25, 整数部分为 1，小数部分为 0.25
0.25 * 2 = 0.5 , 整数部分为 0，小数部分为 0.5
0.5 * 2 = 1 , 整数部分为 1，小数部分为 0
```
因此，0.625 的二进制表示就是 0.101。

然而有些小数，并不能够精确的转化为二进制表示。

eg: 将 0.4 转化为二进制数
```
0.4*2=0.8 整数部分为 0，小数部分为 0.8
0.8*2=1.6 整数部分为 1，小数部分为 0.6
0.6*2=1.2 整数部分为 1，小数部分为 0.2
0.2*2=0.4 整数部分为 0，小数部分为 0.4
0.4*2=0.8 整数部分为 0，小数部分为 0.8
0.8*2=1.6 整数部分为 1，小数部分为 0.6
0.6*2=1.2 整数部分为 1，小数部分为 0.2
... ...

```
实际上这永远算不完，也就是说，0.4 的二进制表示是 0.0110... 这样一个无限循环小数。

由于计算机的内存、CPU 寄存器等等这些硬件单元都是有限的，只能表示有限位数的二进制位，因此存储的二进制小数就会和实际转换而成的二进制数有一定的误差，在各种编程语言（如 C++、Java、python）的实现中对浮点数精度的规定也各不相同。

P.S.

> 中关村配置最高的电子计算机的计算精度还不如一个便利店卖的手持计算器。再简陋的计算器也比超级计算器的精度高，关键不在于它的频率和内存，而在于它是如何设计、如何表示、如何计算的。

在科学计算器（如 CASIO fx-82es/991es 函数式计算器）中，由于小数存储采用的不是 IEEE 754 标准（用浮点数存储小数），而是**用定点数来存储小数**，因此不会存在这样的精度问题。事实上，为解决浮点数的精度问题，java 中的 BigDecimal、C# 中的货币类型、MySQL 中的 NUMERIC 类型都是这么干的（用定点数存储小数）。

#### 3.2.2. 问题表现

一般来讲，`==` 和 `!=` 在针对浮点数比较时候，如果两边都是字面量，那么不会出现精度问题。但如果有一边是计算出来的，就会出现浮点数精度问题导致的奇怪现象。以 Java 为例，由于浮点数 0.1 在计算机中实际上并不存在（只是近似拟合），因此对两个不存在的值进行相加，就会得到一些奇怪的误差。

eg:
```java
jshell> 0.1 + 0.1 == 0.2
$1 ==> true

jshell> 0.1 + 0.1 + 0.1 == 0.3
$2 ==> false

jshell> 0.1 + 0.1 + 0.1 + 0.1 == 0.4
$3 ==> true

jshell> 0.1 + 0.2 == 0.3
$4 ==> false

jshell> 0.2 + 0.4
$5 ==> 0.6000000000000001

jshell> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1
$6 ==> 0.8999999999999999
```

但只要是精度以内的二进制有限数字就可以避免此问题，如 `0.25 + 0.25` 肯定就 `==0.5`，因为 0.25 可以用浮点数精确表示。但需要注意的是，能精确表示的浮点数占比非常少，0.1 到 0.9 的 9 个小数中，只有 0.5 可以用二进制精确的表示，事实上，如果把浮点数的范围比做地球，那么可以精确表示的浮点数还不到一粒芝麻大。

#### 3.2.3. 问题规避

因此，**通常不建议直接将两个浮点数进行大小比较或者做精确的计算，往往会导致得到意想不到的结果**。在需要对浮点数进行比较计算时，不应使用 `==` 或 `!=`，而应该设法转化成 `>=` 或 `<=` 的形式。

eg:
```
if (x == 0.0) // 隐含错误的比较
```
转化为
```
if ((x >= -EPSINON) && (x <= EPSINON)) // 其中 EPSINON 是允许的误差（即精度），如 1e-8
```

### 3.3. 实例

- 例 1：将 20.59375(10) 转换成 IEEE754 标准的 32 位二进制浮点数。

  分析：float 类型共 32 位，1 位符号位，8 位指数位，23 位尾数位

  步骤：

  1. 将 20.59375(10) 的整数和小数部分分别转换为二进制：

      - 20 转换为 10100.
      - 0.59375 采取乘 2 取整数位的方法（如下图），转换为 0.10011:
        ```
        0.59375 * 2 = 1.1875  整数部分为 1，小数部分为 0.1875
        0.1875 * 2  = 0.375   整数部分为 0，小数部分为 0.375
        0.375 * 2   = 0.75    整数部分为 0，小数部分为 0.75
        0.75 * 2    = 1.5     整数部分为 1，小数部分为 0.5
        0.5 * 2     = 1.0     整数部分为 1，小数部分为 0
        ```
        因此，取其中的整数部分，20.59375(10) = 10100.10011(2).

  1. 化为科学计数法：(-1)^0x1.010010011x2^4.
  1. 因此，S=0，E=4+127=131=10000011，M=0100 1001 1000 0000 0000 000.
  1. 20.59375 的 IEEE754 表示法为：`0 10000011 01001 0011 0000 0000 0000`.

- 例 2：已知 double 类型 38414.4, 求：其对应的二进制表示。

  分析：double 类型共计 64 位； 1 位是符号位，11 位是指数位，52 位是尾数位。

  步骤：按照 IEEE 浮点数表示法，下面先把 38414.4 转换为二进制数，把整数部和小数部分开处理：

  1. 整数部分转换为二进制：1001011000001110。
  1. 小数的处理：0.4=0.5*0+0.25*1+0.125*1+0.0625*0+……

      由于存在著名的**浮点数精度问题**，所以直到加上前面的整数部分算够 53 位就行了。如果你够耐心，手工算到 53 位那么因该是：
      ```
      38414.4(10)=1001011000001110.0110011001100110011001100110011001100(2)。
      ```
      再转换为科学记数法：`1.001011000001110 0110011001100110011001100110011001100`，左移了 15 位，所以指数为 15。即表达式为：
      ```
      (-1)^0x1.001011000001110 0110011001100110011001100110011001100×2^15
      ```
      因此：
      - 符号位 S = 0.
      - 指数`E=（15+1023）10 = 1038（10）= 100 0000 1110(2)`.
      - 尾数`M = 001011000001110 0110011001100110011001100110011001100`（舍去最高位 1.）.
      合在一起得到浮点数 38414.4 的二进制表示：
      ```
      01000000 11100010 11000001 110 01100  11001100  11001100  11001100  11001100
      ```

- 例 3：浮点数 x 的 IEEE754 标准储存格式为 0x0000 0009，则其浮点数的十进制数值为 0.000000.

  ![image](http://img.cdn.firejq.com/jpg/2018/5/13/487853a5574e4761fa1b845528fc8886.jpg)

  分析：
  - 首先，将十六进制数 0x00000009 展开成二进制：0 00000000 000 0000 0000 0000 0000 1001，得到第一位符号位 s=0，后面 8 位的指数 E=00000000，最后 23 位的有效数字 M=000 0000 0000 0000 0000 1001。
  - 由于指数 E 全为 0，所以符合上一节的第二种情况。因此，浮点数 V 就写成：
    ```
    V=(-1)^0×0.00000000000000000001001×2^(-126)=1.001×2^(-146)
    ```
  - 显然，V 是一个很小的接近于 0 的正数，所以用十进制小数表示就是 0.000000。

- 例 4：用二进制表示的浮点数 9.0，还原成十进制结果是 1091567616：

  分析：
  - 首先，浮点数 9.0 等于二进制的 1001.0，即 1.001×2^3。
  - 那么，第一位的符号位 s=0，有效数字 M 等于 001 后面再加 20 个 0，凑满 23 位，指数 E 等于 3+127=130，即 10000010。
  - 所以，写成二进制形式，应该是 S+E+M，即 0 10000010 001 0000 0000 0000 0000 0000。这个 32 位的二进制数，还原成十进制，正是 1091567616。

## 4. 字符表示

由于数字计算机只能处理二进制数据，因此字符信息存储到计算机中时都必要转化成二进制格式的代码，即符号数据。

目前国际上普遍采用的一种字符系统是七单位的 IRA 码，其美国版称为 ASCII 码。它用一个字节来表示，低 7 位用来编码（128 个），最高位为校验位。

## 5. Refer Links

[浮点数的二进制表示 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html)

[浮点数的表示和基本运算](https://www.cnblogs.com/FlyingBread/archive/2009/02/15/660206.html)

[深入理解计算机系统（2.7）--- 二进制浮点数，IEEE 标准](https://www.cnblogs.com/zuoxiaolong/p/computer11.html)

[浮点数的二进制表示学习笔记](http://blog.163.com/yql_bl/blog/static/847851692008112013117685/)

[你应该知道的浮点数基础知识](http://cenalulu.github.io/linux/about-denormalized-float-number/)

[为什么说浮点数缺乏精确性？ python 中浮点数运算问题](https://www.zhihu.com/question/25457573)

[对于同样的浮点数运算为何 Java 与 C 的结果不相同？](https://www.zhihu.com/question/26165631)

[计算器是怎么避免浮点数不精确的问题的？](https://www.zhihu.com/question/27674576)

[有没有使用“==”判断浮点数相等与否出现错误的例子？](https://www.zhihu.com/question/21175703)

[代码之谜（四）- 浮点数（从惊讶到思考）](http://justjavac.com/codepuzzle/2012/11/02/codepuzzle-float-from-surprised-to-ponder.html)

[代码之谜（五）- 浮点数（谁偷了你的精度？）](http://justjavac.com/codepuzzle/2012/11/11/codepuzzle-float-who-stole-your-accuracy.html)
